ğŸ‘‰ Problem: Maximum Subarray (Kadaneâ€™s Algorithm)

You must find the contiguous subarray that gives the maximum total sum.

âœ… Key Idea

"If your running sum becomes negative, throw it away and start fresh."

âœ¨ Flashcard

Kadane = keep adding; if sum < 0 â†’ reset; track max.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with two trackers

maxSum â† first element of the array
(This ensures answer always includes at least one number)

curSum â† 0
(Your temporary running sum)

Step 2 â€” Begin scanning the array from left to right

For each number in the array:

Step 3 â€” If the running sum became negative

Drop it.

Restart the subarray from the next number.

Why?
A negative running sum will only pull future sums down.

So mentally say:
â€œcurSum < 0? Reset to 0.â€

Step 4 â€” Add the current number to your running total

Extend the current subarray by including this number.

curSum grows as long as you are gaining value.

Step 5 â€” Update the global best

After adding each number:

Compare curSum with maxSum

If curSum is higher â†’ update maxSum

This ensures you always keep track of the best subarray seen so far.

Step 6 â€” Finish

After scanning all numbers:

The value in maxSum is the maximum subarray sum.

ğŸ§  Mental Map (Very Simple)

Imagine walking through numbers with a backpack:

Add each number to your backpack.

If the items in the backpack make the total weight negative,
empty the backpack and start collecting freshly.

Always remember the heaviest backpack value seen.

â±ï¸ Complexity

Time: O(n) â†’ one pass

Space: O(1) â†’ only two variables

You can also write:
ğŸ“Œ For the sliding window version
ğŸ“Œ For the divide & conquer solution
ğŸ“Œ For returning indices or subarray

ğŸ‘‰ Problem: Maximum Sum Circular Subarray (LeetCode 918)

You must find the maximum subarray sum, but the array is circular â€” meaning the end wraps around to the start.

âœ… Key Idea

There are two possible types of max subarrays:

1ï¸âƒ£ Normal (Non-Circular) Subarray

Example:
[1, -2, 3, -2] â†’ best is [3] â†’ sum = 3
Just run Kadaneâ€™s algorithm.

2ï¸âƒ£ Circular Subarray

The subarray â€œwraps aroundâ€ the end â†’ start.

Example:
[5, -3, 5] best circular = [5, ?, 5] = 10 â†’ sum = 10

How to find this?

ğŸ‘‰ Circular max sum = total sum âˆ’ minimum subarray sum

Because:

Removing the minimum middle part gives the maximum wrapping part.

âœ¨ Flashcard

"Max = max(normalKadane, total âˆ’ minKadane). But if all numbers are negative â†’ return max normal only."

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the normal maximum subarray sum

Use standard Kadane:

Keep adding numbers.

When sum < 0 â†’ reset to 0.

Track the largest sum seen.

This gives:

max_normal


This solves the non-wrapping case.

Step 2 â€” Compute the minimum subarray sum

Do Kadane again, but inverted:

Keep adding numbers.

When sum > 0 â†’ reset to 0.

Track the smallest (most negative) sum seen.

This gives:

min_subarray


This helps us compute the maximum circular sum.

Step 3 â€” Compute total sum of all elements
total_sum = sum(nums)


This is needed for wrapping logic.

Step 4 â€” Compute circular subarray sum
max_circular = total_sum âˆ’ min_subarray


This essentially removes the worst (minimum) middle part to form a wrapping subarray.

Step 5 â€” Edge Case: All numbers are negative

If all numbers are negative:

The minimum subarray = total sum

So: total_sum â€“ min_subarray = 0 (invalid empty subarray)

So in this case:
âœ” Return only max_normal

Because circular sum is not allowed to be empty.

Step 6 â€” Final Answer
answer = max(max_normal, max_circular)

ğŸ§  Mental Map (Super Simple)

Think of the array having two choices:

1ï¸âƒ£ Best is inside the array normally.

Just Kadane.

2ï¸âƒ£ Best is across the ends.

Take the whole array â†’ remove the worst part â†’ that creates a wrap.

Compare both â†’ pick larger.
â±ï¸ Complexity

Time: O(n)

Space: O(1)

ğŸ” Short Examples
Example 1: [1, -2, 3, -2]

max_normal = 3

min_subarray = -2

total = 0

max_circular = 0 âˆ’ (-2) = 2 â†’ but 3 is bigger

Answer = 3

Example 2: [5, -3, 5]

max_normal = 7

min_subarray = -3

total = 7

max_circular = 7 âˆ’ (-3) = 10

Answer = 10

Example 3: [-3, -2, -3]

All negative â†’ must return largest (least negative)

Answer = -2

ğŸ‘‰ Problem: Longest Turbulent Subarray (LeetCode 978)

You are given an integer array arr.
A turbulent subarray is one where the comparison signs alternate between adjacent elements:

Either: > < > < â€¦

Or: < > < > â€¦

Return the length of the longest turbulent subarray.

âœ… Key Idea

Use a sliding window / two counters approach:

Track two lengths while scanning:

up â†’ current subarray ends with <

down â†’ current subarray ends with >

Whenever the sign flips, extend the subarray.

Reset when adjacent numbers are equal.

âœ¨ Flashcard:
"Compare neighbors. If sign flips â†’ extend subarray. Equal â†’ reset."

âš¡ Full Approach (Step-by-Step)
Step 1 â€” Handle edge case

If the array has only one element â†’ return 1.

Step 2 â€” Initialize

max_len = 1 (at least one element counts)

up = 1, down = 1 (lengths of turbulent subarrays ending in < or >)

Step 3 â€” Loop through array

For each index i from 1 to n-1:

Compare arr[i] with arr[i-1]

If arr[i] > arr[i-1]:

up = down + 1 (flip happened)

down = 1 (reset opposite direction)

Else if arr[i] < arr[i-1]:

down = up + 1

up = 1

Else:

Equal â†’ reset both: up = down = 1

Update max_len = max(max_len, up, down)

Step 4 â€” Return

max_len after scanning the array.

â±ï¸ Complexity

Time: O(n) â†’ single pass

Space: O(1) â†’ only 3 variables

ğŸ“ Example Dry Run
Example 1: [9,4,2,10,7,8,8,1,9]

Compare 9>4 â†’ down=2, up=1 â†’ max_len=2

Compare 4>2 â†’ down=2, up=1 â†’ max_len=2

Compare 2<10 â†’ up=down+1=3, down=1 â†’ max_len=3

Compare 10>7 â†’ down=up+1=4, up=1 â†’ max_len=4

Compare 7<8 â†’ up=down+1=5, down=1 â†’ max_len=5

Compare 8=8 â†’ reset â†’ up=down=1

Compare 8>1 â†’ down=up+1=2, up=1

Compare 1<9 â†’ up=down+1=3, down=1

Final max_len = 5



ğŸ‘‰ Problem: Contains Duplicate II (Leet code 219)

You must determine whether any number appears twice within a distance of k from each other.

âœ… Key Idea

â€œKeep a sliding window of size at most k.
If a number reappears inside that window â†’ duplicate found.â€

You donâ€™t need to search the entire array â€” only look k steps back.

âœ¨ Flashcard

Nearby duplicate =
â€œUse a sliding window set.
If window grows > k â†’ remove leftmost.
If current number already in set â†’ True.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a sliding window

Use a set to store the last few elements youâ€™ve seen.

Call it:
window â† empty set

Also keep a pointer:
left â† 0
(This marks the start of the sliding window)

Step 2 â€” Walk through the array using right pointer

For each index right, you check the current number nums[right].

Step 3 â€” Ensure the window never becomes larger than k

If the distance (right - left) becomes bigger than k,
you must remove nums[left] from the window â†’ slide forward.

Why?
Because any element more than k steps away is no longer allowed.

So think:
â€œWindow too big? Kick out the leftmost.â€

Then increase left.

Step 4 â€” Check for a duplicate inside the window

Before inserting the current number:

If nums[right] is already inside the window â†’
you found a value that appears again within â‰¤ k distance.

Return True immediately.

This is the core condition.

Step 5 â€” Add the current number to the window

After ensuring the window is valid and checking for duplicates,
insert the current number.

Step 6 â€” If loop finishes with no match

Return False.

This means no number repeated within k distance.

ğŸ§  Mental Map (Very Simple)

Imagine a sliding glass window that can only show k elements at a time.

You move the window from left to right.

If a number is seen again inside the window â†’ duplicate found.

If the window gets too wide â†’ push out the leftmost number.

â±ï¸ Complexity

Time: O(n)
(You visit each number once)

Space: O(k)
(Window holds at most k items)

If you'd like, I can also write:
ğŸ“Œ The hashmap version
ğŸ“Œ The brute-force explanation
ğŸ“Œ A visual example walk-through with emojis


ğŸ‘‰ Problem: Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Leetcode 1343)

Count Subarrays With Average â‰¥ Threshold

You are given:

arr â†’ an array of numbers

k â†’ size of subarray

threshold â†’ required minimum average

You must count:

How many subarrays of size k
have average â‰¥ threshold?

âœ¨ Key Idea

Instead of checking averages, we compare sum:

A subarray's average â‰¥ threshold
â‡” its sum â‰¥ threshold * k

Why?

average = sum / k
sum / k â‰¥ threshold  â†’  sum â‰¥ threshold * k


So we only need the sum, not the average.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the target sum

You need each windowâ€™s sum to be at least:

threshold * k


This avoids doing division and makes comparisons faster.

Step 2 â€” Start by summing the first window of size k

Take the first k elements and compute their sum.

If this sum â‰¥ target sum â†’ count it.

Step 3 â€” Slide the window across the array (1 step at a time)

When sliding from one window to the next:

Add the new element on the right

Remove the element that is leaving from the left

This keeps the window always of size k.

This takes O(1) per step.

Step 4 â€” After each slide, compare the window sum

If window_sum â‰¥ target_sum â†’ increase answer.

Step 5 â€” Continue until the end of the array

Return how many windows qualified.

ğŸ§  Mental Picture

Imagine a window that covers exactly k numbers.

You slide this window across the array from left to right.

At each position:

Check if the total inside the window is â€œheavy enoughâ€

If yes â†’ count it

This is classical sliding window.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one pass through the array.

If you want, I can also rewrite this in:
ğŸ“Œ Flashcard format
ğŸ“Œ Step-by-step dry run with example
ğŸ“Œ Visual diagram of sliding windows