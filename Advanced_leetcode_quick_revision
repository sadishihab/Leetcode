ğŸ‘‰ Problem: Maximum Subarray (Kadaneâ€™s Algorithm)

You must find the contiguous subarray that gives the maximum total sum.

âœ… Key Idea

"If your running sum becomes negative, throw it away and start fresh."

âœ¨ Flashcard

Kadane = keep adding; if sum < 0 â†’ reset; track max.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with two trackers

maxSum â† first element of the array
(This ensures answer always includes at least one number)

curSum â† 0
(Your temporary running sum)

Step 2 â€” Begin scanning the array from left to right

For each number in the array:

Step 3 â€” If the running sum became negative

Drop it.

Restart the subarray from the next number.

Why?
A negative running sum will only pull future sums down.

So mentally say:
â€œcurSum < 0? Reset to 0.â€

Step 4 â€” Add the current number to your running total

Extend the current subarray by including this number.

curSum grows as long as you are gaining value.

Step 5 â€” Update the global best

After adding each number:

Compare curSum with maxSum

If curSum is higher â†’ update maxSum

This ensures you always keep track of the best subarray seen so far.

Step 6 â€” Finish

After scanning all numbers:

The value in maxSum is the maximum subarray sum.

ğŸ§  Mental Map (Very Simple)

Imagine walking through numbers with a backpack:

Add each number to your backpack.

If the items in the backpack make the total weight negative,
empty the backpack and start collecting freshly.

Always remember the heaviest backpack value seen.

â±ï¸ Complexity

Time: O(n) â†’ one pass

Space: O(1) â†’ only two variables

You can also write:
ğŸ“Œ For the sliding window version
ğŸ“Œ For the divide & conquer solution
ğŸ“Œ For returning indices or subarray

ğŸ‘‰ Problem: Maximum Sum Circular Subarray (LeetCode 918)

You must find the maximum subarray sum, but the array is circular â€” meaning the end wraps around to the start.

âœ… Key Idea

There are two possible types of max subarrays:

1ï¸âƒ£ Normal (Non-Circular) Subarray

Example:
[1, -2, 3, -2] â†’ best is [3] â†’ sum = 3
Just run Kadaneâ€™s algorithm.

2ï¸âƒ£ Circular Subarray

The subarray â€œwraps aroundâ€ the end â†’ start.

Example:
[5, -3, 5] best circular = [5, ?, 5] = 10 â†’ sum = 10

How to find this?

ğŸ‘‰ Circular max sum = total sum âˆ’ minimum subarray sum

Because:

Removing the minimum middle part gives the maximum wrapping part.

âœ¨ Flashcard

"Max = max(normalKadane, total âˆ’ minKadane). But if all numbers are negative â†’ return max normal only."

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the normal maximum subarray sum

Use standard Kadane:

Keep adding numbers.

When sum < 0 â†’ reset to 0.

Track the largest sum seen.

This gives:

max_normal


This solves the non-wrapping case.

Step 2 â€” Compute the minimum subarray sum

Do Kadane again, but inverted:

Keep adding numbers.

When sum > 0 â†’ reset to 0.

Track the smallest (most negative) sum seen.

This gives:

min_subarray


This helps us compute the maximum circular sum.

Step 3 â€” Compute total sum of all elements
total_sum = sum(nums)


This is needed for wrapping logic.

Step 4 â€” Compute circular subarray sum
max_circular = total_sum âˆ’ min_subarray


This essentially removes the worst (minimum) middle part to form a wrapping subarray.

Step 5 â€” Edge Case: All numbers are negative

If all numbers are negative:

The minimum subarray = total sum

So: total_sum â€“ min_subarray = 0 (invalid empty subarray)

So in this case:
âœ” Return only max_normal

Because circular sum is not allowed to be empty.

Step 6 â€” Final Answer
answer = max(max_normal, max_circular)

ğŸ§  Mental Map (Super Simple)

Think of the array having two choices:

1ï¸âƒ£ Best is inside the array normally.

Just Kadane.

2ï¸âƒ£ Best is across the ends.

Take the whole array â†’ remove the worst part â†’ that creates a wrap.

Compare both â†’ pick larger.
â±ï¸ Complexity

Time: O(n)

Space: O(1)

ğŸ” Short Examples
Example 1: [1, -2, 3, -2]

max_normal = 3

min_subarray = -2

total = 0

max_circular = 0 âˆ’ (-2) = 2 â†’ but 3 is bigger

Answer = 3

Example 2: [5, -3, 5]

max_normal = 7

min_subarray = -3

total = 7

max_circular = 7 âˆ’ (-3) = 10

Answer = 10

Example 3: [-3, -2, -3]

All negative â†’ must return largest (least negative)

Answer = -2

ğŸ‘‰ Problem: Longest Turbulent Subarray (LeetCode 978)

You are given an integer array arr.
A turbulent subarray is one where the comparison signs alternate between adjacent elements:

Either: > < > < â€¦

Or: < > < > â€¦

Return the length of the longest turbulent subarray.

âœ… Key Idea

Use a sliding window / two counters approach:

Track two lengths while scanning:

up â†’ current subarray ends with <

down â†’ current subarray ends with >

Whenever the sign flips, extend the subarray.

Reset when adjacent numbers are equal.

âœ¨ Flashcard:
"Compare neighbors. If sign flips â†’ extend subarray. Equal â†’ reset."

âš¡ Full Approach (Step-by-Step)
Step 1 â€” Handle edge case

If the array has only one element â†’ return 1.

Step 2 â€” Initialize

max_len = 1 (at least one element counts)

up = 1, down = 1 (lengths of turbulent subarrays ending in < or >)

Step 3 â€” Loop through array

For each index i from 1 to n-1:

Compare arr[i] with arr[i-1]

If arr[i] > arr[i-1]:

up = down + 1 (flip happened)

down = 1 (reset opposite direction)

Else if arr[i] < arr[i-1]:

down = up + 1

up = 1

Else:

Equal â†’ reset both: up = down = 1

Update max_len = max(max_len, up, down)

Step 4 â€” Return

max_len after scanning the array.

â±ï¸ Complexity

Time: O(n) â†’ single pass

Space: O(1) â†’ only 3 variables

ğŸ“ Example Dry Run
Example 1: [9,4,2,10,7,8,8,1,9]

Compare 9>4 â†’ down=2, up=1 â†’ max_len=2

Compare 4>2 â†’ down=2, up=1 â†’ max_len=2

Compare 2<10 â†’ up=down+1=3, down=1 â†’ max_len=3

Compare 10>7 â†’ down=up+1=4, up=1 â†’ max_len=4

Compare 7<8 â†’ up=down+1=5, down=1 â†’ max_len=5

Compare 8=8 â†’ reset â†’ up=down=1

Compare 8>1 â†’ down=up+1=2, up=1

Compare 1<9 â†’ up=down+1=3, down=1

Final max_len = 5



ğŸ‘‰ Problem: Contains Duplicate II (Leet code 219)

You must determine whether any number appears twice within a distance of k from each other.

âœ… Key Idea

â€œKeep a sliding window of size at most k.
If a number reappears inside that window â†’ duplicate found.â€

You donâ€™t need to search the entire array â€” only look k steps back.

âœ¨ Flashcard

Nearby duplicate =
â€œUse a sliding window set.
If window grows > k â†’ remove leftmost.
If current number already in set â†’ True.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a sliding window

Use a set to store the last few elements youâ€™ve seen.

Call it:
window â† empty set

Also keep a pointer:
left â† 0
(This marks the start of the sliding window)

Step 2 â€” Walk through the array using right pointer

For each index right, you check the current number nums[right].

Step 3 â€” Ensure the window never becomes larger than k

If the distance (right - left) becomes bigger than k,
you must remove nums[left] from the window â†’ slide forward.

Why?
Because any element more than k steps away is no longer allowed.

So think:
â€œWindow too big? Kick out the leftmost.â€

Then increase left.

Step 4 â€” Check for a duplicate inside the window

Before inserting the current number:

If nums[right] is already inside the window â†’
you found a value that appears again within â‰¤ k distance.

Return True immediately.

This is the core condition.

Step 5 â€” Add the current number to the window

After ensuring the window is valid and checking for duplicates,
insert the current number.

Step 6 â€” If loop finishes with no match

Return False.

This means no number repeated within k distance.

ğŸ§  Mental Map (Very Simple)

Imagine a sliding glass window that can only show k elements at a time.

You move the window from left to right.

If a number is seen again inside the window â†’ duplicate found.

If the window gets too wide â†’ push out the leftmost number.

â±ï¸ Complexity

Time: O(n)
(You visit each number once)

Space: O(k)
(Window holds at most k items)



ğŸ‘‰ Problem: Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Leetcode 1343)

Count Subarrays With Average â‰¥ Threshold

You are given:

arr â†’ an array of numbers

k â†’ size of subarray

threshold â†’ required minimum average

You must count:

How many subarrays of size k
have average â‰¥ threshold?

âœ¨ Key Idea

Instead of checking averages, we compare sum:

A subarray's average â‰¥ threshold
â‡” its sum â‰¥ threshold * k

Why?

average = sum / k
sum / k â‰¥ threshold  â†’  sum â‰¥ threshold * k


So we only need the sum, not the average.

âœ¨ Flashcard (Short Memory Trick)

Count subarrays avg â‰¥ threshold =
â€œUse sliding window sum.
Target = threshold Ã— k.
Build first window.
Slide: add right, remove left.
If sum â‰¥ target â†’ count.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the target sum

You need each windowâ€™s sum to be at least:

threshold * k


This avoids doing division and makes comparisons faster.

Step 2 â€” Start by summing the first window of size k

Take the first k elements and compute their sum.

If this sum â‰¥ target sum â†’ count it.

Step 3 â€” Slide the window across the array (1 step at a time)

When sliding from one window to the next:

Add the new element on the right

Remove the element that is leaving from the left

This keeps the window always of size k.

This takes O(1) per step.

Step 4 â€” After each slide, compare the window sum

If window_sum â‰¥ target_sum â†’ increase answer.

Step 5 â€” Continue until the end of the array

Return how many windows qualified.

ğŸ§  Mental Picture

Imagine a window that covers exactly k numbers.

You slide this window across the array from left to right.

At each position:

Check if the total inside the window is â€œheavy enoughâ€

If yes â†’ count it

This is classical sliding window.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one pass through the array.



ğŸ‘‰ Problem: Minimum Size Subarray Sum (Leetcode 209)
Find the shortest subarray whose sum â‰¥ target.
You are given:


nums â†’ array of positive integers


target â†’ required minimum sum


You must return:


The minimal length of a subarray whose sum â‰¥ target


Return 0 if no such subarray exists



âœ¨ Key Idea
This is a classic sliding window problem.
Because all numbers are positive,
â†’ expanding the right pointer always increases the sum
â†’ shrinking the left pointer always decreases the sum
So two-pointer sliding window works perfectly.

âœ¨ Flashcard

Minimum Size Subarray Sum =
â€œUse sliding window (positive nums).
Grow R until sum â‰¥ target.
Shrink L to minimize window.
Track shortest valid size.
If never valid â†’ return 0.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers


L â†’ start of the window


R â†’ end of the window


total â†’ sum inside the window


min_length â†’ initialized to âˆ



Step 2 â€” Expand the window by moving R
For each new element:
total += nums[R]

Keep adding numbers until total â‰¥ target.

Step 3 â€” When the window meets the requirement
Whenever:
total â‰¥ target

We found a valid subarray.
Now we try to shrink it from the left to make it as small as possible.
Update the answer:
min_length = min(min_length, R - L + 1)


Step 4 â€” Shrink from the left
Remove nums[L] from the window:
total -= nums[L]
L += 1

Continue shrinking while the sum still â‰¥ target.
This finds the shortest valid window for this R.

Step 5 â€” Continue until R reaches the end
If no valid window was ever found â†’ return 0.

ğŸ§  Mental Picture
Imagine a window sliding across the array.


It grows until it is heavy enough (sum â‰¥ target)


Then it shrinks to find the smallest valid size


Then it grows again


This ensures we find the minimum valid window.

â±ï¸ Complexity
OperationCostTimeO(n)SpaceO(1)
Each pointer moves at most n steps â†’ linear time.

âœ”ï¸ Examples Explained
Example 1
target = 7
nums = [2,3,1,2,4,3]
Valid windows with sum â‰¥ 7 include:


[2,3,1,2] â†’ length 4


[3,1,2,4] â†’ length 4


[4,3] â†’ length 2 (smallest)


Answer: 2

Example 2
target = 4
nums = [1,4,4]
The subarrays:


[4] â†’ length 1


[4] â†’ length 1


Answer: 1

Example 3
target = 11
nums = [1,1,1,1,1,1,1,1]
All sums are â‰¤ 8 â†’ no subarray can reach 11.
Answer: 0


ğŸ‘‰ Problem: Longest Substring Without Repeating Characters (leetcode 03)

Find the length of the longest substring (continuous sequence)
with no repeating characters.

You are given:

s â†’ a string

Return:

The maximum length of any substring where all characters are unique

âœ¨ Key Idea

Use a sliding window with:

L â†’ left pointer

R â†’ right pointer

a set to store characters currently inside the window

We expand the window with R, and if a duplicate appears,
we shrink from the left until the window becomes valid again.

âœ¨ Flashcard

Longest substring without repeating chars =
â€œUse sliding window set.
If char not in set â†’ add & update max.
If duplicate â†’ shrink L removing chars until gone.
Window always stays unique.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L starts at 0

R loops over every character

A set window stores the characters currently inside the window

Step 2 â€” Expand the window by adding s[R]

If s[R] is not in the set:

Add it

Update max length

If s[R] is in the set â†’ we have a duplicate.

Step 3 â€” Shrink from the left when duplicate found

While s[R] is already in the window:

Remove s[L] from the set

Move L to the right

Repeat until duplicate disappears

Now the window is valid again.

Step 4 â€” Track the maximum window size

At each step:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue until R reaches the end

Return the maximum.

ğŸ§  Mental Picture

Imagine a window sliding across the string:

Expand as long as all characters are unique

When you hit a duplicate â†’ shrink from the left

Keep only the valid "unique character substring" inside the window

Track the largest window ever formed

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(min(n, charset))

Since each pointer moves at most n times.


âœ”ï¸ Example Outputs
Example 1

s = "abcabcbb"
Longest: "abc" â†’ length 3

Example 2

s = "bbbbb"
Longest: "b" â†’ length 1

Example 3

s = "pwwkew"
Longest: "wke" â†’ length 3

If you want, you can also do it by:

ğŸ“Œ A version using a dictionary instead of a set (faster)

ğŸ‘‰ Problem: Longest Repeating Character Replacement (leetcode 424)

You are given:

s â†’ a string of uppercase letters

k â†’ maximum number of character replacements allowed

You may:

Change any character to any other uppercase letter

Perform this operation at most k times

Return:

The length of the longest substring that can be made of the same character, after using at most k replacements.

âœ¨ Key Idea

We want a substring where:

Most characters are the same

And we can fix the rest (up to k characters) by replacing them

Inside any window:

replacements needed = window_size - count_of_most_frequent_char_in_window


For the window to be valid:

window_size - max_freq â‰¤ k


This tells us whether the window can be turned into all identical letters.

âœ¨ Flashcard

Longest Repeating Character Replacement =
â€œUse sliding window freq map.
Track max_freq inside window.
Window valid if size âˆ’ max_freq â‰¤ k.
If invalid â†’ shrink L.
Track largest valid window.â€

ğŸ§  Mental Picture

Imagine a window sliding across the string.

At each step:

Count how many characters already match

Calculate how many characters need replacing

If replacements needed â‰¤ k â†’ good window

If too many replacements â†’ shrink from left

Keep the largest valid window

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Sliding window with L and R

Expand the window by moving R

Keep frequency counts of letters in the window

Track max_freq = the highest frequency of any character in the current window

Step 2 â€” Check if the window is valid

A window is valid if:

(R - L + 1) - max_freq â‰¤ k


Meaning:

Total characters

Minus the number of already-matching characters

Must be â‰¤ k replacements allowed

If valid â†’ we can expand further.

Step 3 â€” If window becomes invalid

Shrink from the left:

reduce count of s[L]
L += 1


We donâ€™t need to reduce max_freq strictly, because:

Letting it stay slightly outdated does not break correctness

The window size only grows to valid sizes

This is a well-known trick that keeps the code O(n).

Step 4 â€” Track maximum window size

Whenever the window is valid:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue to end of string

Return the largest valid window found.



â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

26 uppercase letters â†’ constant extra space.

âœ”ï¸ Example Results
Example 1

s = "ABAB", k = 2
We can make all letters 'A' or 'B'.

Max length = 4

Example 2

s = "AABABBA", k = 1
Best substring â†’ "BBBB" after one change.

Max length = 4


ğŸ‘‰ Problem: Valid Palindrome (LeetCode 125)

You are given:

s â†’ a string consisting of printable ASCII characters (letters, digits, punctuation, spaces)

You may:

Convert uppercase letters to lowercase

Remove all non-alphanumeric characters

Return:

true if the resulting string reads the same forward and backward, otherwise false.

âœ¨ Key Idea

We want to check if a string is a palindrome ignoring cases and non-alphanumeric characters.

Use two pointers:

L starts at the beginning

R starts at the end

At each step:

Skip non-alphanumeric characters

Compare characters in lowercase

If mismatch â†’ return false

If pointers meet â†’ return true

âœ¨ Flashcard

Valid Palindrome =
â€œUse two pointers. Skip non-alphanumeric. Compare lowercase. If all match â†’ palindrome.â€

ğŸ§  Mental Picture

Imagine a window sliding inwards from both ends:

Ignore spaces, punctuation, etc.

Compare letters and digits

Shrink inward until pointers meet

If all comparisons pass â†’ palindrome

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers
L = 0, R = len(s) - 1

Step 2 â€” Skip invalid characters
While L < R:

Move L forward if s[L] is not alphanumeric

Move R backward if s[R] is not alphanumeric

Step 3 â€” Compare characters

Convert s[L] and s[R] to lowercase

If they are different â†’ return false

Else â†’ move L += 1 and R -= 1

Step 4 â€” Repeat until pointers meet

If loop finishes without mismatch â†’ return true

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan string once
Space	O(1) â†’ constant extra space for pointers

âœ”ï¸ Example Results

Example 1

Input: "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome


Example 2

Input: "race a car"
Output: false
Explanation: "raceacar" is not a palindrome

Example 3

Input: " "
Output: true
Explanation: empty string is trivially a palindrome



ğŸ‘‰ Problem: Two Sum II - Input Array Is Sorted (LeetCode 167)

You are given:

numbers â†’ a 1-indexed array of integers, sorted in non-decreasing order

target â†’ a number

You may:

Pick two distinct numbers from the array

Add them to equal target

Return:

[index1, index2] â†’ the 1-based indices of the two numbers that sum to target

Constraints:

Exactly one solution exists

Cannot use the same element twice

Must use constant extra space

âœ¨ Key Idea

Since the array is sorted, we can use two pointers:

L â†’ starts at the beginning

R â†’ starts at the end

At each step:

Calculate current_sum = numbers[L] + numbers[R]

If current_sum == target â†’ solution found â†’ return [L+1, R+1]

If current_sum < target â†’ move L right to increase sum

If current_sum > target â†’ move R left to decrease sum

This works because the array is sorted â†’ moving pointers adjusts the sum in a predictable way.

âœ¨ Flashcard

Two Sum II =
â€œUse two pointers on sorted array. Compare sum to target. Move L or R accordingly. Return 1-based indices.â€

ğŸ§  Mental Picture

Imagine two fingers: one at the start, one at the end of the array

Compare their sum to the target

Move fingers closer together until sum matches the target

One pass â†’ finds the solution efficiently

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0
R = len(numbers) - 1


Step 2 â€” Move pointers while L < R

Calculate current_sum = numbers[L] + numbers[R]

Compare with target:

current_sum == target â†’ return [L+1, R+1]

current_sum < target â†’ move L += 1 to increase sum

current_sum > target â†’ move R -= 1 to decrease sum

Step 3 â€” Continue until solution found

Guaranteed because exactly one solution exists

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan array once
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: 2 + 7 = 9


Example 2

Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: 2 + 4 = 6


Example 3

Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: -1 + 0 = -1


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array (LeetCode 26 two pointers)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicate elements in-place

Keep the relative order of the unique elements

Return:

k â†’ the number of unique elements in the array

The first k elements of nums should be the unique numbers

Elements beyond index k-1 can be ignored

Constraints:

1 <= nums.length <= 3 * 10^4

-100 <= nums[i] <= 100

Array is sorted in non-decreasing order

âœ¨ Key Idea

Because the array is sorted, duplicates appear consecutively:

Use two pointers:

L â†’ slow pointer, tracks last unique element

R â†’ fast pointer, scans through the array

At each step:

Compare nums[R] with nums[L]

If different â†’ found a new unique number

Move L forward

Assign nums[L] = nums[R]

If same â†’ skip, R moves forward

At the end, L + 1 is the count of unique numbers

âœ¨ Flashcard

Remove Duplicates =
â€œUse two pointers on sorted array. L tracks last unique. R scans. When nums[R] != nums[L], move L and update. Return L + 1.â€

ğŸ§  Mental Picture

Imagine a slow finger L marking the last unique element

A fast finger R scans the array

Whenever a new number appears, copy it after L

Result: unique numbers shifted to the front, duplicates ignored

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0  # Last unique element index


Step 2 â€” Iterate with fast pointer

for R in range(1, len(nums)):


Step 3 â€” Check for new unique element

If nums[R] != nums[L] â†’ new number found

Move L += 1

Assign nums[L] = nums[R]

Step 4 â€” Continue until end of array

All unique elements are now from index 0 to L

Return L + 1 â†’ number of unique elements

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: unique elements are 1 and 2


Example 2

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: unique elements are 0,1,2,3,4


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array II (LeetCode 80)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicates in-place such that each unique element appears at most twice

Keep the relative order of elements

Return:

k â†’ number of elements after removing extra duplicates

The first k elements of nums should contain the final result

Elements beyond index k-1 can be ignored

Constraints:

Do not allocate extra space â†’ O(1) space

1 <= nums.length <= 3 * 10^4

-10^4 <= nums[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ slow pointer, tracks the position to write the next allowed element

R â†’ fast pointer, scans the array

Keep at most 2 duplicates:

Compare nums[R] with nums[L-2] (the element 2 steps behind the slow pointer)

If nums[R] != nums[L-2] â†’ it is allowed â†’ copy nums[R] to nums[L] and move L forward

If nums[R] == nums[L-2] â†’ more than 2 duplicates â†’ skip

This works because the array is sorted â†’ duplicates are consecutive

âœ¨ Flashcard

Remove Duplicates II =
â€œUse two pointers. Slow pointer writes allowed elements. Keep at most two duplicates. If nums[R] != nums[L-2] â†’ write nums[R]. Return L.â€

ğŸ§  Mental Picture

Slow pointer L â†’ marks next position to write allowed element

Fast pointer R â†’ scans through array

Only copy the element if it does not exceed two occurrences

At the end â†’ first L elements are the allowed numbers

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Handle edge case

if len(nums) <= 2:
    return len(nums)


If array has 0, 1, or 2 elements â†’ all are allowed

Step 2 â€” Initialize slow pointer

L = 2  # first two elements are always allowed


L points to next position to write

Start from index 2 because first two elements are always allowed

Step 3 â€” Iterate with fast pointer

for R in range(2, len(nums)):


R scans from the third element to the end

Step 4 â€” Check if current element is allowed

if nums[R] != nums[L - 2]:
    nums[L] = nums[R]
    L += 1


Compare with the element two steps behind slow pointer (nums[L-2])

If different â†’ allowed â†’ copy to nums[L] and move L forward

If same â†’ skip â†’ prevents more than 2 duplicates

Step 5 â€” Return number of allowed elements

return L


L is now the count of elements with at most two duplicates

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: keep at most two duplicates


Example 2

Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: keep at most two duplicates


ğŸ‘‰ Problem: Container With Most Water (LeetCode 11)

You are given:

height â†’ a list of vertical line heights

Each line is at coordinate (i, height[i])

You may:

Pick two lines to form a container with the x-axis

Return:

The maximum area of water the container can store

Constraints:

Cannot slant the container â†’ height is limited by the shorter line

2 <= height.length <= 10^5

0 <= height[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ start of array

R â†’ end of array

Area formula:

area
=
min
â¡
(
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ¿
]
,
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ‘…
]
)
Ã—
(
ğ‘…
âˆ’
ğ¿
)
area=min(height[L],height[R])Ã—(Râˆ’L)

Move the pointer pointing to the shorter line, because moving the taller line will never increase the area.

Keep track of maximum area seen so far.

âœ¨ Flashcard

Container With Most Water =
â€œTwo pointers at both ends. Area = min(height[L], height[R]) * width. Move shorter line pointer. Track max area.â€

ğŸ§  Mental Picture

Imagine a container formed by two vertical lines

Width = distance between lines

Height = shorter line

Slide the shorter line inward â†’ possible bigger height, maybe bigger area

Stop when pointers meet

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers and max area

L = 0
R = len(height) - 1
max_area = 0


L â†’ left pointer

R â†’ right pointer

max_area â†’ stores largest container area so far

Step 2 â€” Loop until pointers meet

while L < R:


Continue scanning all possible containers formed by L and R

Step 3 â€” Calculate area

current_area = min(height[L], height[R]) * (R - L)
max_area = max(max_area, current_area)


Width = R - L

Height = min(height[L], height[R])

Update max_area if current_area is larger

Step 4 â€” Move pointer pointing to shorter line

if height[L] < height[R]:
    L += 1
else:
    R -= 1


Move the smaller line pointer inward

Why? Because moving the taller line cannot increase area, but moving the shorter line may

Step 5 â€” Return result

return max_area


After pointers meet, max_area holds the maximum container area

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass with two pointers
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: Max area formed by lines at index 1 and 8 â†’ min(8,7) * (8-1) = 49


Example 2

Input: height = [1,1]
Output: 1
Explanation: Only two lines â†’ area = 1

