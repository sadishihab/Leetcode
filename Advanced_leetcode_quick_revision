ğŸ‘‰ Problem: Maximum Subarray (Kadaneâ€™s Algorithm) (leetcode 53)

You must find the contiguous subarray that gives the maximum total sum.

âœ… Key Idea

"If your running sum becomes negative, throw it away and start fresh."

âœ¨ Flashcard

Kadane = keep adding; if sum < 0 â†’ reset; track max.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with two trackers

maxSum â† first element of the array
(This ensures answer always includes at least one number)

curSum â† 0
(Your temporary running sum)

Step 2 â€” Begin scanning the array from left to right

For each number in the array:

Step 3 â€” If the running sum became negative

Drop it.

Restart the subarray from the next number.

Why?
A negative running sum will only pull future sums down.

So mentally say:
â€œcurSum < 0? Reset to 0.â€

Step 4 â€” Add the current number to your running total

Extend the current subarray by including this number.

curSum grows as long as you are gaining value.

Step 5 â€” Update the global best

After adding each number:

Compare curSum with maxSum

If curSum is higher â†’ update maxSum

This ensures you always keep track of the best subarray seen so far.

Step 6 â€” Finish

After scanning all numbers:

The value in maxSum is the maximum subarray sum.

ğŸ§  Mental Map (Very Simple)

Imagine walking through numbers with a backpack:

Add each number to your backpack.

If the items in the backpack make the total weight negative,
empty the backpack and start collecting freshly.

Always remember the heaviest backpack value seen.

â±ï¸ Complexity

Time: O(n) â†’ one pass

Space: O(1) â†’ only two variables

You can also write:
ğŸ“Œ For the sliding window version
ğŸ“Œ For the divide & conquer solution
ğŸ“Œ For returning indices or subarray

ğŸ‘‰ Problem: Maximum Sum Circular Subarray (LeetCode 918)

You must find the maximum subarray sum, but the array is circular â€” meaning the end wraps around to the start.

âœ… Key Idea

There are two possible types of max subarrays:

1ï¸âƒ£ Normal (Non-Circular) Subarray

Example:
[1, -2, 3, -2] â†’ best is [3] â†’ sum = 3
Just run Kadaneâ€™s algorithm.

2ï¸âƒ£ Circular Subarray

The subarray â€œwraps aroundâ€ the end â†’ start.

Example:
[5, -3, 5] best circular = [5, ?, 5] = 10 â†’ sum = 10

How to find this?

ğŸ‘‰ Circular max sum = total sum âˆ’ minimum subarray sum

Because:

Removing the minimum middle part gives the maximum wrapping part.

âœ¨ Flashcard

"Max = max(normalKadane, total âˆ’ minKadane). But if all numbers are negative â†’ return max normal only."

âœ… How It Works

Use Kadaneâ€™s algorithm to find the maximum subarray sum in the normal (non-circular) array.

Use a modified Kadaneâ€™s algorithm to find the minimum subarray sum.

Compute total_sum of the array.

Maximum circular subarray sum can be calculated as total_sum - min_subarray.

Handle edge case: if all numbers are negative, the normal max subarray sum is the answer.

Return the larger of max_normal and max_circular.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the normal maximum subarray sum

Use standard Kadane:

Keep adding numbers.

When sum < 0 â†’ reset to 0.

Track the largest sum seen.

This gives:

max_normal


This solves the non-wrapping case.

Step 2 â€” Compute the minimum subarray sum

Do Kadane again, but inverted:

Keep adding numbers.

When sum > 0 â†’ reset to 0.

Track the smallest (most negative) sum seen.

This gives:

min_subarray


This helps us compute the maximum circular sum.

Step 3 â€” Compute total sum of all elements
total_sum = sum(nums)


This is needed for wrapping logic.

Step 4 â€” Compute circular subarray sum
max_circular = total_sum âˆ’ min_subarray


This essentially removes the worst (minimum) middle part to form a wrapping subarray.

Step 5 â€” Edge Case: All numbers are negative

If all numbers are negative:

The minimum subarray = total sum

So: total_sum â€“ min_subarray = 0 (invalid empty subarray)

So in this case:
âœ” Return only max_normal

Because circular sum is not allowed to be empty.

Step 6 â€” Final Answer
answer = max(max_normal, max_circular)

ğŸ§  Mental Map (Super Simple)

Think of the array having two choices:

1ï¸âƒ£ Best is inside the array normally.

Just Kadane.

2ï¸âƒ£ Best is across the ends.

Take the whole array â†’ remove the worst part â†’ that creates a wrap.

Compare both â†’ pick larger.
â±ï¸ Complexity

Time: O(n)

Space: O(1)

ğŸ” Short Examples
Example 1: [1, -2, 3, -2]

max_normal = 3

min_subarray = -2

total = 0

max_circular = 0 âˆ’ (-2) = 2 â†’ but 3 is bigger

Answer = 3

Example 2: [5, -3, 5]

max_normal = 7

min_subarray = -3

total = 7

max_circular = 7 âˆ’ (-3) = 10

Answer = 10

Example 3: [-3, -2, -3]

All negative â†’ must return largest (least negative)

Answer = -2

ğŸ‘‰ Problem: Longest Turbulent Subarray (LeetCode 978)

You are given an integer array arr.
A turbulent subarray is one where the comparison signs alternate between adjacent elements:

Either: > < > < â€¦

Or: < > < > â€¦

Return the length of the longest turbulent subarray.

âœ… Key Idea

Use a sliding window / two counters approach:

Track two lengths while scanning:

up â†’ current subarray ends with <

down â†’ current subarray ends with >

Whenever the sign flips, extend the subarray.

Reset when adjacent numbers are equal.

âœ¨ Flashcard:
"Compare neighbors. If sign flips â†’ extend subarray. Equal â†’ reset."

âœ… How It Works

If the array has only one element, return 1.

Use two counters, up and down, to track lengths of turbulent subarrays ending at the current element:

up â†’ last comparison was >

down â†’ last comparison was <

Iterate through the array starting from index 1:

If arr[i] > arr[i - 1], set up = down + 1 and reset down = 1.

If arr[i] < arr[i - 1], set down = up + 1 and reset up = 1.

If equal, reset both up and down to 1.

At each step, update max_len with the largest of max_len, up, and down.

Continue until the end of the array.

Return max_len â†’ length of the longest turbulent subarray.

âš¡ Full Approach (Step-by-Step)
Step 1 â€” Handle edge case

If the array has only one element â†’ return 1.

Step 2 â€” Initialize

max_len = 1 (at least one element counts)

up = 1, down = 1 (lengths of turbulent subarrays ending in < or >)

Step 3 â€” Loop through array

For each index i from 1 to n-1:

Compare arr[i] with arr[i-1]

If arr[i] > arr[i-1]:

up = down + 1 (flip happened)

down = 1 (reset opposite direction)

Else if arr[i] < arr[i-1]:

down = up + 1

up = 1

Else:

Equal â†’ reset both: up = down = 1

Update max_len = max(max_len, up, down)

Step 4 â€” Return

max_len after scanning the array.

â±ï¸ Complexity

Time: O(n) â†’ single pass

Space: O(1) â†’ only 3 variables

ğŸ“ Example Dry Run
Example 1: [9,4,2,10,7,8,8,1,9]

Compare 9>4 â†’ down=2, up=1 â†’ max_len=2

Compare 4>2 â†’ down=2, up=1 â†’ max_len=2

Compare 2<10 â†’ up=down+1=3, down=1 â†’ max_len=3

Compare 10>7 â†’ down=up+1=4, up=1 â†’ max_len=4

Compare 7<8 â†’ up=down+1=5, down=1 â†’ max_len=5

Compare 8=8 â†’ reset â†’ up=down=1

Compare 8>1 â†’ down=up+1=2, up=1

Compare 1<9 â†’ up=down+1=3, down=1

Final max_len = 5



ğŸ‘‰ Problem: Contains Duplicate II (Leet code 219)

You must determine whether any number appears twice within a distance of k from each other.

âœ… Key Idea

â€œKeep a sliding window of size at most k.
If a number reappears inside that window â†’ duplicate found.â€

You donâ€™t need to search the entire array â€” only look k steps back.

âœ¨ Flashcard

Nearby duplicate =
â€œUse a sliding window set.
If window grows > k â†’ remove leftmost.
If current number already in set â†’ True.â€

âœ… How It Works

Use a sliding window of size at most k with pointers L (left) and R (right).

Maintain a set window to store elements currently in the window.

For each R, check if the window size exceeds k:

If yes, remove nums[L] from the window and increment L.

If nums[R] is already in the window â†’ a nearby duplicate is found, return True.

Otherwise, add nums[R] to the window.

Continue until the end of the array.

If no nearby duplicates are found, return False.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a sliding window

Use a set to store the last few elements youâ€™ve seen.

Call it:
window â† empty set

Also keep a pointer:
left â† 0
(This marks the start of the sliding window)

Step 2 â€” Walk through the array using right pointer

For each index right, you check the current number nums[right].

Step 3 â€” Ensure the window never becomes larger than k

If the distance (right - left) becomes bigger than k,
you must remove nums[left] from the window â†’ slide forward.

Why?
Because any element more than k steps away is no longer allowed.

So think:
â€œWindow too big? Kick out the leftmost.â€

Then increase left.

Step 4 â€” Check for a duplicate inside the window

Before inserting the current number:

If nums[right] is already inside the window â†’
you found a value that appears again within â‰¤ k distance.

Return True immediately.

This is the core condition.

Step 5 â€” Add the current number to the window

After ensuring the window is valid and checking for duplicates,
insert the current number.

Step 6 â€” If loop finishes with no match

Return False.

This means no number repeated within k distance.

ğŸ§  Mental Map (Very Simple)

Imagine a sliding glass window that can only show k elements at a time.

You move the window from left to right.

If a number is seen again inside the window â†’ duplicate found.

If the window gets too wide â†’ push out the leftmost number.

â±ï¸ Complexity

Time: O(n)
(You visit each number once)

Space: O(k)
(Window holds at most k items)



ğŸ‘‰ Problem: Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Leetcode 1343)

Count Subarrays With Average â‰¥ Threshold

You are given:

arr â†’ an array of numbers

k â†’ size of subarray

threshold â†’ required minimum average

You must count:

How many subarrays of size k
have average â‰¥ threshold?

âœ¨ Key Idea

Instead of checking averages, we compare sum:

A subarray's average â‰¥ threshold
â‡” its sum â‰¥ threshold * k

Why?

average = sum / k
sum / k â‰¥ threshold  â†’  sum â‰¥ threshold * k


So we only need the sum, not the average.

âœ¨ Flashcard (Short Memory Trick)

Count subarrays avg â‰¥ threshold =
â€œUse sliding window sum.
Target = threshold Ã— k.
Build first window.
Slide: add right, remove left.
If sum â‰¥ target â†’ count.â€

âœ… How It Works

Compute target_sum = threshold * k â†’ the minimum sum a subarray of size k needs.

Initialize window_sum with the sum of the first k elements.

Initialize count to 1 if the first window meets the threshold, otherwise 0.

Slide the window across the array:

Add the new element entering the window and remove the element leaving the window.

If window_sum >= target_sum, increment count.

Continue until the end of the array.

Return count â†’ number of subarrays of size k with average â‰¥ threshold.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the target sum

You need each windowâ€™s sum to be at least:

threshold * k


This avoids doing division and makes comparisons faster.

Step 2 â€” Start by summing the first window of size k

Take the first k elements and compute their sum.

If this sum â‰¥ target sum â†’ count it.

Step 3 â€” Slide the window across the array (1 step at a time)

When sliding from one window to the next:

Add the new element on the right

Remove the element that is leaving from the left

This keeps the window always of size k.

This takes O(1) per step.

Step 4 â€” After each slide, compare the window sum

If window_sum â‰¥ target_sum â†’ increase answer.

Step 5 â€” Continue until the end of the array

Return how many windows qualified.

ğŸ§  Mental Picture

Imagine a window that covers exactly k numbers.

You slide this window across the array from left to right.

At each position:

Check if the total inside the window is â€œheavy enoughâ€

If yes â†’ count it

This is classical sliding window.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one pass through the array.



ğŸ‘‰ Problem: Minimum Size Subarray Sum (Leetcode 209)
Find the shortest subarray whose sum â‰¥ target.
You are given:


nums â†’ array of positive integers


target â†’ required minimum sum


You must return:


The minimal length of a subarray whose sum â‰¥ target


Return 0 if no such subarray exists



âœ¨ Key Idea
This is a classic sliding window problem.
Because all numbers are positive,
â†’ expanding the right pointer always increases the sum
â†’ shrinking the left pointer always decreases the sum
So two-pointer sliding window works perfectly.

âœ¨ Flashcard

Minimum Size Subarray Sum =
â€œUse sliding window (positive nums).
Grow R until sum â‰¥ target.
Shrink L to minimize window.
Track shortest valid size.
If never valid â†’ return 0.â€

âœ… How It Works

Use a sliding window with L as the left pointer and R as the right pointer.

Maintain total as the sum of elements in the current window.

For each R, add nums[R] to total to expand the window.

While total >= target, the current window is valid:

Update min_length with the size of the window (R - L + 1).

Shrink the window from the left by subtracting nums[L] and incrementing L.

Continue until the end of the array.

If no valid window is found, return 0; otherwise, return min_length.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers


L â†’ start of the window


R â†’ end of the window


total â†’ sum inside the window


min_length â†’ initialized to âˆ



Step 2 â€” Expand the window by moving R
For each new element:
total += nums[R]

Keep adding numbers until total â‰¥ target.

Step 3 â€” When the window meets the requirement
Whenever:
total â‰¥ target

We found a valid subarray.
Now we try to shrink it from the left to make it as small as possible.
Update the answer:
min_length = min(min_length, R - L + 1)


Step 4 â€” Shrink from the left
Remove nums[L] from the window:
total -= nums[L]
L += 1

Continue shrinking while the sum still â‰¥ target.
This finds the shortest valid window for this R.

Step 5 â€” Continue until R reaches the end
If no valid window was ever found â†’ return 0.

ğŸ§  Mental Picture
Imagine a window sliding across the array.


It grows until it is heavy enough (sum â‰¥ target)


Then it shrinks to find the smallest valid size


Then it grows again


This ensures we find the minimum valid window.

â±ï¸ Complexity
OperationCostTimeO(n)SpaceO(1)
Each pointer moves at most n steps â†’ linear time.

âœ”ï¸ Examples Explained
Example 1
target = 7
nums = [2,3,1,2,4,3]
Valid windows with sum â‰¥ 7 include:


[2,3,1,2] â†’ length 4


[3,1,2,4] â†’ length 4


[4,3] â†’ length 2 (smallest)


Answer: 2

Example 2
target = 4
nums = [1,4,4]
The subarrays:


[4] â†’ length 1


[4] â†’ length 1


Answer: 1

Example 3
target = 11
nums = [1,1,1,1,1,1,1,1]
All sums are â‰¤ 8 â†’ no subarray can reach 11.
Answer: 0


ğŸ‘‰ Problem: Longest Substring Without Repeating Characters (leetcode 03)

Find the length of the longest substring (continuous sequence)
with no repeating characters.

You are given:

s â†’ a string

Return:

The maximum length of any substring where all characters are unique

âœ¨ Key Idea

Use a sliding window with:

L â†’ left pointer

R â†’ right pointer

a set to store characters currently inside the window

We expand the window with R, and if a duplicate appears,
we shrink from the left until the window becomes valid again.

âœ¨ Flashcard

Longest substring without repeating chars =
â€œUse sliding window set.
If char not in set â†’ add & update max.
If duplicate â†’ shrink L removing chars until gone.
Window always stays unique.â€

ChatGPT said:

âœ… How It Works

Use a sliding window with L as the left pointer and R as the right pointer.

Maintain a set window to store characters in the current window.

For each R, check if s[R] is already in the window:

If yes, remove characters from the left (L) until the duplicate is gone.

Add s[R] to the window.

Update max_length with the size of the current window (R - L + 1).

Continue until the end of the string.

Return max_length â†’ the length of the longest substring without repeating characters.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L starts at 0

R loops over every character

A set window stores the characters currently inside the window

Step 2 â€” Expand the window by adding s[R]

If s[R] is not in the set:

Add it

Update max length

If s[R] is in the set â†’ we have a duplicate.

Step 3 â€” Shrink from the left when duplicate found

While s[R] is already in the window:

Remove s[L] from the set

Move L to the right

Repeat until duplicate disappears

Now the window is valid again.

Step 4 â€” Track the maximum window size

At each step:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue until R reaches the end

Return the maximum.

ğŸ§  Mental Picture

Imagine a window sliding across the string:

Expand as long as all characters are unique

When you hit a duplicate â†’ shrink from the left

Keep only the valid "unique character substring" inside the window

Track the largest window ever formed

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(min(n, charset))

Since each pointer moves at most n times.


âœ”ï¸ Example Outputs
Example 1

s = "abcabcbb"
Longest: "abc" â†’ length 3

Example 2

s = "bbbbb"
Longest: "b" â†’ length 1

Example 3

s = "pwwkew"
Longest: "wke" â†’ length 3

If you want, you can also do it by:

ğŸ“Œ A version using a dictionary instead of a set (faster)

ğŸ‘‰ Problem: Longest Repeating Character Replacement (leetcode 424)

You are given:

s â†’ a string of uppercase letters

k â†’ maximum number of character replacements allowed

You may:

Change any character to any other uppercase letter

Perform this operation at most k times

Return:

The length of the longest substring that can be made of the same character, after using at most k replacements.

âœ¨ Key Idea

We want a substring where:

Most characters are the same

And we can fix the rest (up to k characters) by replacing them

Inside any window:

replacements needed = window_size - count_of_most_frequent_char_in_window


For the window to be valid:

window_size - max_freq â‰¤ k


This tells us whether the window can be turned into all identical letters.

âœ¨ Flashcard

Longest Repeating Character Replacement =
â€œUse sliding window freq map.
Track max_freq inside window.
Window valid if size âˆ’ max_freq â‰¤ k.
If invalid â†’ shrink L.
Track largest valid window.â€

ğŸ§  Mental Picture

Imagine a window sliding across the string.

At each step:

Count how many characters already match

Calculate how many characters need replacing

If replacements needed â‰¤ k â†’ good window

If too many replacements â†’ shrink from left

Keep the largest valid window

âœ… How It Works

Use a sliding window with pointers L (left) and R (right).

Maintain a frequency map count of characters inside the window.

Track max_freq, the count of the most frequent character in the current window.

For each R, add s[R] to the frequency map and update max_freq.

If the window size minus max_freq exceeds k, shrink the window from the left (L) and update counts.

At each step, update max_length with the size of the valid window (R - L + 1).

Continue until the end of the string.

Return max_length â†’ the length of the longest substring after at most k replacements.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Sliding window with L and R

Expand the window by moving R

Keep frequency counts of letters in the window

Track max_freq = the highest frequency of any character in the current window

Step 2 â€” Check if the window is valid

A window is valid if:

(R - L + 1) - max_freq â‰¤ k


Meaning:

Total characters

Minus the number of already-matching characters

Must be â‰¤ k replacements allowed

If valid â†’ we can expand further.

Step 3 â€” If window becomes invalid

Shrink from the left:

reduce count of s[L]
L += 1


We donâ€™t need to reduce max_freq strictly, because:

Letting it stay slightly outdated does not break correctness

The window size only grows to valid sizes

This is a well-known trick that keeps the code O(n).

Step 4 â€” Track maximum window size

Whenever the window is valid:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue to end of string

Return the largest valid window found.



â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

26 uppercase letters â†’ constant extra space.

âœ”ï¸ Example Results
Example 1

s = "ABAB", k = 2
We can make all letters 'A' or 'B'.

Max length = 4

Example 2

s = "AABABBA", k = 1
Best substring â†’ "BBBB" after one change.

Max length = 4


ğŸ‘‰ Problem: Valid Palindrome (LeetCode 125)

You are given:

s â†’ a string consisting of printable ASCII characters (letters, digits, punctuation, spaces)

You may:

Convert uppercase letters to lowercase

Remove all non-alphanumeric characters

Return:

true if the resulting string reads the same forward and backward, otherwise false.

âœ¨ Key Idea

We want to check if a string is a palindrome ignoring cases and non-alphanumeric characters.

Use two pointers:

L starts at the beginning

R starts at the end

At each step:

Skip non-alphanumeric characters

Compare characters in lowercase

If mismatch â†’ return false

If pointers meet â†’ return true

âœ¨ Flashcard

Valid Palindrome =
â€œUse two pointers. Skip non-alphanumeric. Compare lowercase. If all match â†’ palindrome.â€

ğŸ§  Mental Picture

Imagine a window sliding inwards from both ends:

Ignore spaces, punctuation, etc.

Compare letters and digits

Shrink inward until pointers meet

If all comparisons pass â†’ palindrome

âœ… How It Works

Initialize two pointers, L at the start and R at the end of the string.

Move L forward and R backward, skipping non-alphanumeric characters.

At each step, compare the lowercase versions of s[L] and s[R].

If a mismatch is found, return False â†’ not a palindrome.

Otherwise, move both pointers inward and continue.

If pointers meet without mismatches, return True â†’ the string is a palindrome.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers
L = 0, R = len(s) - 1

Step 2 â€” Skip invalid characters
While L < R:

Move L forward if s[L] is not alphanumeric

Move R backward if s[R] is not alphanumeric

Step 3 â€” Compare characters

Convert s[L] and s[R] to lowercase

If they are different â†’ return false

Else â†’ move L += 1 and R -= 1

Step 4 â€” Repeat until pointers meet

If loop finishes without mismatch â†’ return true

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan string once
Space	O(1) â†’ constant extra space for pointers

âœ”ï¸ Example Results

Example 1

Input: "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome


Example 2

Input: "race a car"
Output: false
Explanation: "raceacar" is not a palindrome

Example 3

Input: " "
Output: true
Explanation: empty string is trivially a palindrome



ğŸ‘‰ Problem: Two Sum II - Input Array Is Sorted (LeetCode 167)

You are given:

numbers â†’ a 1-indexed array of integers, sorted in non-decreasing order

target â†’ a number

You may:

Pick two distinct numbers from the array

Add them to equal target

Return:

[index1, index2] â†’ the 1-based indices of the two numbers that sum to target

Constraints:

Exactly one solution exists

Cannot use the same element twice

Must use constant extra space

âœ¨ Key Idea

Since the array is sorted, we can use two pointers:

L â†’ starts at the beginning

R â†’ starts at the end

At each step:

Calculate current_sum = numbers[L] + numbers[R]

If current_sum == target â†’ solution found â†’ return [L+1, R+1]

If current_sum < target â†’ move L right to increase sum

If current_sum > target â†’ move R left to decrease sum

This works because the array is sorted â†’ moving pointers adjusts the sum in a predictable way.

âœ¨ Flashcard

Two Sum II =
â€œUse two pointers on sorted array. Compare sum to target. Move L or R accordingly. Return 1-based indices.â€

ğŸ§  Mental Picture

Imagine two fingers: one at the start, one at the end of the array

Compare their sum to the target

Move fingers closer together until sum matches the target

One pass â†’ finds the solution efficiently

âœ… How It Works

L and R are pointers starting at the beginning and end of the array.

Calculate current_sum = numbers[L] + numbers[R].

If current_sum > target, move R left to reduce the sum.

If current_sum < target, move L right to increase the sum.

If current_sum == target, return [L + 1, R + 1] (1-indexed).

Continue until the correct pair is found.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0
R = len(numbers) - 1


Step 2 â€” Move pointers while L < R

Calculate current_sum = numbers[L] + numbers[R]

Compare with target:

current_sum == target â†’ return [L+1, R+1]

current_sum < target â†’ move L += 1 to increase sum

current_sum > target â†’ move R -= 1 to decrease sum

Step 3 â€” Continue until solution found

Guaranteed because exactly one solution exists

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan array once
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: 2 + 7 = 9


Example 2

Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: 2 + 4 = 6


Example 3

Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: -1 + 0 = -1


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array (LeetCode 26 two pointers)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicate elements in-place

Keep the relative order of the unique elements

Return:

k â†’ the number of unique elements in the array

The first k elements of nums should be the unique numbers

Elements beyond index k-1 can be ignored

Constraints:

1 <= nums.length <= 3 * 10^4

-100 <= nums[i] <= 100

Array is sorted in non-decreasing order

âœ¨ Key Idea

Because the array is sorted, duplicates appear consecutively:

Use two pointers:

L â†’ slow pointer, tracks last unique element

R â†’ fast pointer, scans through the array

At each step:

Compare nums[R] with nums[L]

If different â†’ found a new unique number

Move L forward

Assign nums[L] = nums[R]

If same â†’ skip, R moves forward

At the end, L + 1 is the count of unique numbers

âœ¨ Flashcard

Remove Duplicates =
â€œUse two pointers on sorted array. L tracks last unique. R scans. When nums[R] != nums[L], move L and update. Return L + 1.â€

ğŸ§  Mental Picture

Imagine a slow finger L marking the last unique element

A fast finger R scans the array

Whenever a new number appears, copy it after L

Result: unique numbers shifted to the front, duplicates ignored

âœ… How It Works

If the array is empty, return 0.

Use L as a slow pointer to track the position of the last unique element.

Iterate with R as a fast pointer through the array starting from index 1.

At each step, check if nums[R] is different from nums[L].

If different, increment L and write nums[R] at position L.

Continue until the end of the array.

Return L + 1 as the number of unique elements.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0  # Last unique element index


Step 2 â€” Iterate with fast pointer

for R in range(1, len(nums)):


Step 3 â€” Check for new unique element

If nums[R] != nums[L] â†’ new number found

Move L += 1

Assign nums[L] = nums[R]

Step 4 â€” Continue until end of array

All unique elements are now from index 0 to L

Return L + 1 â†’ number of unique elements

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: unique elements are 1 and 2


Example 2

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: unique elements are 0,1,2,3,4


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array II (LeetCode 80)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicates in-place such that each unique element appears at most twice

Keep the relative order of elements

Return:

k â†’ number of elements after removing extra duplicates

The first k elements of nums should contain the final result

Elements beyond index k-1 can be ignored

Constraints:

Do not allocate extra space â†’ O(1) space

1 <= nums.length <= 3 * 10^4

-10^4 <= nums[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ slow pointer, tracks the position to write the next allowed element

R â†’ fast pointer, scans the array

Keep at most 2 duplicates:

Compare nums[R] with nums[L-2] (the element 2 steps behind the slow pointer)

If nums[R] != nums[L-2] â†’ it is allowed â†’ copy nums[R] to nums[L] and move L forward

If nums[R] == nums[L-2] â†’ more than 2 duplicates â†’ skip

This works because the array is sorted â†’ duplicates are consecutive

âœ¨ Flashcard

Remove Duplicates II =
â€œUse two pointers. Slow pointer writes allowed elements. Keep at most two duplicates. If nums[R] != nums[L-2] â†’ write nums[R]. Return L.â€

ğŸ§  Mental Picture

Slow pointer L â†’ marks next position to write allowed element

Fast pointer R â†’ scans through array

Only copy the element if it does not exceed two occurrences

At the end â†’ first L elements are the allowed numbers

âœ… How It Works

If the array has 2 or fewer elements, all are allowed.

Use L as a slow pointer to track the position to write allowed elements.

Iterate with R as a fast pointer through the array starting from index 2.

At each step, check if nums[R] is different from nums[L - 2] to allow at most two duplicates.

If allowed, write nums[R] at position L and increment L.

Continue until the end of the array.

Return L as the number of allowed elements.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Handle edge case

if len(nums) <= 2:
    return len(nums)


If array has 0, 1, or 2 elements â†’ all are allowed

Step 2 â€” Initialize slow pointer

L = 2  # first two elements are always allowed


L points to next position to write

Start from index 2 because first two elements are always allowed

Step 3 â€” Iterate with fast pointer

for R in range(2, len(nums)):


R scans from the third element to the end

Step 4 â€” Check if current element is allowed

if nums[R] != nums[L - 2]:
    nums[L] = nums[R]
    L += 1


Compare with the element two steps behind slow pointer (nums[L-2])

If different â†’ allowed â†’ copy to nums[L] and move L forward

If same â†’ skip â†’ prevents more than 2 duplicates

Step 5 â€” Return number of allowed elements

return L


L is now the count of elements with at most two duplicates

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: keep at most two duplicates


Example 2

Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: keep at most two duplicates


ğŸ‘‰ Problem: Container With Most Water (LeetCode 11)

You are given:

height â†’ a list of vertical line heights

Each line is at coordinate (i, height[i])

You may:

Pick two lines to form a container with the x-axis

Return:

The maximum area of water the container can store

Constraints:

Cannot slant the container â†’ height is limited by the shorter line

2 <= height.length <= 10^5

0 <= height[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ start of array

R â†’ end of array

Area formula:

area
=
min
â¡
(
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ¿
]
,
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ‘…
]
)
Ã—
(
ğ‘…
âˆ’
ğ¿
)
area=min(height[L],height[R])Ã—(Râˆ’L)

Move the pointer pointing to the shorter line, because moving the taller line will never increase the area.

Keep track of maximum area seen so far.

âœ¨ Flashcard

Container With Most Water =
â€œTwo pointers at both ends. Area = min(height[L], height[R]) * width. Move shorter line pointer. Track max area.â€

ğŸ§  Mental Picture

Imagine a container formed by two vertical lines

Width = distance between lines

Height = shorter line

Slide the shorter line inward â†’ possible bigger height, maybe bigger area

Stop when pointers meet

âœ… How It Works

L and R scan from both ends toward the center.

At each step, the shorter line determines the container height.

Calculate area = min(height[L], height[R]) Ã— (R âˆ’ L).

Update max_area if current area is larger.

Move the pointer pointing to the shorter line inward.

Continue until L meets R.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers and max area

L = 0
R = len(height) - 1
max_area = 0


L â†’ left pointer

R â†’ right pointer

max_area â†’ stores largest container area so far

Step 2 â€” Loop until pointers meet

while L < R:


Continue scanning all possible containers formed by L and R

Step 3 â€” Calculate area

current_area = min(height[L], height[R]) * (R - L)
max_area = max(max_area, current_area)


Width = R - L

Height = min(height[L], height[R])

Update max_area if current_area is larger

Step 4 â€” Move pointer pointing to shorter line

if height[L] < height[R]:
    L += 1
else:
    R -= 1


Move the smaller line pointer inward

Why? Because moving the taller line cannot increase area, but moving the shorter line may

Step 5 â€” Return result

return max_area


After pointers meet, max_area holds the maximum container area

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass with two pointers
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: Max area formed by lines at index 1 and 8 â†’ min(8,7) * (8-1) = 49


Example 2

Input: height = [1,1]
Output: 1
Explanation: Only two lines â†’ area = 1


ğŸ‘‰ Problem: Trapping Rain Water (LeetCode 42)

You are given:

height â†’ an array of non-negative integers representing an elevation map

Width of each bar = 1

You may:

Compute how much water is trapped after raining between the bars

Return:

Total units of trapped water

Constraints:

1 <= height.length <= 2 * 10^4

0 <= height[i] <= 10^5

âœ¨ Key Idea

Water trapped at a given index depends on tallest bars to the left and right:

water at i
=
max
â¡
(
0
,
min
â¡
(
tallest left
,
tallest right
)
âˆ’
height
[
ğ‘–
]
)
water at i=max(0,min(tallest left,tallest right)âˆ’height[i])

Use two pointers approach for O(1) space:

L â†’ start pointer

R â†’ end pointer

Track left_max â†’ tallest bar from left

Track right_max â†’ tallest bar from right

Move the pointer pointing to the smaller bar

Compute water trapped at each step and accumulate

âœ¨ Flashcard

Trapping Rain Water =
â€œTwo pointers at both ends. Track tallest bars from left and right. Move the shorter bar inward. Water trapped = min(left_max, right_max) - height[i]. Add to total.â€

ğŸ§  Mental Picture

Imagine the bars forming valleys and peaks

Water can only be trapped up to the smaller of the tallest bars on the left and right

Move pointers inward step by step

At each step, calculate trapped water above the current bar

Continue until pointers meet

âš¡ Step-by-Step Approach (No Code)

Step 1 â€” Initialize pointers and variables

Place L at the start of the array and R at the end

Initialize left_max and right_max to 0

Initialize water to 0

Step 2 â€” Loop until pointers meet

Keep processing the bars between L and R

Step 3 â€” Decide which pointer to move

Compare height[L] and height[R]

Move the pointer pointing to the smaller bar

If left bar is smaller â†’ trapped water depends on left_max

If right bar is smaller â†’ trapped water depends on right_max

Step 4 â€” Update max and add trapped water

If current bar â‰¥ max on its side â†’ update the max

Else â†’ water trapped at this bar = max - height at the bar

Move pointer inward

Step 5 â€” Continue until pointers meet

Repeat Step 3 and Step 4 until the two pointers meet

Accumulate trapped water at each step

Step 6 â€” Return result

The total accumulated water is the answer

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass with two pointers
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: Water trapped = 6 units


Example 2

Input: [4,2,0,3,2,5]
Output: 9
Explanation: Water trapped = 9 units

âœ… How It Works

L and R scan from both ends toward the center.

At each step, the smaller bar determines trapped water.

left_max and right_max track the tallest bars seen so far.

Water trapped at a bar = max(0, min(left_max, right_max) âˆ’ height[i]).

Continue until L meets R.

ğŸ‘‰ Problem: Range Sum Query â€“ Immutable (Prefix Sum) (LeetCode 303)

You must answer multiple queries asking for the sum of elements between indices left and right (inclusive).

âœ… Key Idea

"Precompute cumulative sums once, then answer every range query using subtraction."

Instead of adding numbers again and again for every query, store partial sums and reuse them.

ğŸ§  Mental Map (Very Simple)

Imagine your array as checkpoints on a road:

Each checkpoint stores how far youâ€™ve traveled so far.

To know the distance between two checkpoints:

Look at the farther one

Subtract the distance just before the starting point

That difference is your answer.

âœ¨ Flashcard

Prefix Sum = sum till right âˆ’ sum before left

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a prefix sum structure

Prepare an array that will store cumulative sums.

Each position i will hold the sum of elements from index 0 to i.

Step 2 â€” Build cumulative totals

Start with a running total set to 0.

Scan the array from left to right:

Add the current number to the running total

Store this total in the prefix array

After this step:

prefix[i] = sum of elements from 0 to i

Step 3 â€” Understand what a range sum means

To find the sum from index left to right:

Take the sum up to right

Remove the sum of elements before left

Mathematically:

If left > 0 â†’ subtract prefix[left âˆ’ 1]

If left == 0 â†’ subtract 0

Step 4 â€” Answer each query in constant time

For every query (left, right):

Get the cumulative sum at right

Subtract the cumulative sum just before left

The result is the required range sum

No loops. No recalculation.

Step 5 â€” Finish

Since the array is immutable, the prefix array never changes.

You can answer thousands of queries efficiently using the same precomputed data.



â±ï¸ Complexity

Preprocessing: O(n) (build prefix sums once)

Each Query: O(1)

Space: O(n) (prefix array)

ğŸ“Œ This is the best possible solution for an immutable array
ğŸ“Œ This is exactly what interviewers expect for LeetCode 303
ğŸ“Œ Mutable version? â†’ Fenwick Tree / Segment Tree

ğŸ‘‰ Problem: Range Sum Query 2D â€“ Immutable (2D Prefix Sum) (LeetCode 304)

You must answer multiple queries asking for the sum of elements inside a rectangular sub-matrix, defined by its top-left corner (row1, col1) and bottom-right corner (row2, col2).

âœ… Key Idea

"Precompute cumulative sums for the whole matrix once, then answer every rectangle query using subtraction."

Instead of summing all cells inside the rectangle for every query, store partial rectangle sums and reuse them.

ğŸ§  Mental Map (Very Simple)

Imagine the matrix as a large field divided into blocks.

At each cell, you store:
â€œHow much area (sum) is covered from the top-left corner up to here?â€

To find the area of any rectangle:
Take the big area till the bottom-right
Remove the area above
Remove the area to the left
Add back the overlapping corner (removed twice)

### Think of it like peeling layers. Take a big rectangle. Cut off the top. Cut off the left. Fix the double cut

âœ¨ Flashcard

2D Prefix Sum = big rectangle âˆ’ top âˆ’ left + overlap

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a 2D prefix sum structure

Prepare a 2D array prefix.

Each position (i, j) will store the sum of all elements from (0,0) to (i,j).

Step 2 â€” Build cumulative totals row by row

For each row:

Start a running sum row_sum = 0

Move left to right across the row:

Add the current cell value to row_sum

Add the value from the cell directly above (if it exists)

Store the result in the prefix matrix

After this step:

prefix[i][j] = sum of all elements inside rectangle (0,0) â†’ (i,j)

Step 3 â€” Understand what a rectangle sum means

To find the sum of a rectangle (row1, col1) â†’ (row2, col2):

Start with the sum from (0,0) â†’ (row2, col2)

Remove the area above row1

Remove the area left of col1

Add back the top-left overlap (it was removed twice)

Step 4 â€” Answer each query in constant time

For every query (row1, col1, row2, col2):

Get the cumulative sum at (row2, col2)

Subtract the cumulative sum above the rectangle

Subtract the cumulative sum to the left of the rectangle

Add back the overlapping top-left area

No loops. No recalculation.

Step 5 â€” Finish

Since the matrix is immutable, the prefix matrix never changes.

You can answer thousands of rectangle sum queries efficiently using the same precomputed data.

â±ï¸ Complexity

Preprocessing: O(m Ã— n) (build prefix matrix once)

Each Query: O(1)

Space: O(m Ã— n) (prefix matrix)

ğŸ“Œ This is the best possible solution for an immutable 2D matrix
ğŸ“Œ This is exactly what interviewers expect for LeetCode 304
ğŸ“Œ Mutable version? â†’ 2D Fenwick Tree / Segment Tree

ğŸ‘‰ Problem: Find Pivot Index (1D Prefix Sum) (LeetCode 724)

You are given an array of integers.
You must find the leftmost index where:

sum of elements strictly to the left
=
sum of elements strictly to the right

If no such index exists, return -1.

âœ… Key Idea

"Keep a running prefix sum from the left, and derive the right sum using the total."

Instead of recalculating sums for every index, compute the total once and reuse it.

ğŸ§  Mental Map (Very Simple)

Imagine the array split into three parts at index i:

[ left_sum | nums[i] | right_sum ]


left_sum â†’ sum of everything before i

nums[i] â†’ current element

right_sum â†’ everything after i

If the left and right sides balance, youâ€™ve found the pivot.

âœ¨ Flashcard

1D Prefix Sum Pivot Rule

right_sum = total âˆ’ left_sum âˆ’ current_value


Pivot condition:

left_sum == right_sum

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Calculate total sum

Add up all elements of the array once.
This represents the entire weight of the array.

Step 2 â€” Start with an empty left side

Initialize a variable:

left_sum = 0

At the beginning, nothing exists to the left.

Step 3 â€” Scan the array from left to right

At each index:

Treat the current element as the â€œcenterâ€

Everything before it is left_sum

Everything after it is:

right_sum = total âˆ’ left_sum âˆ’ current_element

Step 4 â€” Check the pivot condition

If:

left_sum == right_sum


Return the current index immediately
(this guarantees the leftmost pivot).

Step 5 â€” Slide the divider

If itâ€™s not a pivot:

Add the current element to left_sum

Move to the next index

The divider shifts one step to the right.

Step 6 â€” No pivot found

If the loop ends with no match, return -1.

ğŸ” What left_sum += num really means

It moves the divider:

Before:
[ left | current | right ]

After:
[ left + current | next | right ]


This is a running (implicit) prefix sum.

â±ï¸ Complexity

Time: O(n) (single pass)

Space: O(1) (no extra array)

ğŸ“Œ Why this is optimal

ğŸ“Œ Uses prefix sum logic without extra memory
ğŸ“Œ One loop, no nested sums
ğŸ“Œ Exactly what interviewers expect for LeetCode 724

ğŸ” Relation to LeetCode 304
Problem	Dimension	Prefix Sum Type
304	2D	Stored prefix matrix
724	1D	Running prefix sum

Same idea. Different dimension.


ğŸ‘‰ Problem: Product of Array Except Self (Prefix Ã— Suffix Product) (LeetCode 238)

You are given an integer array nums.
You must return an array answer where:

answer[i] = product of all elements except nums[i]

âš ï¸ Constraints:

No division

O(n) time

Follow-up: O(1) extra space

âœ… Key Idea

"Whatâ€™s missing at index i is everything to the left Ã— everything to the right."

So for every index:

answer[i] = (product of left side) Ã— (product of right side)


This is prefix product + suffix product, just like prefix sumsâ€”but with multiplication.

ğŸ§  Mental Map (Very Simple)

Imagine the array split at index i:

[ left product | nums[i] | right product ]


Ignore the middle. Multiply the two sides.

âœ¨ Flashcard

Product Except Self

answer[i] = prefix_product[i] Ã— suffix_product[i]

âš¡ Full Approach (Two-Pass, No Division)
Step 1 â€” Prefix products (left side)

Create an output array answer.

For each index:

Store the product of all elements before it

Example (nums = [1,2,3,4]):

answer = [1, 1, 2, 6]


(1 is neutral for multiplication)

Step 2 â€” Suffix products (right side)

Now walk from right to left, keeping a running right_product.

At each index:

answer[i] *= right_product
right_product *= nums[i]


This multiplies the right side into the stored left product.

Step 3 â€” Done

The output array now contains the correct product for every index.


ğŸ” Dry Run (Example 1)

Input

nums = [1,2,3,4]

After prefix pass
answer = [1, 1, 2, 6]

After suffix pass
answer = [24, 12, 8, 6]

ğŸ§  Why this works with zeros

Example:

nums = [-1,1,0,-3,3]


Prefix and suffix naturally handle zeros

No division â†’ no undefined behavior

Exactly one zero â†’ only one index has non-zero product

Multiple zeros â†’ all products are zero

â±ï¸ Complexity

Time: O(n)

Extra Space: O(1) (output array excluded)

ğŸ“Œ Interview Takeaways

ğŸ“Œ This is prefix-suffix multiplication
ğŸ“Œ Same pattern family as:

LeetCode 724 (Pivot Index)

LeetCode 304 (2D Prefix Sum)

LeetCode 560 (Subarray Sum)

ğŸ“Œ Division-based solutions are not accepted

Line-by-line Explanation
class Solution:
This defines the class as required by LeetCode.
Think of it as a â€œcontainerâ€ for the function.

def productExceptSelf(self, nums):
This defines the function.
nums is the input list.
self is just standard for class methods in Python.
n = len(nums)

Get the length of the array.
Weâ€™ll use this to loop through the array.

answer = [1] * n
Make an output array of the same size as nums.
Fill it with 1 because multiplying by 1 doesnâ€™t change anything.

prefix = 1
prefix will store the product of all numbers to the left of the current index.
Start with 1 because nothing is on the left of index 0.

for i in range(n):
    answer[i] = prefix
    prefix *= nums[i]

Step by step:
answer[i] = prefix â†’ store the product of all elements before index i.
prefix *= nums[i] â†’ include the current element in the left product for the next index.

After this loop:
answer[i] contains the product of all elements to the left of i.

suffix = 1
suffix will store the product of all numbers to the right of the current index.
Start with 1 because nothing is on the right of the last index.

for i in range(n - 1, -1, -1):
    answer[i] *= suffix
    suffix *= nums[i]

Step by step:

answer[i] *= suffix â†’ multiply the current value (left product) by the product of all elements to the right.
suffix *= nums[i] â†’ include the current element in the right product for the next index to the left.

After this loop:
answer[i] now contains product of everything except nums[i].

return answer

Return the final output array.

ğŸ§  Key Idea (Easy Way)

First loop â†’ collect left products.

Second loop â†’ multiply right products.

No division. One array used for output. Two simple passes.


ğŸ‘‰ Problem: Subarray Sum Equals K (1D Prefix Sum + Hash Map) (LeetCode 560)

You are given an integer array nums and an integer k.

Your task is to count how many continuous subarrays have a sum equal to k.

âœ… Key Idea

â€œTrack cumulative sums and count how many times weâ€™ve seen a needed sum before.â€

Instead of checking every subarray (slow), we reuse past prefix sums to instantly know how many valid subarrays end at the current index.

ğŸ§  Mental Map (Very Simple)

Imagine walking through the array while keeping a running balance.

At each step, ask:

â€œHave I ever seen a balance of (current_sum âˆ’ k) before?â€

If yes:

Every time it appeared = one valid subarray ending here

Then:

Record the current balance for future use

âœ¨ Flashcard

1D Prefix Sum Rule

subarray sum = current_sum âˆ’ previous_sum


So:

If current_sum âˆ’ k exists before â†’ subarray sum = k

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Initialize counters

count â†’ total number of valid subarrays

cum_sum â†’ running sum while iterating

prefix_counts â†’ stores:

prefix_sum â†’ how many times it appeared


Start with:

prefix_counts[0] = 1


ğŸ‘‰ This represents the empty prefix, allowing subarrays that start at index 0.

Step 2 â€” Traverse the array

Move through nums one element at a time.

At each element:

Add it to cum_sum

Now ask:

â€œDo I already have a prefix sum equal to cum_sum âˆ’ k?â€

Step 3 â€” Count valid subarrays

If cum_sum âˆ’ k exists:

Add its frequency to count

Why?

Each occurrence represents a different starting point

All of them form a valid subarray ending here

Step 4 â€” Store current prefix sum

Record the current cum_sum in prefix_counts.

Important:

Use increment, not assignment

Same cumulative sum can appear multiple times

This builds history for future checks.

Step 5 â€” Finish

After scanning the array:

count contains the total number of subarrays whose sum is k

Return it.

ğŸ§© Tiny Walkthrough
nums = [1, 2, 3]
k = 3

Index	num	    cum_sum	    cum_sum âˆ’ k	    Found before?	        count
start	 â€“	       0	        â€“	      prefix_counts[0]=1	       0
0	     1	       1	       -2	            âŒ	                   0
1	     2	       3	        0	            âœ…	                   1
2	     3	       6	        3	            âœ…	                   2

Valid subarrays:

[1,2]

[3]

â±ï¸ Complexity

Time: O(n) (single pass)

Space: O(n) (prefix sum map)

ğŸ“Œ Why this solution is perfect

ğŸ“Œ Works with negative numbers (sliding window fails)
ğŸ“Œ Optimal for interviews
ğŸ“Œ Exactly what LeetCode expects for Subarray Sum Equals K

ğŸ” Related problems:

Prefix sum basics

Subarray sum = 0

2D version â†’ Prefix Sum Matrix

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Middle of Linked List â€“ LeetCode 876)

Find the middle of a linked list using two pointers:
slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Fast ends â†’ slow is the middle.
Even list? â†’ second middle.â€

âš¡ Full Explanation (Very Easy)

1. Find the middle of a linked list
ğŸ¯ Goal

Return the middle node of a singly linked list.
If there are two middle nodes, return the second one.

ğŸ” How the code works (Line-by-Line)

Initialize pointers
slow, fast = head, head


slow â†’ moves 1 step at a time

fast â†’ moves 2 steps at a time

Both start at the head.

Traverse until fast reaches the end
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next


Fast moves twice as fast as slow

When fast reaches the end:

slow is at the middle

For even-length lists:

slow naturally lands on the second middle

Return slow
return slow


Middle node found âœ…

ğŸ§  Mental Map

â€œFast pointer finishes first â†’ slow pointer is the middle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

ğŸ‘‰ Floydâ€™s Tortoise and Hare + Reverse Second Half (LeetCode 2130)

Find the maximum twin sum in a linked list using two pointers and a reverse of the second half.

âœ¨ Flashcard

â€œFind middle â†’ reverse second half â†’ walk together â†’ add twins â†’ track max.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Find the middle of the linked list

ğŸ¯ Goal
Split the list into two halves so twin nodes can be aligned.

ğŸ§  Mental Picture

Original list: 5 â†’ 4 â†’ 2 â†’ 1
Slow stops at middle â†’ split
Left half:  5 â†’ 4
Right half: 2 â†’ 1


slow moves 1 step, fast moves 2 steps

When fast reaches the end â†’ slow is at middle

Even-length list â†’ slow lands at start of second half

2ï¸âƒ£ Reverse the second half

ğŸ¯ Goal
Align twins so we can walk left & right together.

ğŸ§  Mental Picture

Right half before reverse: 2 â†’ 1
After reverse:             1 â†’ 2


Twins now line up side by side

Left half stays the same

Right half is flipped

Think: â€œMirror the second half to face the first halfâ€

3ï¸âƒ£ Walk both halves and compute maximum twin sum

ğŸ¯ Goal
Add each twin pair and track the maximum sum.

ğŸ§  Mental Picture

Left:   5 â†’ 4
Right:  1 â†’ 2
Add pairs: 5+1=6, 4+2=6
Maximum = 6


Move both pointers together

Stop when the right pointer ends

Why right? â†’ Each node in the right half has exactly one twin

â€œCut â†’ Flip â†’ Add â†’ Track maxâ€

ğŸ§  Extra Notes / Mental Hooks

You donâ€™t need extra space

Only one pass to middle, one reverse, one pass for sums

Works for any even-length linked list

Fast pointer â†’ stops the middle naturally

Reversing the second half â†’ makes twin calculation simple

ğŸ“¦ Complexity

Time: O(n) â†’ middle + reverse + pair walk

Space: O(1) â†’ only pointers, no extra list

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Linked List Cycle â€“ LeetCode 141)

Detect if a linked list contains a cycle using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Meet? â†’ cycle exists.
Fast reaches end? â†’ no cycle.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Detect a cycle in a linked list

ğŸ¯ Goal
Return True if the linked list contains a cycle; otherwise, return False.

ğŸ§  Mental Picture

Example: 3 â†’ 2 â†’ 0 â†’ -4
           â†‘         â†“
           â†---------


Slow pointer moves 1 step at a time

Fast pointer moves 2 steps at a time

If a cycle exists:

Fast will eventually â€œlapâ€ slow

Slow and fast meet inside the cycle

If no cycle exists:

Fast reaches the end of the list (None)

No meeting â†’ return False

ğŸ”¹ Step-by-Step

Initialize pointers

slow = head

fast = head

Traverse the list

Move slow 1 step

Move fast 2 steps

Check if slow == fast

Yes â†’ cycle exists â†’ return True

No â†’ continue

End condition

Fast reaches the end â†’ no cycle â†’ return False

ğŸ§  Mental Map

â€œTwo runners in a track:
Slow walks, fast runs.
Meet? â†’ cycle.
Fast finishes track â†’ no cycle.â€

ğŸ“¦ Complexity

Time: O(n) â†’ slow + fast traverse at most once around the list

Space: O(1) â†’ only two pointers

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Linked List Cycle II â€“ LeetCode 142)

Find the starting node of a cycle in a linked list using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Meet inside cycle? â†’ rewind slow â†’ start of cycle.
Fast reaches end? â†’ no cycle.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Detect if a cycle exists

ğŸ¯ Goal
Determine whether the linked list contains a cycle first.

ğŸ§  Mental Picture

Example: 3 â†’ 2 â†’ 0 â†’ -4
           â†‘         â†“
           â†---------


Slow pointer moves 1 step

Fast pointer moves 2 steps

If a cycle exists:

Fast will eventually â€œlapâ€ slow

Slow and fast meet inside the cycle

If no cycle exists:

Fast reaches the end of the list (None) â†’ no cycle

ğŸ”¹ Step-by-Step

Initialize pointers

slow = head

fast = head

Traverse

Move slow 1 step

Move fast 2 steps

If slow == fast â†’ cycle exists â†’ go to next step

Else â†’ continue

If fast reaches the end â†’ return None (no cycle)

2ï¸âƒ£ Find the start of the cycle

ğŸ¯ Goal
Return the first node where the cycle begins.

ğŸ§  Mental Picture

Let slow = meeting point inside cycle

Let slow2 = head of the list

Move both pointers 1 step at a time

They will meet at the start of the cycle

List: 3 â†’ 2 â†’ 0 â†’ -4
Start: slow2 = head
Meeting: slow inside cycle
Walk both â†’ meet at node 2 (start of cycle)


Why it works:
Distance from head to cycle start = distance from meeting point to cycle start along the cycle

ğŸ§  Mental Map

â€œDetect cycle â†’ meet inside â†’ rewind slow to head â†’ both walk 1 step â†’ meet at cycle start.â€

ğŸ“¦ Complexity

Time: O(n) â†’ one pass to detect + one pass to find start

Space: O(1) â†’ only two pointers

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Find the Duplicate Number â€“ LeetCode 287)

Find the duplicate number in an array using the cycle detection technique (treat array values as â€œpointersâ€).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Meet inside cycle? â†’ rewind slow â†’ duplicate number found.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Detect the cycle in the array

ğŸ¯ Goal
Find if the â€œarray pointersâ€ form a cycle caused by the duplicate number.

ğŸ§  Mental Picture

Example: nums = [1,3,4,2,2]
Treat values as pointers:
0 â†’ 1 â†’ 3 â†’ 2 â†’ 4 â†’ 2 ...
Cycle occurs at the duplicate number 2


Slow moves 1 step: slow = nums[slow]

Fast moves 2 steps: fast = nums[nums[fast]]

If a duplicate exists:

Fast will eventually â€œlapâ€ slow

Slow and fast meet inside the cycle

ğŸ”¹ Step-by-Step

Initialize pointers

slow = nums[0]

fast = nums[0]

Traverse

Move slow 1 step

Move fast 2 steps

If slow == fast â†’ cycle detected â†’ go to next step

Why this works: treating array indices and values as a linked list guarantees a cycle because at least one number is repeated.

2ï¸âƒ£ Find the duplicate number (start of cycle)

ğŸ¯ Goal
Return the duplicate number causing the cycle.

ğŸ§  Mental Picture

Let slow = meeting point inside cycle

Let slow2 = start of array (nums[0])

Move both pointers 1 step at a time

They will meet at the duplicate number

Array: [1,3,4,2,2]
Start: slow2 = nums[0] = 1
Meeting: slow inside cycle at 2
Walk both â†’ meet at 2 (duplicate number)


Distance from start to duplicate = distance from meeting point to duplicate along the cycle

ğŸ§  Mental Map

â€œTreat array as linked list â†’ detect cycle â†’ meet inside â†’ rewind slow â†’ meet at duplicate.â€

ğŸ“¦ Complexity

Time: O(n) â†’ slow + fast traverse at most twice

Space: O(1) â†’ constant pointers, no extra array

ğŸ‘‰ Implement Trie (Prefix Tree) - (Leetcode 208)

Store words efficiently and answer search and prefix queries by sharing common letter paths.

âœ¨ Flashcard

â€œLetters form paths.
Only some nodes are word endings.
Prefix â‰  word.â€

âš¡ Full Explanation (Very Easy)
1. Inserting a word
ğŸ¯ Goal

Store a word letter by letter while reusing common prefixes.

ğŸ” How it works

â€¢ Start from the root (empty node)
â€¢ Move through each letter in order
â€¢ If a letter path doesnâ€™t exist â†’ create it
â€¢ Move forward until the last letter

âš¡ At the last letter, mark:

â€œA complete word ends here.â€

This is what the word flag represents.

ğŸ§  Mental Map

â€œWalk letters â†’ stop â†’ stamp END OF WORD.â€

2. Searching for a word
ğŸ¯ Goal

Confirm whether a full word exists â€” not just a prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Follow the path of each letter
â€¢ If any letter is missing â†’ word does not exist
â€¢ After the final letter, check:

âš¡ Is this node marked as a word end?

âœ” Yes â†’ valid word
âŒ No â†’ only a prefix

ğŸ§  Mental Map

â€œPath exists + word-end stamp â†’ word found.â€

3. Checking a prefix (startsWith)
ğŸ¯ Goal

Check whether any word starts with this prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Walk through prefix letters
â€¢ If all letters exist in sequence â†’ prefix exists

ğŸš« No need to check word ending

ğŸ§  Mental Map

â€œPrefix only needs a path, not a destination.â€

â­ Why the word flag is CRITICAL

Imagine storing:

â€¢ car
â€¢ cat

Both share the path: c â†’ a

But:

â€¢ car ends at r
â€¢ cat ends at t

Without a word-ending marker:
âŒ The Trie cannot tell whether â€œcaâ€ is a word or just a prefix.

ğŸ‘‰ The word flag answers one question only:

â€œDoes a complete word stop here?â€

ğŸ“¦ Complexity

â€¢ Time per operation: linear in word length
â€¢ Extra space: only for new letters

ğŸ§  One-Line Intuition

â€œTrie remembers paths.
word = True remembers when to stop.â€

ğŸ‘‰ Design Add and Search Words Data Structure - WordDictionary (Trie + DFS with . wildcard) (Leetcode 211)

Store words efficiently and support flexible search where . can match any letter, by combining a Trie with DFS.

âœ¨ Flashcard

â€œTrie gives structure.
. gives freedom.
One matching path = success.â€

âš¡ Full Explanation (Very Easy)
1. Adding a word

ğŸ¯ Goal
Store a word so it can be searched later (with or without .).

ğŸ” How it works

â€¢ Start from the root (empty node)
â€¢ Move through each letter one by one
â€¢ If a letter path doesnâ€™t exist â†’ create it
â€¢ Move forward until the last letter

âš¡ At the last letter, mark:

â€œA complete word ends here.â€

This is stored using the word flag.

ğŸ§  Mental Map

â€œWalk letters â†’ stop â†’ stamp END OF WORD.â€

2. Searching for a word (with . support)

ğŸ¯ Goal
Check if any stored word matches the search pattern.

ğŸ” How it works (Big Picture)

â€¢ Start from the root
â€¢ Match the word character by character
â€¢ Normal letter â†’ follow one path
â€¢ Dot . â†’ try all possible paths
â€¢ If at least one path succeeds â†’ return True

3. DFS helper (core idea)

ğŸ¯ Goal
Answer this question:

â€œFrom this node, can the rest of the word be matched?â€

ğŸ” Step-by-step logic

â€¢ i = current position in the search word
â€¢ node = where we are in the Trie

âš¡ When i == len(word)

We reached the end of the search word.

âœ” If a word ends here â†’ match found
âŒ Otherwise â†’ only a prefix

ğŸ§  Mental Map

â€œWord finished â†’ check word-end stamp.â€

ğŸ”€ When current character is .

Dot means wildcard.

ğŸ” What we do:

â€¢ Try every child of the current node
â€¢ Recursively search the rest of the word
â€¢ If any path works, stop and return True
â€¢ If all paths fail â†’ return False

ğŸ§  Mental Map

â€œDot = open every door.
One success is enough.â€

ğŸ”’ When current character is a letter

â€¢ If the letter path doesnâ€™t exist â†’ fail
â€¢ If it exists â†’ move forward and continue

ğŸ§  Mental Map

â€œLetter locks the path.
No road â†’ dead end.â€

4. Why search starts with dfs(0, root)

â€¢ 0 â†’ start from the first character
â€¢ root â†’ all words in a Trie start here

ğŸ§  Mental Map

â€œWords start at the root.
Matching starts at index 0.â€

â­ Example Walkthrough

Stored words:
â€¢ bat
â€¢ bdc
â€¢ bad

Search:

b.d


ğŸ§  What happens:

â€¢ b â†’ follow b
â€¢ . â†’ try all children (a, d)
â€¢ d â†’ check if word ends here

âœ” Path b â†’ a â†’ d â†’ "bad" matches
âœ” Return True

ğŸ“¦ Complexity

â€¢ Add word: linear in word length
â€¢ Search:

No dot â†’ linear

With dots â†’ branching (still safe due to max 2 dots)

â€¢ Add word â†’ O(L)
â€¢ Search without dot â†’ O(L)
â€¢ Search with dot â†’ O(26áµˆ Â· L), but d â‰¤ 2, so practical and safe

ğŸ§  One-Line Intuition


â€œTrie remembers paths.
DFS explores options.
. turns search into smart branching.â€

ğŸ‘‰ Word Search II (Trie + Backtracking DFS) (Leet Code 212)

Find all words from a list that can be formed by walking adjacent cells on a board without reusing a cell.

âœ¨ Flashcard

â€œBoard = maze.
Words = Trie.
DFS walks the board, Trie prunes dead paths.â€

âš¡ Full Mental Map (Very Easy)

This problem looks scary, but itâ€™s really three ideas glued together:

1ï¸âƒ£ Trie â†’ store all words efficiently
2ï¸âƒ£ DFS on the board â†’ walk letters
3ï¸âƒ£ Pruning â†’ stop early when no word can match

ğŸ§  Big Picture Strategy

âŒ Bad idea:
For every word â†’ search the board
â†’ too slow (30k words Ã— DFS)

âœ… Good idea:
Search the board once, and use a Trie to check which words are possible.

ğŸ§© Step 1: Build a Trie from words

ğŸ¯ Goal
Share prefixes so we donâ€™t repeat work.

Example words:

["oath", "eat", "pea", "rain"]


Trie mental shape:

(root)
 â”œâ”€â”€ o â†’ a â†’ t â†’ h (word)
 â”œâ”€â”€ e â†’ a â†’ t (word)
 â”œâ”€â”€ p â†’ e â†’ a
 â””â”€â”€ r â†’ a â†’ i â†’ n


ğŸ§  Mental Map
â€œTrie tells us which paths are promising.â€

ğŸ§© Step 2: DFS from every board cell

ğŸ¯ Goal
Start DFS from each cell and try to build words.

From each cell:
â€¢ Move up / down / left / right
â€¢ Mark cell as visited
â€¢ Follow Trie paths
â€¢ Backtrack when done

ğŸ§  Mental Map
â€œBoard walk + Trie walk at the same time.â€

ğŸ§© Step 3: Pruning (MOST IMPORTANT)

ğŸ¯ Goal
Stop exploring paths that canâ€™t form any word.

If:
â€¢ Current letter not in Trie children
â†’ STOP immediately

ğŸ§  Mental Map
â€œNo Trie path â†’ dead end â†’ donâ€™t explore further.â€

ğŸ§© Step 4: Found a word

When:
â€¢ Trie node says word = True

âœ” Add word to result
âœ” Mark it False (avoid duplicates)

ğŸ§  Mental Map
â€œReached a word-end stamp â†’ collect word.â€

ğŸ§  One Full DFS Thought

â€œFrom this board cell, can I walk in such a way that letters follow a Trie path and end at a word?â€

ğŸ“¦ Complexity (with Big-O)

Let:
â€¢ M Ã— N = board size
â€¢ W = number of words
â€¢ L = max word length

Time

O(M Ã— N Ã— 4á´¸) (worst case)
ğŸ‘‰ In practice much faster due to Trie pruning

Space

â€¢ Trie: O(W Ã— L)
â€¢ DFS recursion: O(L)

ğŸ§  One-Line Intuition (Interview Gold)

â€œTrie reduces word search to prefix checking, DFS explores the board, and pruning kills useless paths early.â€


ğŸ‘‰ Prefix & Suffix Search (Trie Trick) (LeetCode 745)

Given a list of words, support queries:

f(prefix, suffix) â†’ largest index of a word
that starts with prefix AND ends with suffix


âœ¨ Flashcard

â€œSuffix first, then #, then prefix.
Store everything in one Trie.â€

âš¡ Full Mental Map (Very Easy)

This problem looks clever, but itâ€™s really one big trick:

1ï¸âƒ£ Combine suffix + '#' + word
2ï¸âƒ£ Store everything in one Trie
3ï¸âƒ£ During search, walk suffix + '#' + prefix

Thatâ€™s it.

ğŸ§  Big Picture Strategy

âŒ Bad idea
For every query:
â€¢ Check every word
â€¢ Check prefix + suffix
â†’ O(N Ã— word_length) â†’ too slow

âœ… Good idea
Precompute all suffixâ€“prefix combinations once using a Trie.

ğŸ§© Step 1: Why the # character?
long_word = "#" + word


ğŸ¯ Goal
Separate suffix and prefix clearly.

ğŸ§  Mental Map
# is a wall:

[suffix] # [prefix]


No ambiguity. Clean split.

ğŸ§© Step 2: Insert ALL suffixes of each word

Example words:

words = ["apple"]


Word index = 0

All suffixes of "apple":

"apple"
"pple"
"ple"
"le"
"e"
""

ğŸ§© Step 3: What exactly do we insert?

For every suffix:

suffix + "#" + word

Inserted strings for "apple":
apple#apple
pple#apple
ple#apple
le#apple
e#apple
#apple


ğŸ§  Mental Map
â€œEvery possible suffix is paired with the full word.â€

ğŸ§© Step 4: Trie insertion (core loop)
for j in range(len(word) + 1):
    curr = self.root
    curr.index = i
    for c in word[j:] + long_word:
        if c not in curr.children:
            curr.children[c] = TrieNode()
        curr = curr.children[c]
        curr.index = i

Whatâ€™s happening mentally?

â€¢ Start at root
â€¢ Walk character by character
â€¢ Create nodes if needed
â€¢ Always update index = i

ğŸ§  Mental Map

â€œEvery node remembers the latest word index passing through it.â€

Thatâ€™s how we get maximum index automatically.

ğŸ§  Trie Mental Shape (Partial)
(root)
 â”œâ”€â”€ l â†’ e â†’ # â†’ a â†’ p â†’ p â†’ l â†’ e   (index=0)
 â”œâ”€â”€ p â†’ l â†’ e â†’ # â†’ a â†’ p â†’ p â†’ l â†’ e
 â”œâ”€â”€ # â†’ a â†’ p â†’ p â†’ l â†’ e


Each path represents:

suffix # word

ğŸ§© Step 5: Searching
def f(self, pref, suff):
    search = suff + "#" + pref


Example query:

f("ap", "le")


Search string:

"le#ap"


ğŸ§  Mental Map
â€œIf le#ap exists, then:
suffix = le
prefix = ap
â†’ valid word exists.â€

ğŸ§© Step 6: Trie traversal
for c in search:
    if c not in curr.children:
        return -1
    curr = curr.children[c]


â€¢ Walk Trie exactly like a prefix search
â€¢ If path breaks â†’ no match

ğŸ§© Step 7: Return answer
return curr.index


ğŸ¯ Why this works
Because during insertion:

curr.index = i


was always updated.

ğŸ§  Mental Map
â€œThe deepest node holds the largest index.â€

ğŸ§  One Full Thought (Interview Gold)

â€œI pre-store every suffix combined with the word in a Trie.
During query, I search suffix#prefix.
The Trie node already knows the largest index.â€

ğŸ“¦ Complexity

Let:
â€¢ N = number of words
â€¢ L = max word length

Time
Build: O(N Ã— LÂ²)
Query: O(L)

Space
Trie: O(N Ã— LÂ²)

ğŸ§  One-Line Intuition

â€œTurn prefixâ€“suffix search into a single Trie lookup using
suffix#prefix.â€

ğŸ‘‰ Redundant Connection (Union-Find Trick) (LeetCode 684)

Given a graph that was originally a tree,
one extra edge was added.

Return the edge that creates the cycle.

âœ¨ Flashcard

â€œBuild the tree edge by edge.
If two nodes already share a leader â†’ cycle found.â€

âš¡ Full Mental Map (Very Easy)

This problem looks like graph theory,
but itâ€™s really one simple idea:

1ï¸âƒ£ Build connections gradually
2ï¸âƒ£ Track connected components
3ï¸âƒ£ The first edge that connects same component â†’ redundant

Thatâ€™s it.

ğŸ§  Big Picture Strategy

âŒ Bad idea
For every edge:
â€¢ Run DFS to check cycle
â†’ O(NÂ²)

Too slow.

âœ… Good idea
Use Union-Find to track connectivity in near O(1).

Union-Find answers one question fast:

â€œAre these two nodes already connected?â€

ğŸ§© Step 1: Initialize Disjoint Sets

We create:

â€¢ A parent for every node
â€¢ A rank (tree height)

Initially:

1   2   3   4
â†‘   â†‘   â†‘   â†‘


Everyone is their own group.

ğŸ§  Mental Map
â€œEveryone starts alone.â€

ğŸ§© Step 2: Process Edges One by One

We loop through edges in order:

For each edge (u, v):

Try to connect them.

ğŸ§© Step 3: What Does Union Actually Do?

Union does two things:

1ï¸âƒ£ Find root of u
2ï¸âƒ£ Find root of v

If both roots are same:

âš ï¸ Theyâ€™re already connected
âš ï¸ Adding this edge forms a cycle

Return False.

If different:

Attach one tree under the other (by rank).
Return True.

ğŸ§  Mental Map

â€œDifferent leaders â†’ merge groups.
Same leader â†’ loop detected.â€

ğŸ§© Step 4: Path Compression (Hidden Speed Boost)

During find:

While climbing upward to find the root:

â€¢ Make nodes skip their parent
â€¢ Point them closer to root

Instead of:

1 â†’ 2 â†’ 3 â†’ 4


It becomes:

1 â†’ 4
2 â†’ 4
3 â†’ 4


Future finds become almost instant.

ğŸ§  Mental Map

â€œClimb to the leader.
Shorten the ladder while climbing.â€

ğŸ§© Step 5: Why Returning Immediately Works

We process edges in input order.

The first time union fails:

That edge is the one that closes the cycle.

Problem says:

â€œIf multiple answers exist, return the one that occurs last.â€

Because:

â€¢ Earlier edges build the tree
â€¢ The last edge that closes the loop is the redundant one

Union-Find naturally detects it.

ğŸ§ª Example 1

Input:

[[1,2],[1,3],[2,3]]


Process:

â€¢ (1,2) â†’ merge
â€¢ (1,3) â†’ merge
â€¢ (2,3) â†’ already connected

Return:

[2,3]

ğŸ§ª Example 2

Input:

[[1,2],[2,3],[3,4],[1,4],[1,5]]


Process:

â€¢ (1,2) merge
â€¢ (2,3) merge
â€¢ (3,4) merge
â€¢ (1,4) â†’ already connected

Return:

[1,4]

â­ Why This Works

Because in a tree:

â€¢ No cycles
â€¢ Exactly n-1 edges

Adding one more edge:

â€¢ Must create exactly one cycle

Union-Find detects exactly that moment.

ğŸ“¦ Complexity

Let:

â€¢ n = number of nodes

Time
Almost O(n)

(technically O(n Î±(n)))

Space
O(n)

ğŸ§  One-Line Intuition

â€œWhile building the tree,
the first edge that connects two already-connected nodes
is the redundant edge.â€

ğŸ‘‰ Accounts Merge (Union-Find Trick) (LeetCode 721)

Given a list of accounts, merge all accounts that belong to the same person. Two accounts belong to the same person if any email is shared.

âœ¨ Flashcard

â€œEmails are nodes. Accounts sharing emails are connected. Union-Find merges accounts. Then collect all emails per person.â€

âš¡ Full Mental Map (Very Easy)

This problem looks like string/email processing, but itâ€™s really graph connectivity:

1ï¸âƒ£ Treat each account as a node.
2ï¸âƒ£ If two accounts share an email â†’ connect them.
3ï¸âƒ£ Union-Find merges connected accounts.
4ï¸âƒ£ Collect all emails for each connected component â†’ merged account.

ğŸ§  Big Picture Strategy

âŒ Bad idea

Compare every account pair for shared emails â†’ O(NÂ² Ã— email_length) â†’ too slow

âœ… Good idea

Use Union-Find to track account connectivity efficiently

Then group emails by root parent â†’ final result

ğŸ§© Step 1: Initialize Union-Find

Create a parent for every account

Create a rank to optimize merging

0   1   2   3
â†‘   â†‘   â†‘   â†‘


Everyone starts in their own group.

ğŸ§© Step 2: Map emails to accounts & Union

Loop through accounts:

For each email, check if it already exists in email_to_account

If yes â†’ merge current account with previous account owning that email

If no â†’ map this email to current account index

Mental Map

Accounts 0 & 1 share 'b@mail' â†’ merged
Accounts 2 separate


Union-Find ensures all connected accounts have the same root.

ğŸ§© Step 3: Group emails by root parent

For every email:

root = uf.find(account_index)


Find which person/component it belongs to

Add email to root_to_emails[root]

Mental Map

root 0 â†’ ["a@mail","b@mail","c@mail"]
root 2 â†’ ["d@mail"]


ğŸ§© Step 4: Build final merged accounts

For each root:

name = accounts[root][0] â†’ pick the personâ€™s name

emails = sorted(root_to_emails[root]) â†’ sort emails alphabetically

Append [name] + emails to result

Mental Map

0 â†’ ["John", "a@mail","b@mail","c@mail"]
2 â†’ ["Mary", "d@mail"]


ğŸ§  Why It Works

Union-Find merges all accounts connected by emails

Root parent = representative of each person

Grouping emails by root gives all emails for that person

Sorting + adding name â†’ final merged account

ğŸ§ª Example

Input:

accounts = [
    ["John","a@mail","b@mail"],
    ["John","b@mail","c@mail"],
    ["Mary","d@mail"]
]


Process:

Map emails â†’ union accounts 0 & 1

Group emails by root:

0 â†’ ["a@mail","b@mail","c@mail"]
2 â†’ ["d@mail"]


Build result:

[
  ["John","a@mail","b@mail","c@mail"],
  ["Mary","d@mail"]
]


ğŸ“¦ Complexity

N = number of accounts, E = total emails

Time

O(N + E log E) (log E for sorting emails)

Space

O(N + E) for Union-Find and mapping

ğŸ§  One-Line Intuition

â€œEach account is a node. Emails connect accounts. Union-Find merges nodes. Collect all emails per root â†’ merged account.â€


ğŸ‘‰ Problem type: Consecutive Sequence â€“ Longest Consecutive Sequence (LeetCode 128)

âœ¨ Flashcard:
â€œLongest streak starts at the beginning of a sequence. Use a set for O(1) lookups. Track streak length.â€

âš¡ Full Approach

We need the length of the longest consecutive numbers in an unsorted array.

ğŸ”¥ Key Idea: HashSet + Sequence Start Check

Instead of sorting (O(n log n)):

Store all numbers in a set â†’ fast lookup

For each number, only start a streak if num - 1 is not in the set â†’ ensures we start at sequence beginnings

Count consecutive numbers num, num+1, num+2â€¦ â†’ track streak length

Return the maximum streak length

ğŸ§  Steps / Mental Map

Step 1: Put numbers in a set

Fast O(1) lookup

Removes duplicates

Mental Map:

nums â†’ set(nums)


Step 2: Loop through each number in the set

Only start counting at sequence beginnings

Skip numbers in the middle of a sequence â†’ avoids duplicate work

Mental Map:

num - 1 not in set â†’ start streak
num - 1 in set â†’ skip


Step 3: Count consecutive numbers

Move forward along the consecutive sequence

Increase streak for each consecutive number

Mental Map:

current â†’ num
streak = 1
while current + 1 in set â†’ current += 1, streak += 1


Step 4: Track the longest streak

Keep updating the maximum streak length

Ensures the final answer is the longest sequence

Mental Map:

longest = max(longest, streak)


ğŸ“¦ Complexity

Time: O(n) â†’ each number processed at most twice

Space: O(n) â†’ set stores all numbers

ğŸ§  One-Line Intuition / Mental Map

Numbers â†’ set
Sequence start? num-1 not in set â†’ count streak
Update max streak â†’ return

ğŸ‘‰ Problem type: Segment Tree â€“ Range Sum Query (Mutable) (LeetCode 307)

âœ¨ Flashcard:
â€œSplit the array into ranges.
Store sum at each node.
Update one leaf â†’ fix ancestors.
Query only overlapping ranges.â€

âš¡ Full Approach

We need to support:

â€¢ update(index, val)
â€¢ sumRange(left, right)

Efficiently.

Brute force:

â€¢ Update â†’ O(1)
â€¢ Range sum â†’ O(n) âŒ (too slow for many queries)

Better approach â†’ Segment Tree

ğŸ”¥ Key Idea: Store Partial Sums in a Tree

Instead of recalculating sums every time:

â€¢ Divide array into halves
â€¢ Each node stores sum of its range
â€¢ Update affects only one root-to-leaf path
â€¢ Query touches only relevant segments

ğŸ§  Steps / Mental Map

Step 1: Build the Tree (O(n))

Split array recursively:

[0-3]
 /   \
[0-1] [2-3]


Each node stores:

sum = left.sum + right.sum


Mental Map:

Divide â†’ Build children â†’ Combine


Code logic:

if L == R:
    return leaf

build left
build right
sum = left + right

Step 2: Update a Value (O(log n))

Goal: Change nums[index] = val

Process:

â€¢ Go down to the correct leaf
â€¢ Update its sum
â€¢ While returning â†’ recompute parent sums

Only one path is visited (tree height = log n)

Mental Map:

Go to leaf
Fix sums while climbing back

Step 3: Query Range Sum (O(log n))

Goal: Return sum from left to right

Three cases:

1ï¸âƒ£ Exact match â†’ return sum immediately
2ï¸âƒ£ Entirely in left subtree â†’ go left
3ï¸âƒ£ Entirely in right subtree â†’ go right
4ï¸âƒ£ Split across middle â†’ query both sides

Mental Map:

No overlap â†’ ignore
Full overlap â†’ return
Partial overlap â†’ split


ğŸ“¦ Complexity

Time:

â€¢ Build â†’ O(n)
â€¢ Update â†’ O(log n)
â€¢ sumRange â†’ O(log n)

Space:

â€¢ O(n)

ğŸ§  One-Line Intuition / Mental Map

Array â†’ break into ranges
Store partial sums
Update one leaf â†’ fix upward
Query only needed pieces â†’ fast answer ğŸš€

ğŸ‘‰ Problem type: Greedy + Sorting â€“ Queue Reconstruction by Height (LeetCode 406)

âœ¨ Flashcard:
â€œPlace taller people first.
For same height â†’ smaller k first.
Insert at index k â†’ guarantees k taller people in front.â€

âš¡ Full Approach

We need to reconstruct the queue such that:

For each person [h, k] â†’
Exactly k people in front have height â‰¥ h.

Brute force is tricky:

Trying to place short people first â†’ breaks taller peopleâ€™s condition âŒ

Better approach â†’ Greedy + Sort + Insert

ğŸ”¥ Key Idea: Tallest First + Insert at k

Instead of placing randomly:

1ï¸âƒ£ Place tall people first
2ï¸âƒ£ Insert each person at index = k

Why?

All people already in the list are taller or same height

Inserting at k ensures exactly k taller people in front

Shorter people inserted later do not affect taller people

ğŸ§  Steps / Mental Map

Step 1: Sort People
people.sort(key=lambda x: (-x[0], x[1]))


x[0] = height â†’ -x[0] â†’ descending order

x[1] = k â†’ ascending order if heights tie

Example:

Input: [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Sorted: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]


Mental Map:

Tallest â†’ first
If tie â†’ smaller k first

Step 2: Insert Each Person at Index k
res = []
for person in people:
    res.insert(person[1], person)


Process:

Take person [h, k]

Insert into res at index = k

Why does this work?

All previously inserted people are taller or same height

So inserting at index k guarantees exactly k taller people in front

Example step:

1ï¸âƒ£ Insert [7,0] at 0 â†’ [[7,0]]
2ï¸âƒ£ Insert [7,1] at 1 â†’ [[7,0],[7,1]]
3ï¸âƒ£ Insert [6,1] at 1 â†’ [[7,0],[6,1],[7,1]]

Check [6,1]: one taller person in front âœ”

Step 3: Return Result
return res


Fully reconstructed queue satisfying all [h, k] constraints

ğŸ“¦ Complexity

Sorting â†’ O(n log n)

Insertion â†’ O(nÂ²) worst case

Space â†’ O(n)

ğŸ§  One-Line Intuition / Mental Map

Sort tall â†’ insert at k â†’ shorter people adjust around taller â†’ queue satisfies all conditions ğŸš€

ğŸ‘‰ Problem type: Interval Overlap Detection â€“ Calendar Booking (LeetCode 729)

âœ¨ Flashcard:

â€œEach booking is a block on a timeline.
If new block enters an existing blockâ€™s space â†’ Reject âŒ
If it stays completely outside â†’ Accept âœ…â€

âš¡ Full Approach

We maintain a calendar that contains multiple time blocks.

Each time block represents a booked event.

When a new booking request arrives, our goal is:

âš¡ Ensure it does NOT occupy the same time space as any existing block.

ğŸ”¥ Key Idea: Detect Space Collision

Think of time as a straight line.

Each booking occupies some portion of that line.

When placing a new booking, we check:

Does the new booking start before an existing booking finishes
AND

Does the new booking finish after an existing booking starts

If both happen, it means:

âš¡ The new booking has entered the space of an existing booking

So it must be rejected.

ğŸ§  Steps / Mental Map

Step 1: Maintain a list of booked time blocks

Your calendar is simply a collection of occupied spaces.

Step 2: For every new booking, scan all existing blocks

You mentally compare the new block with each existing block.

Goal:

âš¡ Ensure the new block does not invade any occupied space.

Step 3: Decision

If the new block touches occupied space â†’ Reject

If the new block stays fully in free space â†’ Accept and add it to calendar

ğŸ“¦ Complexity

Time:

O(n)

Because each new booking checks all existing bookings

Space:

O(n)

Because bookings are stored

ğŸ§  One-Line Intuition / Mental Map

Treat bookings like blocks on a timeline â†’
New block must fit in empty space only â†’
If it touches another blockâ€™s space â†’ Reject âŒ
Else â†’ Accept âœ…

ğŸ‘‰ Problem type: Dynamic Programming + Segment Tree â€“ Longest Increasing Subsequence II (LeetCode 2407)

âœ¨ Flashcard:
â€œUse a segment tree to track the max length of subsequences ending at each value.
Query range [num - k, num - 1] â†’ max previous length.
Update current value â†’ extend subsequence by 1.â€

âš¡ Full Approach

We need the longest strictly increasing subsequence where the difference between adjacent elements â‰¤ k.

Brute force DP (O(n^2)) â†’ too slow âŒ
Better approach â†’ Segment Tree + Range Max Query

ğŸ”¥ Key Idea: Use Segment Tree for Range Max

Instead of checking all previous numbers individually:

1ï¸âƒ£ For current num:
Query max subsequence length in [num - k, num - 1]
â†’ gives the longest subsequence that can extend to num.

2ï¸âƒ£ Update num in segment tree with prev_max + 1
â†’ store the longest subsequence ending with num.

ğŸ§  Steps / Mental Map

Step 1: Initialize segment tree

max_num = max(nums)
seg_tree = SegmentTree(max_num, func=max, default=0)


max_num = max element in nums

func=max â†’ we want maximum in a range

default=0 â†’ initial subsequence length

Step 2: Traverse nums

for num in nums:
    prev_max = seg_tree.query(max(1, num - k), num - 1)
    curr_len = prev_max + 1
    seg_tree.update(num, curr_len)
    res = max(res, curr_len)


query(max(1, num-k), num-1) â†’ longest subsequence ending with numbers â‰¤ k behind

curr_len = prev_max + 1 â†’ extend subsequence by 1

update(num, curr_len) â†’ store max length ending at num

res = max(res, curr_len) â†’ keep global maximum

Step 3: Return the result

return res


ğŸ“¦ Complexity

Time: O(n log M) â†’ n = len(nums), M = max(nums)
Each query/update on segment tree = O(log M)

Space: O(M) â†’ for segment tree

ğŸ§  One-Line Intuition / Mental Map

â€œQuery max in [num-k, num-1] â†’ extend subsequence â†’ update num in segment tree â†’ global max tracks longest subsequence ğŸš€â€

Example Run

Input: nums = [4,2,1,4,3,4,5,8,15], k = 3

Mental Map:

1ï¸âƒ£ num=1 â†’ query [1-3,0] = empty â†’ length=1 â†’ update 1
2ï¸âƒ£ num=2 â†’ query [max(1,-1),1] = 1 â†’ length=2 â†’ update 2
3ï¸âƒ£ num=3 â†’ query [0,2] = 2 â†’ length=3 â†’ update 3
4ï¸âƒ£ num=4 â†’ query [1,3] = 3 â†’ length=4 â†’ update 4
5ï¸âƒ£ num=5 â†’ query [2,4] = 4 â†’ length=5 â†’ update 5

Output = 5 âœ…

ğŸ‘‰ Problem type: Heap â€“ Median from Data Stream (LeetCode 295)

âœ¨ Flashcard:
â€œUse two heaps: max heap for smaller half, min heap for larger half.
Median = top of max heap / min heap or average if even number of elements.â€

âš¡ Full Approach

We need to continuously find the median as numbers arrive in a data stream.

Brute force (sorting each time) â†’ too slow âŒ
Better approach â†’ Two Heaps

ğŸ”¥ Key Idea: Two Heaps

small (max heap) â†’ stores the smaller half of numbers (negate numbers for max heap in Python)

large (min heap) â†’ stores the larger half of numbers

Balance heaps so size difference â‰¤ 1

Median is either:

top of larger heap if it has more elements

top of smaller heap if it has more elements

average of both tops if equal

ğŸ§  Steps / Mental Map

Step 1: Initialize heaps

small = []  # max heap (negated numbers)
large = []  # min heap


Step 2: Insert number

1ï¸âƒ£ Push num to max heap (small)
2ï¸âƒ£ If top of small > top of large â†’ swap to maintain order
3ï¸âƒ£ Balance heaps â†’ size difference â‰¤ 1


heapq in Python is min heap â†’ negate values to simulate max heap

Step 3: Find median

if len(small) > len(large): return -small[0]
if len(large) > len(small): return large[0]
return (-small[0] + large[0]) / 2.0  # even number of elements


ğŸ“¦ Complexity

Operation	Time
addNum	O(log n) â†’ heap push/pop
findMedian	O(1)

Space: O(n) â†’ for both heaps

ğŸ§  One-Line Intuition / Mental Map
â€œMaintain two balanced heaps â†’ top elements give median instantly ğŸš€â€

Example Run

Input stream: [1, 2, 3]

Mental Map:

1ï¸âƒ£ num=1 â†’ push to small â†’ small=[1] â†’ median = 1
2ï¸âƒ£ num=2 â†’ push to small â†’ small=[1,2] â†’ balance â†’ small=[1], large=[2] â†’ median = (1+2)/2 = 1.5
3ï¸âƒ£ num=3 â†’ push to small â†’ small=[1,3], large=[2] â†’ balance â†’ small=[2,1], large=[3] â†’ median = 2

Output: [1, 1.5, 2] âœ…


ğŸ‘‰ Problem type: Heap + Lazy Deletion â€“ Sliding Window Median (LeetCode 480)

âœ¨ Flashcard:

â€œUse two heaps to maintain median.
Use lazy deletion to remove old window elements efficiently.â€

âš¡ Full Approach

We need the median of every sliding window of size k.

Example:

nums = [1,3,-1,-3,5,3,6,7], k=3
Window moves â†’ median changes

Brute force:

Sort every window â†’ O(k log k) per window âŒ too slow

Optimal â†’ Two Heaps + Lazy Deletion

ğŸ”¥ Key Idea: Three Components

1ï¸âƒ£ Two Heaps â†’ maintain median

small â†’ max heap â†’ smaller half
large â†’ min heap â†’ larger half

Rule:

small can have equal OR 1 extra element

Median:

odd â†’ top of small
even â†’ average of both tops

2ï¸âƒ£ Problem: Removing old element is hard âŒ

Heap cannot remove arbitrary element in O(log n)

Example:

Heap = [1,3,5,7]

Remove 3 â†’ not possible directly

3ï¸âƒ£ Solution: Lazy Deletion âœ…

Instead of removing immediately:

Mark it in dictionary

self.delayed[num] += 1

Remove later when it reaches top

This is called lazy deletion

ğŸ§  Steps / Mental Map

Overall Flow:

Add new number
Balance heaps
Get median
Mark outgoing number for deletion
Prune heaps if needed
Balance again

ğŸ§± Class DualHeap Mental Model

Think:

small â†’ left half
large â†’ right half
delayed â†’ garbage list
small_size â†’ valid elements count
large_size â†’ valid elements count

ğŸ§¹ prune() â†’ Garbage Collector

âœ¨ Purpose:

Remove invalid elements from heap top

Code Logic:

while heap top is marked deleted:
    remove it
    decrease delayed count


Why needed?

Because heap still contains old elements physically

âš–ï¸ balance() â†’ Maintain Heap Structure

Goal:

size difference â‰¤ 1
small always >= large


Case 1:

small too big:

move â†’ small â†’ large

Case 2:

large too big:

move â†’ large â†’ small

After move â†’ prune invalid elements

â• add(num) â†’ Insert New Element

Step 1:

If num â‰¤ small max

â†’ goes to small

Else

â†’ goes to large

Step 2:

Balance heaps

Complexity:

O(log k)

â– remove(num) â†’ Lazy Delete

Step 1:

Mark deleted

self.delayed[num] += 1

Step 2:

Decrease correct heap size

Step 3:

If number is at heap top â†’ prune immediately

Step 4:

Balance heaps

ğŸ¯ get_median()

Case 1: odd window

return top of small

Case 2: even window

return average

O(1)

ğŸš€ Sliding Window Driver Code
for i in range(len(nums)):

    add(nums[i])

    if window formed:

        record median

        remove outgoing element

ğŸ§  One-Line Intuition / Mental Map

â€œTwo heaps store median, lazy deletion removes expired elements efficiently.â€

ğŸ”¥ Example Run

nums = [1,3,-1,-3,5], k=3

Window 1:

[1,3,-1]

small = [1,-1]
large = [3]

median = 1

Slide â†’

remove 1
add -3

Window:

[3,-1,-3]

median = -1

Slide â†’

remove 3
add 5

Window:

[-1,-3,5]

median = -1

Output:

[1, -1, -1]

ğŸ“¦ Complexity

Operation Time

add O(log k)

remove O(log k)

median O(1)

Total O(n log k)

Space O(k)

ğŸ§  Ultimate Intuition (Interview Gold)

â€œTwo heaps give median. Lazy deletion makes sliding window removal efficient.â€

ğŸ‘‰ Problem type: Heap + Greedy â€“ IPO Capital Maximization (LeetCode 502)

âœ¨ Flashcard:
â€œUse two heaps:

Min-heap to unlock affordable projects by capital

Max-heap to pick the most profitable project
Repeat up to k projects to maximize capital.â€

âš¡ Full Approach

We need to maximize total capital after completing at most k projects, given initial capital w.

Example:

profits = [1,2,3], capital = [0,1,1], w = 0, k = 2


Only projects you can afford with current capital are available.

Always pick the project with highest profit among unlocked ones.

ğŸ”¥ Key Idea: Two Heaps

1ï¸âƒ£ Capital Min Heap â†’ store all projects by required capital

Quickly unlock projects you can afford

Heap top = project with smallest capital requirement

2ï¸âƒ£ Profit Max Heap â†’ store unlocked projects by profit

Always pick largest profit project

Use negative numbers in Python to simulate max heap

ğŸ§  Steps / Mental Map

1ï¸âƒ£ Push all projects into capital_heap â†’ (required capital, profit)
2ï¸âƒ£ Repeat k times:

Unlock all projects with capital â‰¤ current capital â†’ move to profit_heap

If profit_heap empty â†’ break (no projects affordable)

Pop max profit â†’ add to capital w
3ï¸âƒ£ Return final capital w

ğŸ§± Class Heap Mental Model

capital_heap â†’ min-heap â†’ locked projects
profit_heap â†’ max-heap â†’ unlocked projects ready to pick


Unlock â†’ move from capital_heap â†’ profit_heap

Pick â†’ pop max from profit_heap â†’ update capital

Repeat up to k times

ğŸš€ Code Explanation Line-by-Line

capital_heap = []
for c, p in zip(capital, profits):
    heapq.heappush(capital_heap, (c, p))


Push all projects into min-heap by required capital.

Top of heap = project with smallest capital needed.

profit_heap = []


Max heap (store profits as negative numbers in Python).

Top of heap = project with largest profit among unlocked.

for _ in range(k):


Repeat up to k projects.

while capital_heap and capital_heap[0][0] <= w:
    c, p = heapq.heappop(capital_heap)
    heapq.heappush(profit_heap, -p)


Unlock all projects you can currently afford.

Move them to profit heap.

if not profit_heap:
    break


Stop if no project is affordable â†’ cannot increase capital further.

w += -heapq.heappop(profit_heap)


Pick the most profitable project â†’ add profit to capital w.

return w


Return final maximized capital after k projects.

ğŸ”¥ Example Run

Input:

profits = [1,2,3], capital = [0,1,1], w = 0, k = 2


Step 1: Capital heap = [(0,1),(1,2),(1,3)], Profit heap = []

Step 1 unlock: (0,1) â†’ profit heap = [1] â†’ pick max â†’ w = 1

Step 2 unlock: (1,2),(1,3) â†’ profit heap = [3,2] â†’ pick max â†’ w = 4

Output: 4 âœ…

ğŸ“¦ Complexity

Operation	Time
Build capital heap	O(n)
Each heap push/pop	O(log n)
Total	O(n log n)
Space	O(n)

ğŸ§  One-Line Intuition

â€œUnlock affordable projects â†’ pick the highest profit â†’ increase capital â†’ repeat k times.â€

ğŸ‘‰ Problem type: Backtracking â€“ Power Set Generation (LeetCode 78 Subsets)

âœ¨ Flashcard:
â€œEvery element has two choices:

Include it

Exclude it

Explore both recursively to build all subsets.â€

âš¡ Full Approach

We need to generate all possible subsets of an array of unique elements.

Example:

nums = [1,2,3]

Output:

[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Each element has two decisions:

Include in subset

Do NOT include in subset

This creates a decision tree

Total subsets:

2â¿

ğŸ”¥ Key Idea: Backtracking (Include / Exclude)

At each index i:

Include nums[i]

Exclude nums[i]

Recursively explore both

ğŸ§  Steps / Mental Map

1ï¸âƒ£ Start from index 0 with empty subset

2ï¸âƒ£ For each element:

Include â†’ explore deeper

Backtrack â†’ remove element

Exclude â†’ explore deeper

3ï¸âƒ£ When index reaches end â†’ save subset

ğŸ§± Backtracking Mental Model

Think like a tree:

nums = [1,2]

            []
         /       \
       [1]       []
      /   \     /   \
   [1,2] [1]  [2]  []


Each path = one subset

ğŸš€ Code Explanation Line-by-Line

subsets = []
curSet = []


subsets â†’ stores final answer

curSet â†’ current subset being built

def helper(i):


Recursive function

i â†’ current index in nums

if i == len(nums):
    subsets.append(curSet.copy())
    return


Reached end of array

Save current subset

This is a leaf node in decision tree

curSet.append(nums[i])
helper(i + 1)


Include current element

Move to next index

curSet.pop()


Backtrack

Remove last element

Restore previous state

helper(i + 1)


Exclude current element

Move to next index

helper(0)


Start recursion from index 0

return subsets


Return all subsets

ğŸ”¥ Example Run

Input:

nums = [1,2]

Execution:

Start: []

Include 1 â†’ [1]

Include 2 â†’ [1,2] â†’ save

Exclude 2 â†’ [1] â†’ save

Backtrack

Exclude 1 â†’ []

Include 2 â†’ [2] â†’ save

Exclude 2 â†’ [] â†’ save

Output:

[[],[1],[2],[1,2]] âœ…

ğŸ“¦ Complexity

Operation Time
Total subsets 2â¿
Copy each subset O(n)
Total O(n Ã— 2â¿)
Space O(n)

Recursion depth = n

ğŸš€ Why Backtracking Works Best

Because:

We must explore all combinations

Backtracking avoids extra memory

Efficient and clean

ğŸ§  One-Line Intuition

â€œInclude element â†’ explore â†’ remove â†’ exclude element â†’ explore â†’ repeat until all subsets are built.â€

ğŸ‘‰ Problem type: Backtracking + Sorting â€“ Subsets with Duplicates (LeetCode 90)

âœ¨ Flashcard:
â€œSort first.

Include element normally.

When excluding â†’ skip all duplicates.

This prevents duplicate subsets.â€

âš¡ Full Approach

We need to generate all subsets, but input may contain duplicate numbers.

Example:

nums = [1,2,2]

Output:

[[],[1],[1,2],[1,2,2],[2],[2,2]]

NOT allowed:

[2] appearing twice âŒ

ğŸ”¥ Key Idea: Sort + Skip Duplicates

Why sort?

To bring duplicates together:

[2,1,2] â†’ sort â†’ [1,2,2]

Now easy to detect duplicates

ğŸ§  Steps / Mental Map

1ï¸âƒ£ Sort nums

2ï¸âƒ£ At each index:

Include element â†’ normal recursion

Exclude element â†’ skip all duplicates

3ï¸âƒ£ Save subset at leaf

ğŸ§± Backtracking Mental Model

Decision Tree:

nums = [1,2,2]

              []
          /         \
        [1]         []
      /    \      /    \
   [1,2]  [1]  [2]    []
    /           /
[1,2,2]      [2,2]


Duplicates automatically avoided

ğŸš€ Code Explanation Line-by-Line

nums.sort()


Sort to group duplicates

subsets = []
curSet = []


Result storage and working subset

def helper(i):


Recursive function

if i == len(nums):
    subsets.append(curSet[:])
    return


Save subset

curSet.append(nums[i])
helper(i + 1)
curSet.pop()


Include current element

Explore

Backtrack

while i + 1 < len(nums) and nums[i] == nums[i + 1]:
    i += 1


Skip duplicates

Critical step

helper(i + 1)


Exclude element

helper(0)


Start recursion

return subsets


Return result

ğŸ”¥ Example Run

Input:

[1,2,2]

Output:

[[],[1],[1,2],[1,2,2],[2],[2,2]] âœ…

ğŸ“¦ Complexity

Operation Time
Total subsets 2â¿
Total O(n Ã— 2â¿)
Space O(n)

ğŸ§  One-Line Intuition

â€œSort â†’ include element â†’ backtrack â†’ skip duplicates â†’ exclude â†’ repeat.â€

ğŸ‘‰ Backtracking â€“ Generate Combinations (LeetCode 77)

Efficiently generate all combinations of size k from numbers 1 to n using recursion and incremental building.

Perfect when:

You need fixed-size combinations

Order doesnâ€™t matter

You must avoid duplicates like [2,1]

Classic nCk problem

âœ¨ Flashcard

â€œBuild combination step-by-step.
Pick next number only from forward.
Stop when size = k.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal:

Generate all combinations of k numbers from 1 to n.

Example:

Input:

n = 4, k = 2

Output:

[1,2]
[1,3]
[1,4]
[2,3]
[2,4]
[3,4]

ğŸ” Core Idea:

We build combinations gradually.

Each step:

Pick next number

Move forward only

Never go backward â†’ avoids duplicates

ğŸ§  Mental Map:

Start []

Pick 1 â†’ [1]
    Pick 2 â†’ [1,2] âœ…
    Pick 3 â†’ [1,3] âœ…
    Pick 4 â†’ [1,4] âœ…

Pick 2 â†’ [2]
    Pick 3 â†’ [2,3] âœ…
    Pick 4 â†’ [2,4] âœ…

Pick 3 â†’ [3]
    Pick 4 â†’ [3,4] âœ…

2ï¸âƒ£ Core Variables
res â†’ final result

path â†’ current combination

start â†’ next number to try


ğŸ§  Mental Map:

res â†’ storage box

path â†’ combination under construction

start â†’ prevents duplicate combinations

3ï¸âƒ£ Base Case

Code:

if len(path) == k:
    res.append(path.copy())
    return


ğŸ¯ Goal:

Combination complete

Save it

ğŸ§  Mental Map:

â€œCombination ready â†’ save itâ€

4ï¸âƒ£ Pick Decision (FOR LOOP)

Code:

for i in range(start, n+1):


ğŸ¯ Goal:

Try every possible next number

Example:

If start = 2

Try:

2, 3, 4

NOT 1

Prevents duplicates

ğŸ§  Mental Map:

â€œOnly move forwardâ€

5ï¸âƒ£ Backtracking Step

Code:

path.append(i)
backtrack(i+1, path)
path.pop()


ğŸ¯ Goal:

Choose number

Explore

Undo choice

ğŸ§  Mental Map:

â€œChoose â†’ Explore â†’ Undoâ€


7ï¸âƒ£ Full Flow Example

Input:

n = 4, k = 2

Execution:

Start []

Pick 1 â†’ [1]

Pick 2 â†’ [1,2] âœ…

Pick 3 â†’ [1,3] âœ…

Pick 4 â†’ [1,4] âœ…

Pick 2 â†’ [2]

Pick 3 â†’ [2,3] âœ…

Pick 4 â†’ [2,4] âœ…

Pick 3 â†’ [3]

Pick 4 â†’ [3,4] âœ…

ğŸ“¦ Complexity

Time:

O(k Ã— C(n,k))

Space:

O(k)

ğŸš€ Why This Works Best

Because:

No duplicate combinations

Efficient pruning

Clean logic

Most used interview template

ğŸ§  One-Line Intuition

â€œPick next number forward and stop when combination size reaches k.â€


ğŸ‘‰ Backtracking â€“ Phone Letter Combinations (LeetCode 17)

Efficiently generate all possible letter combinations from phone digits using recursion and incremental building.

Perfect when:

You need all possible combinations from multiple groups

Each position has multiple choices

Combination length is fixed

Classic keypad backtracking problem

âœ¨ Flashcard

â€œPick a letter for current digit.
Move to next digit.
Stop when all digits are used.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal:

Generate all letter combinations from given phone digits.

Example:

Input:

digits = "23"


Output:

ad
ae
af
bd
be
bf
cd
ce
cf


ğŸ” Core Idea:

Each digit gives multiple letters.

We build combinations step-by-step.

Digit by digit.

ğŸ§  Mental Map:

Start ""

Digit 2 â†’ a,b,c

Pick a â†’ "a"
â€ƒDigit 3 â†’ d,e,f
â€ƒPick d â†’ "ad" âœ…
â€ƒPick e â†’ "ae" âœ…
â€ƒPick f â†’ "af" âœ…

Pick b â†’ "b"
â€ƒPick d â†’ "bd" âœ…
â€ƒPick e â†’ "be" âœ…
â€ƒPick f â†’ "bf" âœ…

Pick c â†’ "c"
â€ƒPick d â†’ "cd" âœ…
â€ƒPick e â†’ "ce" âœ…
â€ƒPick f â†’ "cf" âœ…

2ï¸âƒ£ Core Variables

res â†’ final result

path â†’ current letter combination

index â†’ current digit position

phone â†’ digit â†’ letters mapping

ğŸ§  Mental Map:

res â†’ storage box

path â†’ word under construction

index â†’ which digit we are processing

phone â†’ choice provider

3ï¸âƒ£ Base Case

Code:

if index == len(digits):
    res.append(path)
    return


ğŸ¯ Goal:

All digits processed

Combination complete

Save it

ğŸ§  Mental Map:

â€œWord ready â†’ save itâ€

Example:

digits="23"

path="ad"

Save

4ï¸âƒ£ Pick Decision (FOR LOOP)

Code:

letters = phone[digits[index]]

for ch in letters:


ğŸ¯ Goal:

Try every letter for current digit

Example:

Digit = "2"

Letters:

a
b
c


ğŸ§  Mental Map:

â€œTry every possible letterâ€

5ï¸âƒ£ Move Forward Step

Code:

backtrack(index + 1, path + ch)


ğŸ¯ Goal:

Choose letter

Move to next digit

ğŸ§  Mental Map:

â€œChoose â†’ Move forwardâ€

Example:

"" + a â†’ "a"
"a" + d â†’ "ad"

6ï¸âƒ£ Why No pop() Here?

Because:

path + ch


creates NEW string

Strings are immutable

No need to undo

ğŸ§  Mental Map:

Each path is independent

7ï¸âƒ£ Full Flow Example

Input:

digits="23"


Execution:

Start ""

Pick a â†’ "a"

Pick d â†’ "ad" âœ…

Pick e â†’ "ae" âœ…

Pick f â†’ "af" âœ…

Pick b â†’ "b"

Pick d â†’ "bd" âœ…

Pick e â†’ "be" âœ…

Pick f â†’ "bf" âœ…

Pick c â†’ "c"

Pick d â†’ "cd" âœ…

Pick e â†’ "ce" âœ…

Pick f â†’ "cf" âœ…

ğŸ“¦ Complexity

Time:

O(4^n)


Because each digit has max 4 letters

Space:

O(n)


Recursion depth

ğŸš€ Why This Works Best

Because:

Explores all combinations

No duplicates

Clean recursion

Standard interview pattern

ğŸ§  One-Line Intuition

â€œPick one letter per digit and move forward until word is complete.â€



ğŸ‘‰ Backtracking â€“ Permutations Using Swap (LeetCode 46)

Efficiently generate all possible permutations by fixing one position at a time and swapping choices into place.

Perfect when:

You need all arrangements of elements

Order matters

Each position must use exactly one element

Classic permutation backtracking problem

âœ¨ Flashcard

Front:
â€œHow do I generate all permutations of an array?â€

Back:

Fix a position

Swap each available number into that position

Recurse to fix the next position

Swap back (undo) to restore the array

Stop when all positions are fixed â†’ save

âš¡ Step-by-Step Combined Explanation

1ï¸âƒ£ Initialize Result Container
res = []


Stores all generated permutations.

Example:

res = []

2ï¸âƒ£ Define Backtracking Function
def backtrack(start):
    if start == len(nums):
        res.append(nums[:])
        return


start â†’ index of the position being fixed.

Base case â†’ all positions fixed â†’ save a copy of nums.

Mental Map:

[ _, _, _ ]
  â†‘ start

3ï¸âƒ£ Loop Through Remaining Numbers
for i in range(start, len(nums)):


Try every number for the current position.

Example:

nums = [1,2,3], start = 0
i = 0 â†’ 1
i = 1 â†’ 2
i = 2 â†’ 3

4ï¸âƒ£ Swap (Choose)
nums[start], nums[i] = nums[i], nums[start]


Swap the number at index i into the current position.

Example before swap: [1,2,3], start = 0, i = 2

After swap: [3,2,1]

Mental Map:

â€œPut new number in the current slotâ€

5ï¸âƒ£ Recurse (Explore)
backtrack(start + 1)


Move to next position and repeat process.

Mental Map:

[3,2,1]
   â†‘ start=1

6ï¸âƒ£ Swap Back (Undo)
nums[start], nums[i] = nums[i], nums[start]


Restore array to original state before trying the next number.

Critical step â€“ without this, permutations get corrupted.

Example:

Before undo: [3,2,1]
After undo: [1,2,3]

7ï¸âƒ£ Start Recursion
backtrack(0)
return res


Start fixing positions from index 0

Return the list of all permutations

ğŸ§  Step-by-Step Mental Animation

Input: [1,2,3]

Fix index 0: try 1,2,3

swap(0,0) â†’ [1,2,3]
swap(0,1) â†’ [2,1,3]
swap(0,2) â†’ [3,2,1]


Fix next index: repeat for index 1

Example branch:

[2,1,3]
Fix index 1 â†’ try remaining numbers
   [2,1,3]
   [2,3,1]


Fix last index â†’ base case â†’ save permutation

ğŸŒ³ Recursion Tree Visualization
                 [1,2,3]
            /       |       \
       [1,_,_]  [2,_,_]  [3,_,_]
        /   \      /  \     /   \
   [1,2,3][1,3,2] [2,1,3][2,3,1] [3,1,2][3,2,1]


Each level fixes one position.

Leaves â†’ complete permutations.

âœ… Example Walkthrough

Input: [1,2,3]

Fix index 0 â†’ pick 1 â†’ [1,_,_]

Fix index 1 â†’ pick 2 â†’ [1,2,_]

Fix index 2 â†’ pick 3 â†’ [1,2,3] â†’ save

Backtrack â†’ swap back â†’ pick next at index 2 â†’ [1,3,2] â†’ save

Backtrack â†’ next choice at index 0 â†’ [2,1,3] â†’ repeat

Final Result:

[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

ğŸ”‘ Interview Tips

Always swap back after recursion

Use nums[:] or .copy() when saving path

Complexity:

Time: O(n Ã— n!)

Space: O(n) recursion stack

ğŸ§  One-Line Intuition

â€œFix a position. Try every number. Undo. Repeat until all positions are fixed.â€



ğŸ‘‰ Backtracking â€“ Unique Permutations Using Used Array (LeetCode 47)

Efficiently generate all unique permutations from an array that may contain duplicates.

Perfect when:

You need all arrangements of elements

Order matters

Some elements may repeat

You must avoid duplicate permutations

Classic permutation + backtracking problem

âœ¨ Flashcard

Front:
â€œHow do I generate all unique permutations of an array with duplicates?â€

Back:

Sort the array to group duplicates

Track used elements with a used[] array

Pick each unused element

Skip duplicates if the previous identical element wasnâ€™t used

Recurse to build the next position

Undo choice (pop + mark unused)

Stop when all positions are filled â†’ save

âš¡ Step-by-Step Combined Explanation

1ï¸âƒ£ Initialize Result Container
res = []


Stores all unique permutations.

Example:

res = []

2ï¸âƒ£ Sort Input & Setup Used Array
nums.sort()          # sort to make duplicates adjacent
used = [False] * len(nums)


Sorting ensures duplicates are next to each other â†’ easy to skip.

used[i] tracks if nums[i] is already in the current path.

Example:

nums = [1,1,2]
used = [False, False, False]

3ï¸âƒ£ Define Backtracking Function
def backtrack(path):
    if len(path) == len(nums):
        res.append(path[:])
        return


path â†’ current permutation being built.

Base case â†’ all positions filled â†’ save a copy.

Mental Map:

[ _, _, _ ]
  â†‘ path length

4ï¸âƒ£ Loop Through All Numbers
for i in range(len(nums)):


Try every number in nums for the current position.

Skip already used numbers:

if used[i]:
    continue


Skip duplicates only if previous duplicate wasnâ€™t used:

if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
    continue


Example:

nums = [1,1,2]
used = [True, False, False]
i = 1 â†’ skip (duplicate not used)

5ï¸âƒ£ Choose the Number
used[i] = True
path.append(nums[i])


Mark as used and add to path.

Example:

path = [1]
used = [True, False, False]


Mental Map:

â€œPick a number and move forwardâ€

6ï¸âƒ£ Recurse
backtrack(path)


Move to the next position and continue building permutation.

Mental Map:

[1]
  â†‘ next pick

7ï¸âƒ£ Undo Choice (Backtrack)
path.pop()
used[i] = False


Remove last number and mark as unused to try the next possibility.

Example:

path = []
used = [False, False, False]


Mental Map:

â€œReset before trying next numberâ€

8ï¸âƒ£ Start Recursion
backtrack([])
return res


Start building permutation with an empty path.

Return all unique permutations at the end.

ğŸ§  Step-by-Step Dry Run â€“ nums = [1,1,2]

Initial Setup:

nums = [1,1,2], used = [False, False, False], path = [], res = []

Step 1: Pick first 1 (i=0)
path = [1], used = [True, False, False]


Recurse:

Step 2: Pick second 1 (i=1)
path = [1,1], used = [True, True, False]


Recurse:

Step 3: Pick 2 (i=2)
path = [1,1,2], used = [True, True, True]
Base case â†’ save â†’ res = [[1,1,2]]


Backtrack â†’ remove 2 â†’ path = [1,1], used = [True, True, False]

Step 4: Backtrack second 1

Pop â†’ path = [1], used = [True, False, False]

i=2 â†’ pick 2 â†’ path = [1,2], used = [True, False, True]

Recurse â†’ i=1 â†’ pick second 1 â†’ path = [1,2,1], used = [True, True, True]

Save â†’ res = [[1,1,2],[1,2,1]]

Step 5: Backtrack first 1

Pop â†’ path = [], used = [False, False, False]

i=1 â†’ skip (duplicate 1 not used)

i=2 â†’ pick 2 â†’ path = [2], used = [False, False, True]

Recurse â†’ pick 1 (i=0) â†’ path = [2,1], used = [True, False, True]

Pick 1 (i=1) â†’ path = [2,1,1], used = [True, True, True]

Save â†’ res = [[1,1,2],[1,2,1],[2,1,1]]

ğŸŒ³ Recursion Tree Visualization
[]
â”œâ”€ 1
â”‚   â”œâ”€ 1
â”‚   â”‚   â””â”€ 2 â†’ [1,1,2]
â”‚   â””â”€ 2
â”‚       â””â”€ 1 â†’ [1,2,1]
â”œâ”€ 1 â†’ skipped
â””â”€ 2
    â”œâ”€ 1
    â”‚   â””â”€ 1 â†’ [2,1,1]
    â””â”€ 1 â†’ skipped

âœ… Final Result
[[1,1,2],[1,2,1],[2,1,1]]

ğŸ”‘ Interview Tips

Always sort array first to handle duplicates

Use used[] array to track picked numbers

Skip duplicates if previous duplicate is not used

Always pop path + mark unused for backtracking

Complexity:

Time: O(n! Ã— n)

Space: O(n) recursion stack + O(n) used[]

ğŸ§  One-Line Intuition

â€œPick unused numbers one by one, skip duplicates, build path recursively, undo choice, repeat until all positions filled â†’ save path.â€