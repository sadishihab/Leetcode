ğŸ‘‰ Problem: Maximum Subarray (Kadaneâ€™s Algorithm) (leetcode 53)

You must find the contiguous subarray that gives the maximum total sum.

âœ… Key Idea

"If your running sum becomes negative, throw it away and start fresh."

âœ¨ Flashcard

Kadane = keep adding; if sum < 0 â†’ reset; track max.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with two trackers

maxSum â† first element of the array
(This ensures answer always includes at least one number)

curSum â† 0
(Your temporary running sum)

Step 2 â€” Begin scanning the array from left to right

For each number in the array:

Step 3 â€” If the running sum became negative

Drop it.

Restart the subarray from the next number.

Why?
A negative running sum will only pull future sums down.

So mentally say:
â€œcurSum < 0? Reset to 0.â€

Step 4 â€” Add the current number to your running total

Extend the current subarray by including this number.

curSum grows as long as you are gaining value.

Step 5 â€” Update the global best

After adding each number:

Compare curSum with maxSum

If curSum is higher â†’ update maxSum

This ensures you always keep track of the best subarray seen so far.

Step 6 â€” Finish

After scanning all numbers:

The value in maxSum is the maximum subarray sum.

ğŸ§  Mental Map (Very Simple)

Imagine walking through numbers with a backpack:

Add each number to your backpack.

If the items in the backpack make the total weight negative,
empty the backpack and start collecting freshly.

Always remember the heaviest backpack value seen.

â±ï¸ Complexity

Time: O(n) â†’ one pass

Space: O(1) â†’ only two variables

You can also write:
ğŸ“Œ For the sliding window version
ğŸ“Œ For the divide & conquer solution
ğŸ“Œ For returning indices or subarray

ğŸ‘‰ Problem: Maximum Sum Circular Subarray (LeetCode 918)

You must find the maximum subarray sum, but the array is circular â€” meaning the end wraps around to the start.

âœ… Key Idea

There are two possible types of max subarrays:

1ï¸âƒ£ Normal (Non-Circular) Subarray

Example:
[1, -2, 3, -2] â†’ best is [3] â†’ sum = 3
Just run Kadaneâ€™s algorithm.

2ï¸âƒ£ Circular Subarray

The subarray â€œwraps aroundâ€ the end â†’ start.

Example:
[5, -3, 5] best circular = [5, ?, 5] = 10 â†’ sum = 10

How to find this?

ğŸ‘‰ Circular max sum = total sum âˆ’ minimum subarray sum

Because:

Removing the minimum middle part gives the maximum wrapping part.

âœ¨ Flashcard

"Max = max(normalKadane, total âˆ’ minKadane). But if all numbers are negative â†’ return max normal only."

âœ… How It Works

Use Kadaneâ€™s algorithm to find the maximum subarray sum in the normal (non-circular) array.

Use a modified Kadaneâ€™s algorithm to find the minimum subarray sum.

Compute total_sum of the array.

Maximum circular subarray sum can be calculated as total_sum - min_subarray.

Handle edge case: if all numbers are negative, the normal max subarray sum is the answer.

Return the larger of max_normal and max_circular.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the normal maximum subarray sum

Use standard Kadane:

Keep adding numbers.

When sum < 0 â†’ reset to 0.

Track the largest sum seen.

This gives:

max_normal


This solves the non-wrapping case.

Step 2 â€” Compute the minimum subarray sum

Do Kadane again, but inverted:

Keep adding numbers.

When sum > 0 â†’ reset to 0.

Track the smallest (most negative) sum seen.

This gives:

min_subarray


This helps us compute the maximum circular sum.

Step 3 â€” Compute total sum of all elements
total_sum = sum(nums)


This is needed for wrapping logic.

Step 4 â€” Compute circular subarray sum
max_circular = total_sum âˆ’ min_subarray


This essentially removes the worst (minimum) middle part to form a wrapping subarray.

Step 5 â€” Edge Case: All numbers are negative

If all numbers are negative:

The minimum subarray = total sum

So: total_sum â€“ min_subarray = 0 (invalid empty subarray)

So in this case:
âœ” Return only max_normal

Because circular sum is not allowed to be empty.

Step 6 â€” Final Answer
answer = max(max_normal, max_circular)

ğŸ§  Mental Map (Super Simple)

Think of the array having two choices:

1ï¸âƒ£ Best is inside the array normally.

Just Kadane.

2ï¸âƒ£ Best is across the ends.

Take the whole array â†’ remove the worst part â†’ that creates a wrap.

Compare both â†’ pick larger.
â±ï¸ Complexity

Time: O(n)

Space: O(1)

ğŸ” Short Examples
Example 1: [1, -2, 3, -2]

max_normal = 3

min_subarray = -2

total = 0

max_circular = 0 âˆ’ (-2) = 2 â†’ but 3 is bigger

Answer = 3

Example 2: [5, -3, 5]

max_normal = 7

min_subarray = -3

total = 7

max_circular = 7 âˆ’ (-3) = 10

Answer = 10

Example 3: [-3, -2, -3]

All negative â†’ must return largest (least negative)

Answer = -2

ğŸ‘‰ Problem: Longest Turbulent Subarray (LeetCode 978)

You are given an integer array arr.
A turbulent subarray is one where the comparison signs alternate between adjacent elements:

Either: > < > < â€¦

Or: < > < > â€¦

Return the length of the longest turbulent subarray.

âœ… Key Idea

Use a sliding window / two counters approach:

Track two lengths while scanning:

up â†’ current subarray ends with <

down â†’ current subarray ends with >

Whenever the sign flips, extend the subarray.

Reset when adjacent numbers are equal.

âœ¨ Flashcard:
"Compare neighbors. If sign flips â†’ extend subarray. Equal â†’ reset."

âœ… How It Works

If the array has only one element, return 1.

Use two counters, up and down, to track lengths of turbulent subarrays ending at the current element:

up â†’ last comparison was >

down â†’ last comparison was <

Iterate through the array starting from index 1:

If arr[i] > arr[i - 1], set up = down + 1 and reset down = 1.

If arr[i] < arr[i - 1], set down = up + 1 and reset up = 1.

If equal, reset both up and down to 1.

At each step, update max_len with the largest of max_len, up, and down.

Continue until the end of the array.

Return max_len â†’ length of the longest turbulent subarray.

âš¡ Full Approach (Step-by-Step)
Step 1 â€” Handle edge case

If the array has only one element â†’ return 1.

Step 2 â€” Initialize

max_len = 1 (at least one element counts)

up = 1, down = 1 (lengths of turbulent subarrays ending in < or >)

Step 3 â€” Loop through array

For each index i from 1 to n-1:

Compare arr[i] with arr[i-1]

If arr[i] > arr[i-1]:

up = down + 1 (flip happened)

down = 1 (reset opposite direction)

Else if arr[i] < arr[i-1]:

down = up + 1

up = 1

Else:

Equal â†’ reset both: up = down = 1

Update max_len = max(max_len, up, down)

Step 4 â€” Return

max_len after scanning the array.

â±ï¸ Complexity

Time: O(n) â†’ single pass

Space: O(1) â†’ only 3 variables

ğŸ“ Example Dry Run
Example 1: [9,4,2,10,7,8,8,1,9]

Compare 9>4 â†’ down=2, up=1 â†’ max_len=2

Compare 4>2 â†’ down=2, up=1 â†’ max_len=2

Compare 2<10 â†’ up=down+1=3, down=1 â†’ max_len=3

Compare 10>7 â†’ down=up+1=4, up=1 â†’ max_len=4

Compare 7<8 â†’ up=down+1=5, down=1 â†’ max_len=5

Compare 8=8 â†’ reset â†’ up=down=1

Compare 8>1 â†’ down=up+1=2, up=1

Compare 1<9 â†’ up=down+1=3, down=1

Final max_len = 5



ğŸ‘‰ Problem: Contains Duplicate II (Leet code 219)

You must determine whether any number appears twice within a distance of k from each other.

âœ… Key Idea

â€œKeep a sliding window of size at most k.
If a number reappears inside that window â†’ duplicate found.â€

You donâ€™t need to search the entire array â€” only look k steps back.

âœ¨ Flashcard

Nearby duplicate =
â€œUse a sliding window set.
If window grows > k â†’ remove leftmost.
If current number already in set â†’ True.â€

âœ… How It Works

Use a sliding window of size at most k with pointers L (left) and R (right).

Maintain a set window to store elements currently in the window.

For each R, check if the window size exceeds k:

If yes, remove nums[L] from the window and increment L.

If nums[R] is already in the window â†’ a nearby duplicate is found, return True.

Otherwise, add nums[R] to the window.

Continue until the end of the array.

If no nearby duplicates are found, return False.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a sliding window

Use a set to store the last few elements youâ€™ve seen.

Call it:
window â† empty set

Also keep a pointer:
left â† 0
(This marks the start of the sliding window)

Step 2 â€” Walk through the array using right pointer

For each index right, you check the current number nums[right].

Step 3 â€” Ensure the window never becomes larger than k

If the distance (right - left) becomes bigger than k,
you must remove nums[left] from the window â†’ slide forward.

Why?
Because any element more than k steps away is no longer allowed.

So think:
â€œWindow too big? Kick out the leftmost.â€

Then increase left.

Step 4 â€” Check for a duplicate inside the window

Before inserting the current number:

If nums[right] is already inside the window â†’
you found a value that appears again within â‰¤ k distance.

Return True immediately.

This is the core condition.

Step 5 â€” Add the current number to the window

After ensuring the window is valid and checking for duplicates,
insert the current number.

Step 6 â€” If loop finishes with no match

Return False.

This means no number repeated within k distance.

ğŸ§  Mental Map (Very Simple)

Imagine a sliding glass window that can only show k elements at a time.

You move the window from left to right.

If a number is seen again inside the window â†’ duplicate found.

If the window gets too wide â†’ push out the leftmost number.

â±ï¸ Complexity

Time: O(n)
(You visit each number once)

Space: O(k)
(Window holds at most k items)



ğŸ‘‰ Problem: Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Leetcode 1343)

Count Subarrays With Average â‰¥ Threshold

You are given:

arr â†’ an array of numbers

k â†’ size of subarray

threshold â†’ required minimum average

You must count:

How many subarrays of size k
have average â‰¥ threshold?

âœ¨ Key Idea

Instead of checking averages, we compare sum:

A subarray's average â‰¥ threshold
â‡” its sum â‰¥ threshold * k

Why?

average = sum / k
sum / k â‰¥ threshold  â†’  sum â‰¥ threshold * k


So we only need the sum, not the average.

âœ¨ Flashcard (Short Memory Trick)

Count subarrays avg â‰¥ threshold =
â€œUse sliding window sum.
Target = threshold Ã— k.
Build first window.
Slide: add right, remove left.
If sum â‰¥ target â†’ count.â€

âœ… How It Works

Compute target_sum = threshold * k â†’ the minimum sum a subarray of size k needs.

Initialize window_sum with the sum of the first k elements.

Initialize count to 1 if the first window meets the threshold, otherwise 0.

Slide the window across the array:

Add the new element entering the window and remove the element leaving the window.

If window_sum >= target_sum, increment count.

Continue until the end of the array.

Return count â†’ number of subarrays of size k with average â‰¥ threshold.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Compute the target sum

You need each windowâ€™s sum to be at least:

threshold * k


This avoids doing division and makes comparisons faster.

Step 2 â€” Start by summing the first window of size k

Take the first k elements and compute their sum.

If this sum â‰¥ target sum â†’ count it.

Step 3 â€” Slide the window across the array (1 step at a time)

When sliding from one window to the next:

Add the new element on the right

Remove the element that is leaving from the left

This keeps the window always of size k.

This takes O(1) per step.

Step 4 â€” After each slide, compare the window sum

If window_sum â‰¥ target_sum â†’ increase answer.

Step 5 â€” Continue until the end of the array

Return how many windows qualified.

ğŸ§  Mental Picture

Imagine a window that covers exactly k numbers.

You slide this window across the array from left to right.

At each position:

Check if the total inside the window is â€œheavy enoughâ€

If yes â†’ count it

This is classical sliding window.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one pass through the array.



ğŸ‘‰ Problem: Minimum Size Subarray Sum (Leetcode 209)
Find the shortest subarray whose sum â‰¥ target.
You are given:


nums â†’ array of positive integers


target â†’ required minimum sum


You must return:


The minimal length of a subarray whose sum â‰¥ target


Return 0 if no such subarray exists



âœ¨ Key Idea
This is a classic sliding window problem.
Because all numbers are positive,
â†’ expanding the right pointer always increases the sum
â†’ shrinking the left pointer always decreases the sum
So two-pointer sliding window works perfectly.

âœ¨ Flashcard

Minimum Size Subarray Sum =
â€œUse sliding window (positive nums).
Grow R until sum â‰¥ target.
Shrink L to minimize window.
Track shortest valid size.
If never valid â†’ return 0.â€

âœ… How It Works

Use a sliding window with L as the left pointer and R as the right pointer.

Maintain total as the sum of elements in the current window.

For each R, add nums[R] to total to expand the window.

While total >= target, the current window is valid:

Update min_length with the size of the window (R - L + 1).

Shrink the window from the left by subtracting nums[L] and incrementing L.

Continue until the end of the array.

If no valid window is found, return 0; otherwise, return min_length.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers


L â†’ start of the window


R â†’ end of the window


total â†’ sum inside the window


min_length â†’ initialized to âˆ



Step 2 â€” Expand the window by moving R
For each new element:
total += nums[R]

Keep adding numbers until total â‰¥ target.

Step 3 â€” When the window meets the requirement
Whenever:
total â‰¥ target

We found a valid subarray.
Now we try to shrink it from the left to make it as small as possible.
Update the answer:
min_length = min(min_length, R - L + 1)


Step 4 â€” Shrink from the left
Remove nums[L] from the window:
total -= nums[L]
L += 1

Continue shrinking while the sum still â‰¥ target.
This finds the shortest valid window for this R.

Step 5 â€” Continue until R reaches the end
If no valid window was ever found â†’ return 0.

ğŸ§  Mental Picture
Imagine a window sliding across the array.


It grows until it is heavy enough (sum â‰¥ target)


Then it shrinks to find the smallest valid size


Then it grows again


This ensures we find the minimum valid window.

â±ï¸ Complexity
OperationCostTimeO(n)SpaceO(1)
Each pointer moves at most n steps â†’ linear time.

âœ”ï¸ Examples Explained
Example 1
target = 7
nums = [2,3,1,2,4,3]
Valid windows with sum â‰¥ 7 include:


[2,3,1,2] â†’ length 4


[3,1,2,4] â†’ length 4


[4,3] â†’ length 2 (smallest)


Answer: 2

Example 2
target = 4
nums = [1,4,4]
The subarrays:


[4] â†’ length 1


[4] â†’ length 1


Answer: 1

Example 3
target = 11
nums = [1,1,1,1,1,1,1,1]
All sums are â‰¤ 8 â†’ no subarray can reach 11.
Answer: 0


ğŸ‘‰ Problem: Longest Substring Without Repeating Characters (leetcode 03)

Find the length of the longest substring (continuous sequence)
with no repeating characters.

You are given:

s â†’ a string

Return:

The maximum length of any substring where all characters are unique

âœ¨ Key Idea

Use a sliding window with:

L â†’ left pointer

R â†’ right pointer

a set to store characters currently inside the window

We expand the window with R, and if a duplicate appears,
we shrink from the left until the window becomes valid again.

âœ¨ Flashcard

Longest substring without repeating chars =
â€œUse sliding window set.
If char not in set â†’ add & update max.
If duplicate â†’ shrink L removing chars until gone.
Window always stays unique.â€

ChatGPT said:

âœ… How It Works

Use a sliding window with L as the left pointer and R as the right pointer.

Maintain a set window to store characters in the current window.

For each R, check if s[R] is already in the window:

If yes, remove characters from the left (L) until the duplicate is gone.

Add s[R] to the window.

Update max_length with the size of the current window (R - L + 1).

Continue until the end of the string.

Return max_length â†’ the length of the longest substring without repeating characters.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L starts at 0

R loops over every character

A set window stores the characters currently inside the window

Step 2 â€” Expand the window by adding s[R]

If s[R] is not in the set:

Add it

Update max length

If s[R] is in the set â†’ we have a duplicate.

Step 3 â€” Shrink from the left when duplicate found

While s[R] is already in the window:

Remove s[L] from the set

Move L to the right

Repeat until duplicate disappears

Now the window is valid again.

Step 4 â€” Track the maximum window size

At each step:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue until R reaches the end

Return the maximum.

ğŸ§  Mental Picture

Imagine a window sliding across the string:

Expand as long as all characters are unique

When you hit a duplicate â†’ shrink from the left

Keep only the valid "unique character substring" inside the window

Track the largest window ever formed

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(min(n, charset))

Since each pointer moves at most n times.


âœ”ï¸ Example Outputs
Example 1

s = "abcabcbb"
Longest: "abc" â†’ length 3

Example 2

s = "bbbbb"
Longest: "b" â†’ length 1

Example 3

s = "pwwkew"
Longest: "wke" â†’ length 3

If you want, you can also do it by:

ğŸ“Œ A version using a dictionary instead of a set (faster)

ğŸ‘‰ Problem: Longest Repeating Character Replacement (leetcode 424)

You are given:

s â†’ a string of uppercase letters

k â†’ maximum number of character replacements allowed

You may:

Change any character to any other uppercase letter

Perform this operation at most k times

Return:

The length of the longest substring that can be made of the same character, after using at most k replacements.

âœ¨ Key Idea

We want a substring where:

Most characters are the same

And we can fix the rest (up to k characters) by replacing them

Inside any window:

replacements needed = window_size - count_of_most_frequent_char_in_window


For the window to be valid:

window_size - max_freq â‰¤ k


This tells us whether the window can be turned into all identical letters.

âœ¨ Flashcard

Longest Repeating Character Replacement =
â€œUse sliding window freq map.
Track max_freq inside window.
Window valid if size âˆ’ max_freq â‰¤ k.
If invalid â†’ shrink L.
Track largest valid window.â€

ğŸ§  Mental Picture

Imagine a window sliding across the string.

At each step:

Count how many characters already match

Calculate how many characters need replacing

If replacements needed â‰¤ k â†’ good window

If too many replacements â†’ shrink from left

Keep the largest valid window

âœ… How It Works

Use a sliding window with pointers L (left) and R (right).

Maintain a frequency map count of characters inside the window.

Track max_freq, the count of the most frequent character in the current window.

For each R, add s[R] to the frequency map and update max_freq.

If the window size minus max_freq exceeds k, shrink the window from the left (L) and update counts.

At each step, update max_length with the size of the valid window (R - L + 1).

Continue until the end of the string.

Return max_length â†’ the length of the longest substring after at most k replacements.

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Sliding window with L and R

Expand the window by moving R

Keep frequency counts of letters in the window

Track max_freq = the highest frequency of any character in the current window

Step 2 â€” Check if the window is valid

A window is valid if:

(R - L + 1) - max_freq â‰¤ k


Meaning:

Total characters

Minus the number of already-matching characters

Must be â‰¤ k replacements allowed

If valid â†’ we can expand further.

Step 3 â€” If window becomes invalid

Shrink from the left:

reduce count of s[L]
L += 1


We donâ€™t need to reduce max_freq strictly, because:

Letting it stay slightly outdated does not break correctness

The window size only grows to valid sizes

This is a well-known trick that keeps the code O(n).

Step 4 â€” Track maximum window size

Whenever the window is valid:

max_length = max(max_length, R - L + 1)

Step 5 â€” Continue to end of string

Return the largest valid window found.



â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

26 uppercase letters â†’ constant extra space.

âœ”ï¸ Example Results
Example 1

s = "ABAB", k = 2
We can make all letters 'A' or 'B'.

Max length = 4

Example 2

s = "AABABBA", k = 1
Best substring â†’ "BBBB" after one change.

Max length = 4


ğŸ‘‰ Problem: Valid Palindrome (LeetCode 125)

You are given:

s â†’ a string consisting of printable ASCII characters (letters, digits, punctuation, spaces)

You may:

Convert uppercase letters to lowercase

Remove all non-alphanumeric characters

Return:

true if the resulting string reads the same forward and backward, otherwise false.

âœ¨ Key Idea

We want to check if a string is a palindrome ignoring cases and non-alphanumeric characters.

Use two pointers:

L starts at the beginning

R starts at the end

At each step:

Skip non-alphanumeric characters

Compare characters in lowercase

If mismatch â†’ return false

If pointers meet â†’ return true

âœ¨ Flashcard

Valid Palindrome =
â€œUse two pointers. Skip non-alphanumeric. Compare lowercase. If all match â†’ palindrome.â€

ğŸ§  Mental Picture

Imagine a window sliding inwards from both ends:

Ignore spaces, punctuation, etc.

Compare letters and digits

Shrink inward until pointers meet

If all comparisons pass â†’ palindrome

âœ… How It Works

Initialize two pointers, L at the start and R at the end of the string.

Move L forward and R backward, skipping non-alphanumeric characters.

At each step, compare the lowercase versions of s[L] and s[R].

If a mismatch is found, return False â†’ not a palindrome.

Otherwise, move both pointers inward and continue.

If pointers meet without mismatches, return True â†’ the string is a palindrome.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers
L = 0, R = len(s) - 1

Step 2 â€” Skip invalid characters
While L < R:

Move L forward if s[L] is not alphanumeric

Move R backward if s[R] is not alphanumeric

Step 3 â€” Compare characters

Convert s[L] and s[R] to lowercase

If they are different â†’ return false

Else â†’ move L += 1 and R -= 1

Step 4 â€” Repeat until pointers meet

If loop finishes without mismatch â†’ return true

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan string once
Space	O(1) â†’ constant extra space for pointers

âœ”ï¸ Example Results

Example 1

Input: "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome


Example 2

Input: "race a car"
Output: false
Explanation: "raceacar" is not a palindrome

Example 3

Input: " "
Output: true
Explanation: empty string is trivially a palindrome



ğŸ‘‰ Problem: Two Sum II - Input Array Is Sorted (LeetCode 167)

You are given:

numbers â†’ a 1-indexed array of integers, sorted in non-decreasing order

target â†’ a number

You may:

Pick two distinct numbers from the array

Add them to equal target

Return:

[index1, index2] â†’ the 1-based indices of the two numbers that sum to target

Constraints:

Exactly one solution exists

Cannot use the same element twice

Must use constant extra space

âœ¨ Key Idea

Since the array is sorted, we can use two pointers:

L â†’ starts at the beginning

R â†’ starts at the end

At each step:

Calculate current_sum = numbers[L] + numbers[R]

If current_sum == target â†’ solution found â†’ return [L+1, R+1]

If current_sum < target â†’ move L right to increase sum

If current_sum > target â†’ move R left to decrease sum

This works because the array is sorted â†’ moving pointers adjusts the sum in a predictable way.

âœ¨ Flashcard

Two Sum II =
â€œUse two pointers on sorted array. Compare sum to target. Move L or R accordingly. Return 1-based indices.â€

ğŸ§  Mental Picture

Imagine two fingers: one at the start, one at the end of the array

Compare their sum to the target

Move fingers closer together until sum matches the target

One pass â†’ finds the solution efficiently

âœ… How It Works

L and R are pointers starting at the beginning and end of the array.

Calculate current_sum = numbers[L] + numbers[R].

If current_sum > target, move R left to reduce the sum.

If current_sum < target, move L right to increase the sum.

If current_sum == target, return [L + 1, R + 1] (1-indexed).

Continue until the correct pair is found.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0
R = len(numbers) - 1


Step 2 â€” Move pointers while L < R

Calculate current_sum = numbers[L] + numbers[R]

Compare with target:

current_sum == target â†’ return [L+1, R+1]

current_sum < target â†’ move L += 1 to increase sum

current_sum > target â†’ move R -= 1 to decrease sum

Step 3 â€” Continue until solution found

Guaranteed because exactly one solution exists

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ scan array once
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: 2 + 7 = 9


Example 2

Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: 2 + 4 = 6


Example 3

Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: -1 + 0 = -1


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array (LeetCode 26 two pointers)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicate elements in-place

Keep the relative order of the unique elements

Return:

k â†’ the number of unique elements in the array

The first k elements of nums should be the unique numbers

Elements beyond index k-1 can be ignored

Constraints:

1 <= nums.length <= 3 * 10^4

-100 <= nums[i] <= 100

Array is sorted in non-decreasing order

âœ¨ Key Idea

Because the array is sorted, duplicates appear consecutively:

Use two pointers:

L â†’ slow pointer, tracks last unique element

R â†’ fast pointer, scans through the array

At each step:

Compare nums[R] with nums[L]

If different â†’ found a new unique number

Move L forward

Assign nums[L] = nums[R]

If same â†’ skip, R moves forward

At the end, L + 1 is the count of unique numbers

âœ¨ Flashcard

Remove Duplicates =
â€œUse two pointers on sorted array. L tracks last unique. R scans. When nums[R] != nums[L], move L and update. Return L + 1.â€

ğŸ§  Mental Picture

Imagine a slow finger L marking the last unique element

A fast finger R scans the array

Whenever a new number appears, copy it after L

Result: unique numbers shifted to the front, duplicates ignored

âœ… How It Works

If the array is empty, return 0.

Use L as a slow pointer to track the position of the last unique element.

Iterate with R as a fast pointer through the array starting from index 1.

At each step, check if nums[R] is different from nums[L].

If different, increment L and write nums[R] at position L.

Continue until the end of the array.

Return L + 1 as the number of unique elements.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers

L = 0  # Last unique element index


Step 2 â€” Iterate with fast pointer

for R in range(1, len(nums)):


Step 3 â€” Check for new unique element

If nums[R] != nums[L] â†’ new number found

Move L += 1

Assign nums[L] = nums[R]

Step 4 â€” Continue until end of array

All unique elements are now from index 0 to L

Return L + 1 â†’ number of unique elements

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: unique elements are 1 and 2


Example 2

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: unique elements are 0,1,2,3,4


ğŸ‘‰ Problem: Remove Duplicates from Sorted Array II (LeetCode 80)

You are given:

nums â†’ a sorted integer array in non-decreasing order

You may:

Remove duplicates in-place such that each unique element appears at most twice

Keep the relative order of elements

Return:

k â†’ number of elements after removing extra duplicates

The first k elements of nums should contain the final result

Elements beyond index k-1 can be ignored

Constraints:

Do not allocate extra space â†’ O(1) space

1 <= nums.length <= 3 * 10^4

-10^4 <= nums[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ slow pointer, tracks the position to write the next allowed element

R â†’ fast pointer, scans the array

Keep at most 2 duplicates:

Compare nums[R] with nums[L-2] (the element 2 steps behind the slow pointer)

If nums[R] != nums[L-2] â†’ it is allowed â†’ copy nums[R] to nums[L] and move L forward

If nums[R] == nums[L-2] â†’ more than 2 duplicates â†’ skip

This works because the array is sorted â†’ duplicates are consecutive

âœ¨ Flashcard

Remove Duplicates II =
â€œUse two pointers. Slow pointer writes allowed elements. Keep at most two duplicates. If nums[R] != nums[L-2] â†’ write nums[R]. Return L.â€

ğŸ§  Mental Picture

Slow pointer L â†’ marks next position to write allowed element

Fast pointer R â†’ scans through array

Only copy the element if it does not exceed two occurrences

At the end â†’ first L elements are the allowed numbers

âœ… How It Works

If the array has 2 or fewer elements, all are allowed.

Use L as a slow pointer to track the position to write allowed elements.

Iterate with R as a fast pointer through the array starting from index 2.

At each step, check if nums[R] is different from nums[L - 2] to allow at most two duplicates.

If allowed, write nums[R] at position L and increment L.

Continue until the end of the array.

Return L as the number of allowed elements.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Handle edge case

if len(nums) <= 2:
    return len(nums)


If array has 0, 1, or 2 elements â†’ all are allowed

Step 2 â€” Initialize slow pointer

L = 2  # first two elements are always allowed


L points to next position to write

Start from index 2 because first two elements are always allowed

Step 3 â€” Iterate with fast pointer

for R in range(2, len(nums)):


R scans from the third element to the end

Step 4 â€” Check if current element is allowed

if nums[R] != nums[L - 2]:
    nums[L] = nums[R]
    L += 1


Compare with the element two steps behind slow pointer (nums[L-2])

If different â†’ allowed â†’ copy to nums[L] and move L forward

If same â†’ skip â†’ prevents more than 2 duplicates

Step 5 â€” Return number of allowed elements

return L


L is now the count of elements with at most two duplicates

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass through array
Space	O(1) â†’ in-place, constant extra space

âœ”ï¸ Example Results

Example 1

Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: keep at most two duplicates


Example 2

Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: keep at most two duplicates


ğŸ‘‰ Problem: Container With Most Water (LeetCode 11)

You are given:

height â†’ a list of vertical line heights

Each line is at coordinate (i, height[i])

You may:

Pick two lines to form a container with the x-axis

Return:

The maximum area of water the container can store

Constraints:

Cannot slant the container â†’ height is limited by the shorter line

2 <= height.length <= 10^5

0 <= height[i] <= 10^4

âœ¨ Key Idea

Use two pointers:

L â†’ start of array

R â†’ end of array

Area formula:

area
=
min
â¡
(
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ¿
]
,
â„
ğ‘’
ğ‘–
ğ‘”
â„
ğ‘¡
[
ğ‘…
]
)
Ã—
(
ğ‘…
âˆ’
ğ¿
)
area=min(height[L],height[R])Ã—(Râˆ’L)

Move the pointer pointing to the shorter line, because moving the taller line will never increase the area.

Keep track of maximum area seen so far.

âœ¨ Flashcard

Container With Most Water =
â€œTwo pointers at both ends. Area = min(height[L], height[R]) * width. Move shorter line pointer. Track max area.â€

ğŸ§  Mental Picture

Imagine a container formed by two vertical lines

Width = distance between lines

Height = shorter line

Slide the shorter line inward â†’ possible bigger height, maybe bigger area

Stop when pointers meet

âœ… How It Works

L and R scan from both ends toward the center.

At each step, the shorter line determines the container height.

Calculate area = min(height[L], height[R]) Ã— (R âˆ’ L).

Update max_area if current area is larger.

Move the pointer pointing to the shorter line inward.

Continue until L meets R.

âš¡ Full Approach (Step-by-Step, No Code)

Step 1 â€” Initialize pointers and max area

L = 0
R = len(height) - 1
max_area = 0


L â†’ left pointer

R â†’ right pointer

max_area â†’ stores largest container area so far

Step 2 â€” Loop until pointers meet

while L < R:


Continue scanning all possible containers formed by L and R

Step 3 â€” Calculate area

current_area = min(height[L], height[R]) * (R - L)
max_area = max(max_area, current_area)


Width = R - L

Height = min(height[L], height[R])

Update max_area if current_area is larger

Step 4 â€” Move pointer pointing to shorter line

if height[L] < height[R]:
    L += 1
else:
    R -= 1


Move the smaller line pointer inward

Why? Because moving the taller line cannot increase area, but moving the shorter line may

Step 5 â€” Return result

return max_area


After pointers meet, max_area holds the maximum container area

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass with two pointers
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: Max area formed by lines at index 1 and 8 â†’ min(8,7) * (8-1) = 49


Example 2

Input: height = [1,1]
Output: 1
Explanation: Only two lines â†’ area = 1


ğŸ‘‰ Problem: Trapping Rain Water (LeetCode 42)

You are given:

height â†’ an array of non-negative integers representing an elevation map

Width of each bar = 1

You may:

Compute how much water is trapped after raining between the bars

Return:

Total units of trapped water

Constraints:

1 <= height.length <= 2 * 10^4

0 <= height[i] <= 10^5

âœ¨ Key Idea

Water trapped at a given index depends on tallest bars to the left and right:

water at i
=
max
â¡
(
0
,
min
â¡
(
tallest left
,
tallest right
)
âˆ’
height
[
ğ‘–
]
)
water at i=max(0,min(tallest left,tallest right)âˆ’height[i])

Use two pointers approach for O(1) space:

L â†’ start pointer

R â†’ end pointer

Track left_max â†’ tallest bar from left

Track right_max â†’ tallest bar from right

Move the pointer pointing to the smaller bar

Compute water trapped at each step and accumulate

âœ¨ Flashcard

Trapping Rain Water =
â€œTwo pointers at both ends. Track tallest bars from left and right. Move the shorter bar inward. Water trapped = min(left_max, right_max) - height[i]. Add to total.â€

ğŸ§  Mental Picture

Imagine the bars forming valleys and peaks

Water can only be trapped up to the smaller of the tallest bars on the left and right

Move pointers inward step by step

At each step, calculate trapped water above the current bar

Continue until pointers meet

âš¡ Step-by-Step Approach (No Code)

Step 1 â€” Initialize pointers and variables

Place L at the start of the array and R at the end

Initialize left_max and right_max to 0

Initialize water to 0

Step 2 â€” Loop until pointers meet

Keep processing the bars between L and R

Step 3 â€” Decide which pointer to move

Compare height[L] and height[R]

Move the pointer pointing to the smaller bar

If left bar is smaller â†’ trapped water depends on left_max

If right bar is smaller â†’ trapped water depends on right_max

Step 4 â€” Update max and add trapped water

If current bar â‰¥ max on its side â†’ update the max

Else â†’ water trapped at this bar = max - height at the bar

Move pointer inward

Step 5 â€” Continue until pointers meet

Repeat Step 3 and Step 4 until the two pointers meet

Accumulate trapped water at each step

Step 6 â€” Return result

The total accumulated water is the answer

â±ï¸ Complexity

Operation	Cost
Time	O(n) â†’ single pass with two pointers
Space	O(1) â†’ constant extra space

âœ”ï¸ Example Results

Example 1

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: Water trapped = 6 units


Example 2

Input: [4,2,0,3,2,5]
Output: 9
Explanation: Water trapped = 9 units

âœ… How It Works

L and R scan from both ends toward the center.

At each step, the smaller bar determines trapped water.

left_max and right_max track the tallest bars seen so far.

Water trapped at a bar = max(0, min(left_max, right_max) âˆ’ height[i]).

Continue until L meets R.

ğŸ‘‰ Problem: Range Sum Query â€“ Immutable (Prefix Sum) (LeetCode 303)

You must answer multiple queries asking for the sum of elements between indices left and right (inclusive).

âœ… Key Idea

"Precompute cumulative sums once, then answer every range query using subtraction."

Instead of adding numbers again and again for every query, store partial sums and reuse them.

ğŸ§  Mental Map (Very Simple)

Imagine your array as checkpoints on a road:

Each checkpoint stores how far youâ€™ve traveled so far.

To know the distance between two checkpoints:

Look at the farther one

Subtract the distance just before the starting point

That difference is your answer.

âœ¨ Flashcard

Prefix Sum = sum till right âˆ’ sum before left

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a prefix sum structure

Prepare an array that will store cumulative sums.

Each position i will hold the sum of elements from index 0 to i.

Step 2 â€” Build cumulative totals

Start with a running total set to 0.

Scan the array from left to right:

Add the current number to the running total

Store this total in the prefix array

After this step:

prefix[i] = sum of elements from 0 to i

Step 3 â€” Understand what a range sum means

To find the sum from index left to right:

Take the sum up to right

Remove the sum of elements before left

Mathematically:

If left > 0 â†’ subtract prefix[left âˆ’ 1]

If left == 0 â†’ subtract 0

Step 4 â€” Answer each query in constant time

For every query (left, right):

Get the cumulative sum at right

Subtract the cumulative sum just before left

The result is the required range sum

No loops. No recalculation.

Step 5 â€” Finish

Since the array is immutable, the prefix array never changes.

You can answer thousands of queries efficiently using the same precomputed data.



â±ï¸ Complexity

Preprocessing: O(n) (build prefix sums once)

Each Query: O(1)

Space: O(n) (prefix array)

ğŸ“Œ This is the best possible solution for an immutable array
ğŸ“Œ This is exactly what interviewers expect for LeetCode 303
ğŸ“Œ Mutable version? â†’ Fenwick Tree / Segment Tree

ğŸ‘‰ Problem: Range Sum Query 2D â€“ Immutable (2D Prefix Sum) (LeetCode 304)

You must answer multiple queries asking for the sum of elements inside a rectangular sub-matrix, defined by its top-left corner (row1, col1) and bottom-right corner (row2, col2).

âœ… Key Idea

"Precompute cumulative sums for the whole matrix once, then answer every rectangle query using subtraction."

Instead of summing all cells inside the rectangle for every query, store partial rectangle sums and reuse them.

ğŸ§  Mental Map (Very Simple)

Imagine the matrix as a large field divided into blocks.

At each cell, you store:
â€œHow much area (sum) is covered from the top-left corner up to here?â€

To find the area of any rectangle:
Take the big area till the bottom-right
Remove the area above
Remove the area to the left
Add back the overlapping corner (removed twice)

### Think of it like peeling layers. Take a big rectangle. Cut off the top. Cut off the left. Fix the double cut

âœ¨ Flashcard

2D Prefix Sum = big rectangle âˆ’ top âˆ’ left + overlap

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Create a 2D prefix sum structure

Prepare a 2D array prefix.

Each position (i, j) will store the sum of all elements from (0,0) to (i,j).

Step 2 â€” Build cumulative totals row by row

For each row:

Start a running sum row_sum = 0

Move left to right across the row:

Add the current cell value to row_sum

Add the value from the cell directly above (if it exists)

Store the result in the prefix matrix

After this step:

prefix[i][j] = sum of all elements inside rectangle (0,0) â†’ (i,j)

Step 3 â€” Understand what a rectangle sum means

To find the sum of a rectangle (row1, col1) â†’ (row2, col2):

Start with the sum from (0,0) â†’ (row2, col2)

Remove the area above row1

Remove the area left of col1

Add back the top-left overlap (it was removed twice)

Step 4 â€” Answer each query in constant time

For every query (row1, col1, row2, col2):

Get the cumulative sum at (row2, col2)

Subtract the cumulative sum above the rectangle

Subtract the cumulative sum to the left of the rectangle

Add back the overlapping top-left area

No loops. No recalculation.

Step 5 â€” Finish

Since the matrix is immutable, the prefix matrix never changes.

You can answer thousands of rectangle sum queries efficiently using the same precomputed data.

â±ï¸ Complexity

Preprocessing: O(m Ã— n) (build prefix matrix once)

Each Query: O(1)

Space: O(m Ã— n) (prefix matrix)

ğŸ“Œ This is the best possible solution for an immutable 2D matrix
ğŸ“Œ This is exactly what interviewers expect for LeetCode 304
ğŸ“Œ Mutable version? â†’ 2D Fenwick Tree / Segment Tree

ğŸ‘‰ Problem: Find Pivot Index (1D Prefix Sum) (LeetCode 724)

You are given an array of integers.
You must find the leftmost index where:

sum of elements strictly to the left
=
sum of elements strictly to the right

If no such index exists, return -1.

âœ… Key Idea

"Keep a running prefix sum from the left, and derive the right sum using the total."

Instead of recalculating sums for every index, compute the total once and reuse it.

ğŸ§  Mental Map (Very Simple)

Imagine the array split into three parts at index i:

[ left_sum | nums[i] | right_sum ]


left_sum â†’ sum of everything before i

nums[i] â†’ current element

right_sum â†’ everything after i

If the left and right sides balance, youâ€™ve found the pivot.

âœ¨ Flashcard

1D Prefix Sum Pivot Rule

right_sum = total âˆ’ left_sum âˆ’ current_value


Pivot condition:

left_sum == right_sum

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Calculate total sum

Add up all elements of the array once.
This represents the entire weight of the array.

Step 2 â€” Start with an empty left side

Initialize a variable:

left_sum = 0

At the beginning, nothing exists to the left.

Step 3 â€” Scan the array from left to right

At each index:

Treat the current element as the â€œcenterâ€

Everything before it is left_sum

Everything after it is:

right_sum = total âˆ’ left_sum âˆ’ current_element

Step 4 â€” Check the pivot condition

If:

left_sum == right_sum


Return the current index immediately
(this guarantees the leftmost pivot).

Step 5 â€” Slide the divider

If itâ€™s not a pivot:

Add the current element to left_sum

Move to the next index

The divider shifts one step to the right.

Step 6 â€” No pivot found

If the loop ends with no match, return -1.

ğŸ” What left_sum += num really means

It moves the divider:

Before:
[ left | current | right ]

After:
[ left + current | next | right ]


This is a running (implicit) prefix sum.

â±ï¸ Complexity

Time: O(n) (single pass)

Space: O(1) (no extra array)

ğŸ“Œ Why this is optimal

ğŸ“Œ Uses prefix sum logic without extra memory
ğŸ“Œ One loop, no nested sums
ğŸ“Œ Exactly what interviewers expect for LeetCode 724

ğŸ” Relation to LeetCode 304
Problem	Dimension	Prefix Sum Type
304	2D	Stored prefix matrix
724	1D	Running prefix sum

Same idea. Different dimension.


ğŸ‘‰ Problem: Product of Array Except Self (Prefix Ã— Suffix Product) (LeetCode 238)

You are given an integer array nums.
You must return an array answer where:

answer[i] = product of all elements except nums[i]

âš ï¸ Constraints:

No division

O(n) time

Follow-up: O(1) extra space

âœ… Key Idea

"Whatâ€™s missing at index i is everything to the left Ã— everything to the right."

So for every index:

answer[i] = (product of left side) Ã— (product of right side)


This is prefix product + suffix product, just like prefix sumsâ€”but with multiplication.

ğŸ§  Mental Map (Very Simple)

Imagine the array split at index i:

[ left product | nums[i] | right product ]


Ignore the middle. Multiply the two sides.

âœ¨ Flashcard

Product Except Self

answer[i] = prefix_product[i] Ã— suffix_product[i]

âš¡ Full Approach (Two-Pass, No Division)
Step 1 â€” Prefix products (left side)

Create an output array answer.

For each index:

Store the product of all elements before it

Example (nums = [1,2,3,4]):

answer = [1, 1, 2, 6]


(1 is neutral for multiplication)

Step 2 â€” Suffix products (right side)

Now walk from right to left, keeping a running right_product.

At each index:

answer[i] *= right_product
right_product *= nums[i]


This multiplies the right side into the stored left product.

Step 3 â€” Done

The output array now contains the correct product for every index.


ğŸ” Dry Run (Example 1)

Input

nums = [1,2,3,4]

After prefix pass
answer = [1, 1, 2, 6]

After suffix pass
answer = [24, 12, 8, 6]

ğŸ§  Why this works with zeros

Example:

nums = [-1,1,0,-3,3]


Prefix and suffix naturally handle zeros

No division â†’ no undefined behavior

Exactly one zero â†’ only one index has non-zero product

Multiple zeros â†’ all products are zero

â±ï¸ Complexity

Time: O(n)

Extra Space: O(1) (output array excluded)

ğŸ“Œ Interview Takeaways

ğŸ“Œ This is prefix-suffix multiplication
ğŸ“Œ Same pattern family as:

LeetCode 724 (Pivot Index)

LeetCode 304 (2D Prefix Sum)

LeetCode 560 (Subarray Sum)

ğŸ“Œ Division-based solutions are not accepted

Line-by-line Explanation
class Solution:
This defines the class as required by LeetCode.
Think of it as a â€œcontainerâ€ for the function.

def productExceptSelf(self, nums):
This defines the function.
nums is the input list.
self is just standard for class methods in Python.
n = len(nums)

Get the length of the array.
Weâ€™ll use this to loop through the array.

answer = [1] * n
Make an output array of the same size as nums.
Fill it with 1 because multiplying by 1 doesnâ€™t change anything.

prefix = 1
prefix will store the product of all numbers to the left of the current index.
Start with 1 because nothing is on the left of index 0.

for i in range(n):
    answer[i] = prefix
    prefix *= nums[i]

Step by step:
answer[i] = prefix â†’ store the product of all elements before index i.
prefix *= nums[i] â†’ include the current element in the left product for the next index.

After this loop:
answer[i] contains the product of all elements to the left of i.

suffix = 1
suffix will store the product of all numbers to the right of the current index.
Start with 1 because nothing is on the right of the last index.

for i in range(n - 1, -1, -1):
    answer[i] *= suffix
    suffix *= nums[i]

Step by step:

answer[i] *= suffix â†’ multiply the current value (left product) by the product of all elements to the right.
suffix *= nums[i] â†’ include the current element in the right product for the next index to the left.

After this loop:
answer[i] now contains product of everything except nums[i].

return answer

Return the final output array.

ğŸ§  Key Idea (Easy Way)

First loop â†’ collect left products.

Second loop â†’ multiply right products.

No division. One array used for output. Two simple passes.


ğŸ‘‰ Problem: Subarray Sum Equals K (1D Prefix Sum + Hash Map) (LeetCode 560)

You are given an integer array nums and an integer k.

Your task is to count how many continuous subarrays have a sum equal to k.

âœ… Key Idea

â€œTrack cumulative sums and count how many times weâ€™ve seen a needed sum before.â€

Instead of checking every subarray (slow), we reuse past prefix sums to instantly know how many valid subarrays end at the current index.

ğŸ§  Mental Map (Very Simple)

Imagine walking through the array while keeping a running balance.

At each step, ask:

â€œHave I ever seen a balance of (current_sum âˆ’ k) before?â€

If yes:

Every time it appeared = one valid subarray ending here

Then:

Record the current balance for future use

âœ¨ Flashcard

1D Prefix Sum Rule

subarray sum = current_sum âˆ’ previous_sum


So:

If current_sum âˆ’ k exists before â†’ subarray sum = k

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Initialize counters

count â†’ total number of valid subarrays

cum_sum â†’ running sum while iterating

prefix_counts â†’ stores:

prefix_sum â†’ how many times it appeared


Start with:

prefix_counts[0] = 1


ğŸ‘‰ This represents the empty prefix, allowing subarrays that start at index 0.

Step 2 â€” Traverse the array

Move through nums one element at a time.

At each element:

Add it to cum_sum

Now ask:

â€œDo I already have a prefix sum equal to cum_sum âˆ’ k?â€

Step 3 â€” Count valid subarrays

If cum_sum âˆ’ k exists:

Add its frequency to count

Why?

Each occurrence represents a different starting point

All of them form a valid subarray ending here

Step 4 â€” Store current prefix sum

Record the current cum_sum in prefix_counts.

Important:

Use increment, not assignment

Same cumulative sum can appear multiple times

This builds history for future checks.

Step 5 â€” Finish

After scanning the array:

count contains the total number of subarrays whose sum is k

Return it.

ğŸ§© Tiny Walkthrough
nums = [1, 2, 3]
k = 3

Index	num	    cum_sum	    cum_sum âˆ’ k	    Found before?	        count
start	 â€“	       0	        â€“	      prefix_counts[0]=1	       0
0	     1	       1	       -2	            âŒ	                   0
1	     2	       3	        0	            âœ…	                   1
2	     3	       6	        3	            âœ…	                   2

Valid subarrays:

[1,2]

[3]

â±ï¸ Complexity

Time: O(n) (single pass)

Space: O(n) (prefix sum map)

ğŸ“Œ Why this solution is perfect

ğŸ“Œ Works with negative numbers (sliding window fails)
ğŸ“Œ Optimal for interviews
ğŸ“Œ Exactly what LeetCode expects for Subarray Sum Equals K

ğŸ” Related problems:

Prefix sum basics

Subarray sum = 0

2D version â†’ Prefix Sum Matrix

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Middle of Linked List â€“ LeetCode 876)

Find the middle of a linked list using two pointers:
slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Fast ends â†’ slow is the middle.
Even list? â†’ second middle.â€

âš¡ Full Explanation (Very Easy)

1. Find the middle of a linked list
ğŸ¯ Goal

Return the middle node of a singly linked list.
If there are two middle nodes, return the second one.

ğŸ” How the code works (Line-by-Line)

Initialize pointers
slow, fast = head, head


slow â†’ moves 1 step at a time

fast â†’ moves 2 steps at a time

Both start at the head.

Traverse until fast reaches the end
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next


Fast moves twice as fast as slow

When fast reaches the end:

slow is at the middle

For even-length lists:

slow naturally lands on the second middle

Return slow
return slow


Middle node found âœ…

ğŸ§  Mental Map

â€œFast pointer finishes first â†’ slow pointer is the middle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

ğŸ‘‰ Floydâ€™s Tortoise and Hare + Reverse Second Half (LeetCode 2130)

Find the maximum twin sum in a linked list using two pointers and a reverse of the second half.

âœ¨ Flashcard

â€œFind middle â†’ reverse second half â†’ walk together â†’ add twins â†’ track max.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Find the middle of the linked list

ğŸ¯ Goal
Split the list into two halves so twin nodes can be aligned.

ğŸ§  Mental Picture

Original list: 5 â†’ 4 â†’ 2 â†’ 1
Slow stops at middle â†’ split
Left half:  5 â†’ 4
Right half: 2 â†’ 1


slow moves 1 step, fast moves 2 steps

When fast reaches the end â†’ slow is at middle

Even-length list â†’ slow lands at start of second half

2ï¸âƒ£ Reverse the second half

ğŸ¯ Goal
Align twins so we can walk left & right together.

ğŸ§  Mental Picture

Right half before reverse: 2 â†’ 1
After reverse:             1 â†’ 2


Twins now line up side by side

Left half stays the same

Right half is flipped

Think: â€œMirror the second half to face the first halfâ€

3ï¸âƒ£ Walk both halves and compute maximum twin sum

ğŸ¯ Goal
Add each twin pair and track the maximum sum.

ğŸ§  Mental Picture

Left:   5 â†’ 4
Right:  1 â†’ 2
Add pairs: 5+1=6, 4+2=6
Maximum = 6


Move both pointers together

Stop when the right pointer ends

Why right? â†’ Each node in the right half has exactly one twin

â€œCut â†’ Flip â†’ Add â†’ Track maxâ€

ğŸ§  Extra Notes / Mental Hooks

You donâ€™t need extra space

Only one pass to middle, one reverse, one pass for sums

Works for any even-length linked list

Fast pointer â†’ stops the middle naturally

Reversing the second half â†’ makes twin calculation simple

ğŸ“¦ Complexity

Time: O(n) â†’ middle + reverse + pair walk

Space: O(1) â†’ only pointers, no extra list

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Linked List Cycle â€“ LeetCode 141)

Detect if a linked list contains a cycle using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Meet? â†’ cycle exists.
Fast reaches end? â†’ no cycle.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Detect a cycle in a linked list

ğŸ¯ Goal
Return True if the linked list contains a cycle; otherwise, return False.

ğŸ§  Mental Picture

Example: 3 â†’ 2 â†’ 0 â†’ -4
           â†‘         â†“
           â†---------


Slow pointer moves 1 step at a time

Fast pointer moves 2 steps at a time

If a cycle exists:

Fast will eventually â€œlapâ€ slow

Slow and fast meet inside the cycle

If no cycle exists:

Fast reaches the end of the list (None)

No meeting â†’ return False

ğŸ”¹ Step-by-Step

Initialize pointers

slow = head

fast = head

Traverse the list

Move slow 1 step

Move fast 2 steps

Check if slow == fast

Yes â†’ cycle exists â†’ return True

No â†’ continue

End condition

Fast reaches the end â†’ no cycle â†’ return False

ğŸ§  Mental Map

â€œTwo runners in a track:
Slow walks, fast runs.
Meet? â†’ cycle.
Fast finishes track â†’ no cycle.â€

ğŸ“¦ Complexity

Time: O(n) â†’ slow + fast traverse at most once around the list

Space: O(1) â†’ only two pointers

ğŸ‘‰ Floydâ€™s Tortoise and Hare (Linked List Cycle II â€“ LeetCode 142)

Find the starting node of a cycle in a linked list using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs.
Meet inside cycle? â†’ rewind slow â†’ start of cycle.
Fast reaches end? â†’ no cycle.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Detect if a cycle exists

ğŸ¯ Goal
Determine whether the linked list contains a cycle first.

ğŸ§  Mental Picture

Example: 3 â†’ 2 â†’ 0 â†’ -4
           â†‘         â†“
           â†---------


Slow pointer moves 1 step

Fast pointer moves 2 steps

If a cycle exists:

Fast will eventually â€œlapâ€ slow

Slow and fast meet inside the cycle

If no cycle exists:

Fast reaches the end of the list (None) â†’ no cycle

ğŸ”¹ Step-by-Step

Initialize pointers

slow = head

fast = head

Traverse

Move slow 1 step

Move fast 2 steps

If slow == fast â†’ cycle exists â†’ go to next step

Else â†’ continue

If fast reaches the end â†’ return None (no cycle)

2ï¸âƒ£ Find the start of the cycle

ğŸ¯ Goal
Return the first node where the cycle begins.

ğŸ§  Mental Picture

Let slow = meeting point inside cycle

Let slow2 = head of the list

Move both pointers 1 step at a time

They will meet at the start of the cycle

List: 3 â†’ 2 â†’ 0 â†’ -4
Start: slow2 = head
Meeting: slow inside cycle
Walk both â†’ meet at node 2 (start of cycle)


Why it works:
Distance from head to cycle start = distance from meeting point to cycle start along the cycle

ğŸ§  Mental Map

â€œDetect cycle â†’ meet inside â†’ rewind slow to head â†’ both walk 1 step â†’ meet at cycle start.â€

ğŸ“¦ Complexity

Time: O(n) â†’ one pass to detect + one pass to find start

Space: O(1) â†’ only two pointers