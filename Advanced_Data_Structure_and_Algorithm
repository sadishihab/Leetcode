ğŸ‘‰ (Maximum Subarray â€“ Three Approaches)
1ï¸âƒ£ Brute Force â€“ O(nÂ²)
âœ… Key Idea

Try every possible subarray and keep track of the largest sum.

At each index i, extend the subarray to the right (j) and accumulate the sum.

âœ¨ Flashcard:
"Pick a start â†’ extend right â†’ update max â†’ repeat for all starts."

âš¡ Full Approach
Steps:

Initialize maxSum to the first element.

Loop i from 0 to nâˆ’1 (start of subarray).

Set curSum = 0 for each new starting point.

Loop j from i to nâˆ’1 (extend the subarray).

Add nums[j] to curSum.

Update maxSum = max(maxSum, curSum).

After checking all subarrays â†’ return maxSum.

â±ï¸ Complexity

Time: O(nÂ²) â€” every (i, j) pair is checked.
Space: O(1) â€” uses constant extra space.

âœ… Notes

Very easy to understand.

Very slow for big inputs.

Good as a baseline, bad in interviews for large arrays.

2ï¸âƒ£ Kadaneâ€™s Algorithm â€“ O(n)
âœ… Key Idea

Walk through the array and maintain a running sum.
If the running sum becomes negative, drop it (reset to 0).

âœ¨ Flashcard:
"If current sum < 0 â†’ reset. Add each number and keep max."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Loop through each number n in nums:

If curSum is negative, reset it: curSum = max(curSum, 0)

Add current number: curSum += n

Update best: maxSum = max(maxSum, curSum)

Return maxSum.

â±ï¸ Complexity

Time: O(n) â€” single pass.
Space: O(1).

âœ… Notes

Works even when array contains negative numbers.

Extremely efficient.

Most common interview solution.

3ï¸âƒ£ Sliding Window Variant of Kadane â€” O(n), with indices
âœ… Key Idea

Same as Kadane, but also track where the max subarray starts and ends.

âœ¨ Flashcard:
"Reset window when sum < 0. Expand right. Update best window when new max is found."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Track indices:

L = current window start

maxL, maxR = best window

For each R in range(len(nums)):

If curSum < 0:

reset curSum = 0

move L = R (new window start)

Add current number: curSum += nums[R]

If curSum beats maxSum:

update maxSum

update maxL, maxR = L, R

Return [maxL, maxR].

â±ï¸ Complexity

Time: O(n)
Space: O(1)

âœ… Notes

Same speed as Kadane.

But it also gives the start and end indices of the best subarray.

Very useful when we need the actual slice of the array.


ğŸ§  First: The Thinking Method & Mental Map

All three functions solve Maximum Subarray Sum (LeetCode 53):
Find a subarray (continuous part) that gives the biggest sum.

1. Brute Force â€“ Thinking Method (Try Everything)

Mental Map:
Imagine pointing at each index i.
Then from that i, extend a window to the right step-by-step (j).
For every possible slice, compute the sum.
Keep track of the biggest one.

âš¡ This is like checking all possible subarrays.

2. Kadaneâ€™s Algorithm â€“ Thinking Method (Smart skipping)

Mental Map:
Walk through the array once.
Keep a running sum (curSum).
If the running sum becomes negative, drop it.
Because a negative sum will only pull future sums down.
Always update the best result (maxSum).

âš¡ This is like saying:
â€œIf what I have so far is harmful (negative), I'll start over.â€

3. Sliding Window Variation â€“ Thinking Method (Kadane + indices)

Kadane normally returns only the sum.
This version also returns left and right indices of the best subarray.

Mental Map:
Still reset curSum when it becomes negative.
At the moment you reset, the new potential start index = R.

Any time you find a new maxSum, record:
The current start (L)

The current end (R)

âš¡ It tracks where the best window starts and ends.


ğŸ‘‰ Problem - Sliding WIndow Fixed (sliding_window_fixed.py)

Check if the array has two equal numbers that are close to each other â€”
specifically, their indices differ by less than k.

Example:
If k = 3, then valid pairs are within 3 steps:
(L, L+1), (L, L+2)

âœ¨ Flashcard

â€œFix left. Check next k positions: any match? â†’ True.â€

âš¡ Full Explanation (Very Easy)
Goal

We are trying to find two identical values such that:

indices are close (difference < k)

ğŸ” How the code works (Line-by-Line)
1. Outer loop â†’ pick a starting index L
for L in range(len(nums)):


Think of L as the left pointer.
We will check if nums[L] has a matching twin nearby.

2. Inner loop â†’ look ahead up to k positions
for R in range(L + 1, min(len(nums), L + k)):


Start from the next position L+1

Look forward only up to k steps (not the whole array)

Stop early if the array ends

So this checks only the close neighbors.

3. Compare values at L and R
if nums[L] == nums[R]:
    return True


If we find any match within k steps â†’ answer is True.

Example:
If L = 2 and nums[2] == nums[4], and 4 - 2 < k, then return True.

4. If loops finish with no match
return False


Means:
â€œNo two close duplicates exist.â€

ğŸ§  Mental Map (Very Simple)

Pick a number.

Look at the next k numbers only.

If any of them is the same â†’ found!

If after checking all positions â†’ none found, return False.

ğŸ“¦ Complexity

Time: O(n Ã— k) because for every element, we look ahead up to k positions

Space: O(1)

ğŸ‘‰ Same problem using sliding window and Hash Set. O(n)
Goal:
ğŸŒŸ When scanning the array, always keep a window of the last k elements.
If the current number is already inside the window â†’ itâ€™s a duplicate within k distance.

âœ¨ Flashcard

â€œKeep last k elements in a set.
If current value is already inside â†’ close duplicate found.â€

âš¡ Full Explanation (Line-by-Line & Super Easy)
1. Create a window as a SET
window = set()
L = 0


window stores the last k elements weâ€™ve seen.

L is the left boundary of the sliding window.

Set is used because lookup is O(1) and perfect for checking duplicates.

2. Loop R from left to right (right boundary)
for R in range(len(nums)):


We move R across the array.

At each R, we check nums[R] with the window.

3. Make sure window size never exceeds k
if R - L + 1 > k:
    window.remove(nums[L])
    L += 1


Explanation:

The window length is (R - L + 1)

If it becomes bigger than k, we must â€œshrinkâ€ it

Remove the leftmost value (nums[L]) from the set

Move L right by 1

This guarantees the window always contains only the last k elements.

4. Check for close duplicate
if nums[R] in window:
    return True


If current value already exists in the window â†’
It means we found a duplicate within k distance.

Return True immediately.

5. Otherwise, add current value to the window
window.add(nums[R])


Now nums[R] becomes part of the last k elements.

6. If loop finishes with no matches
return False


Meaning:
No â€œclose duplicatesâ€ found.

ğŸ§  Mental Map (Very simple)

Imagine a window of k size sliding to the right:

Window holds only last k values

For each new number:

If itâ€™s already in window â†’ duplicate close by â†’ True

If not, add it to window

If window gets too big â†’ remove oldest value

ğŸ“Œ Example

nums = [1, 2, 3, 1], k = 3

Step by step:

R	Window	nums[R]	In window?
0	{}	1	No â†’ add
1	{1}	2	No â†’ add
2	{1,2}	3	No â†’ add
3	{1,2,3}	1	Yes! â†’ return True
â±ï¸ Complexity

Time: O(n)

Space: O(k)


ğŸ‘‰ Problem 1: Longest Subarray With All Equal Values

Find the length of the longest subarray where every element is the same.

You are given:

nums â†’ array of numbers

You must find:

The maximum length of a contiguous stretch where all values are identical

âœ¨ Key Idea

This type of pattern is perfect for a sliding window with two pointers (L and R).

We try to expand the window as long as all elements are equal.

The moment we find a different number:

We â€œresetâ€ the window

Move L to R

This starts a new segment of identical values

âœ¨ Flashcard

â€œTrack a block of equal numbers with L.
Move R forward.
If value changes â†’ set L = R (new block).
Longest block length = answer.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers: L and R

L marks the start of the current block of identical numbers.

R moves across the array (0 â†’ n-1).

Step 2 â€” Compare nums[L] and nums[R]

If they are equal â†’ we remain inside the same subarray.

If they are different â†’
The previous block ended.
Set:

L = R


This starts a new block from position R.

Step 3 â€” Track the maximum block length

At each R:

current_length = R - L + 1
update max_length

Step 4 â€” Continue to the end

The answer is the largest length found.

ğŸ§  Mental Picture

Think of walking through the array and grouping numbers:

[7 7 7 2 2 5 5 5 5 5]

When the value changes, you start counting again.

The longest â€œrunâ€ wins.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one scan through the array.

ğŸ‘‰ Problem 2: Shortest Subarray With Sum â‰¥ Target

Find the smallest subarray length whose sum is at least target.

You are given:

nums â†’ positive integers

target â†’ required minimum sum

Return:

Length of the shortest subarray with sum â‰¥ target

If none exists â†’ return 0

âœ¨ Key Idea

This is a classic expanding + shrinking sliding window.

Because all numbers are positive, the window sum only increases when R moves right â€” so shrinking works correctly.

âœ¨ Flashcard

â€œExpand R to grow sum.
When total â‰¥ target â†’ shrink from L to find smaller valid window.
Track minimum window length.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L = start of window

R = end of window

total = sum of current window

Step 2 â€” Expand the window by moving R

For each R:

total += nums[R]


This makes the window sum bigger.

Step 3 â€” When total â‰¥ target â†’ shrink

While the window is â€œheavy enoughâ€:

Update the minimum length:

length = min(length, R - L + 1)


Remove the leftmost element:

total -= nums[L]
L += 1


This tries to make the window smaller while still meeting the sum requirement.

Step 4 â€” Continue until R reaches end
Step 5 â€” If no window ever met the target

Return 0.

ğŸ§  Mental Picture

Imagine dragging a window that grows until it hits the target sum.

Then you tighten the window from the left to see if a smaller valid window exists.

Repeat until the end.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only linear time because each pointer (L and R) moves at most n steps.

ğŸ‘‰ Problem: Two Pointers (two_pointers.py)
ğŸ‘‰ Problem 1: Check if a String is a Palindrome

Determine whether a given string reads the same forwards and backwards.

You are given:

word â†’ a string of characters

You must return:

true if the string is a palindrome

false otherwise

âœ¨ Key Idea

Use the two-pointer pattern:

One pointer starts at the left

One pointer starts at the right

Compare characters while moving inward.

The moment characters donâ€™t match â†’ itâ€™s not a palindrome.

If we reach the center without mismatches â†’ it is a palindrome.

âœ¨ Flashcard

â€œUse two pointers from both ends.
If characters ever differ â†’ not a palindrome.
If pointers meet with no mismatches â†’ palindrome.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Initialize Two Pointers

Set:

L = 0 (start of the string)

R = len(word) âˆ’ 1 (end of the string)

Step 2 â€” Compare Characters

While L < R:

If word[L] == word[R] â†’ good, keep moving toward the middle

If they differ â†’ instantly return false

Step 3 â€” Move Pointers

After each comparison:

Increment L

Decrement R

This gradually checks symmetrical positions.

Step 4 â€” Reaching the Middle

If the loop completes without finding a mismatch â†’
The string is a palindrome â†’ return true

ğŸ§  Mental Picture

Imagine folding a string from both ends toward the center.
If all mirrored characters match perfectly â†’ palindrome.

Example:

racecar
L-----R (r == r)
 L---R  (a == a)
  L-R   (c == c)
   center

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only scans the string once, using constant memory.

ğŸ‘‰ Problem 2: Two Numbers Sum to Target (In Sorted Array)

Find two numbers in a sorted list that add up to a given target.

You are given:

nums â†’ a sorted array of integers

target â†’ the required sum

You must return:

The indices of the two numbers (L, R) that add up to the target

There is guaranteed exactly one solution

âœ¨ Key Idea

Use the two-pointer technique on the sorted array.

Because it's sorted:

If the sum is too big â†’ move the right pointer left

If the sum is too small â†’ move the left pointer right

If the sum matches â†’ done!

âœ¨ Flashcard

â€œUse two pointers on sorted array.
If sum too big â†’ move R left.
If sum too small â†’ move L right.
When sum matches â†’ return [L, R].â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with Two Pointers

Set:

L = 0 (start of the array)

R = len(nums) âˆ’ 1 (end of the array)

Step 2 â€” Check the Sum of nums[L] + nums[R]

Three cases:

Sum > target
The right value is too large
â†’ Move R left

Sum < target
The left value is too small
â†’ Move L right

Sum == target
Perfect match
â†’ Return [L, R]

Step 3 â€” Repeat Until They Meet

Pointers move inward until the sum is found.

ğŸ§  Mental Picture

You're looking at a scale:

small ......... big
 L           R


If the total is too heavy â†’ shift right pointer left.
If too light â†’ shift left pointer right.

Eventually, the balance matches the target.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Just a single pass through the array.

ğŸ‘‰ Prefix Sum â€“ Range Sum Query (O(1) per query)

1ï¸âƒ£ Prefix Sum Technique

(Preprocessing O(n), Query O(1))

âœ… Key Idea

Store cumulative sums so any subarray sum can be computed using subtraction instead of re-summing elements.

âœ¨ Flashcard

"Precompute sums once â†’ subtract boundaries â†’ get range sum instantly."

âš¡ Full Approach

Steps:

Initialize an empty array prefix.

Set a variable total = 0.

Traverse the input array from left to right:

Add the current element to total.

Append total to the prefix array.

To answer a range sum query (left, right):

Take prefix[right] as the sum from index 0 to right.

If left > 0, subtract prefix[left âˆ’ 1].

If left == 0, subtract 0.

The result is the sum of elements from index left to right.

â±ï¸ Complexity

Preprocessing Time: O(n)

Query Time: O(1)

Space: O(n)

âœ… Notes

Ideal when multiple range sum queries are needed.

Simple logic, very fast queries.

Not suitable if the array is frequently updated.

Commonly used in interviews and competitive programming.