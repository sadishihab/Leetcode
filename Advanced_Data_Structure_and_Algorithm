ğŸ‘‰ (Maximum Subarray â€“ Three Approaches)
1ï¸âƒ£ Brute Force â€“ O(nÂ²)
âœ… Key Idea

Try every possible subarray and keep track of the largest sum.

At each index i, extend the subarray to the right (j) and accumulate the sum.

âœ¨ Flashcard:
"Pick a start â†’ extend right â†’ update max â†’ repeat for all starts."

âš¡ Full Approach
Steps:

Initialize maxSum to the first element.

Loop i from 0 to nâˆ’1 (start of subarray).

Set curSum = 0 for each new starting point.

Loop j from i to nâˆ’1 (extend the subarray).

Add nums[j] to curSum.

Update maxSum = max(maxSum, curSum).

After checking all subarrays â†’ return maxSum.

â±ï¸ Complexity

Time: O(nÂ²) â€” every (i, j) pair is checked.
Space: O(1) â€” uses constant extra space.

âœ… Notes

Very easy to understand.

Very slow for big inputs.

Good as a baseline, bad in interviews for large arrays.

2ï¸âƒ£ Kadaneâ€™s Algorithm â€“ O(n)
âœ… Key Idea

Walk through the array and maintain a running sum.
If the running sum becomes negative, drop it (reset to 0).

âœ¨ Flashcard:
"If current sum < 0 â†’ reset. Add each number and keep max."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Loop through each number n in nums:

If curSum is negative, reset it: curSum = max(curSum, 0)

Add current number: curSum += n

Update best: maxSum = max(maxSum, curSum)

Return maxSum.

â±ï¸ Complexity

Time: O(n) â€” single pass.
Space: O(1).

âœ… Notes

Works even when array contains negative numbers.

Extremely efficient.

Most common interview solution.

3ï¸âƒ£ Sliding Window Variant of Kadane â€” O(n), with indices
âœ… Key Idea

Same as Kadane, but also track where the max subarray starts and ends.

âœ¨ Flashcard:
"Reset window when sum < 0. Expand right. Update best window when new max is found."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Track indices:

L = current window start

maxL, maxR = best window

For each R in range(len(nums)):

If curSum < 0:

reset curSum = 0

move L = R (new window start)

Add current number: curSum += nums[R]

If curSum beats maxSum:

update maxSum

update maxL, maxR = L, R

Return [maxL, maxR].

â±ï¸ Complexity

Time: O(n)
Space: O(1)

âœ… Notes

Same speed as Kadane.

But it also gives the start and end indices of the best subarray.

Very useful when we need the actual slice of the array.


ğŸ§  First: The Thinking Method & Mental Map

All three functions solve Maximum Subarray Sum (LeetCode 53):
Find a subarray (continuous part) that gives the biggest sum.

1. Brute Force â€“ Thinking Method (Try Everything)

Mental Map:
Imagine pointing at each index i.
Then from that i, extend a window to the right step-by-step (j).
For every possible slice, compute the sum.
Keep track of the biggest one.

âš¡ This is like checking all possible subarrays.

2. Kadaneâ€™s Algorithm â€“ Thinking Method (Smart skipping)

Mental Map:
Walk through the array once.
Keep a running sum (curSum).
If the running sum becomes negative, drop it.
Because a negative sum will only pull future sums down.
Always update the best result (maxSum).

âš¡ This is like saying:
â€œIf what I have so far is harmful (negative), I'll start over.â€

3. Sliding Window Variation â€“ Thinking Method (Kadane + indices)

Kadane normally returns only the sum.
This version also returns left and right indices of the best subarray.

Mental Map:
Still reset curSum when it becomes negative.
At the moment you reset, the new potential start index = R.

Any time you find a new maxSum, record:
The current start (L)

The current end (R)

âš¡ It tracks where the best window starts and ends.


ğŸ‘‰ Problem - Sliding WIndow Fixed (sliding_window_fixed.py)

Check if the array has two equal numbers that are close to each other â€”
specifically, their indices differ by less than k.

Example:
If k = 3, then valid pairs are within 3 steps:
(L, L+1), (L, L+2)

âœ¨ Flashcard

â€œFix left. Check next k positions: any match? â†’ True.â€

âš¡ Full Explanation (Very Easy)
Goal

We are trying to find two identical values such that:

indices are close (difference < k)

ğŸ” How the code works (Line-by-Line)
1. Outer loop â†’ pick a starting index L
for L in range(len(nums)):


Think of L as the left pointer.
We will check if nums[L] has a matching twin nearby.

2. Inner loop â†’ look ahead up to k positions
for R in range(L + 1, min(len(nums), L + k)):


Start from the next position L+1

Look forward only up to k steps (not the whole array)

Stop early if the array ends

So this checks only the close neighbors.

3. Compare values at L and R
if nums[L] == nums[R]:
    return True


If we find any match within k steps â†’ answer is True.

Example:
If L = 2 and nums[2] == nums[4], and 4 - 2 < k, then return True.

4. If loops finish with no match
return False


Means:
â€œNo two close duplicates exist.â€

ğŸ§  Mental Map (Very Simple)

Pick a number.

Look at the next k numbers only.

If any of them is the same â†’ found!

If after checking all positions â†’ none found, return False.

ğŸ“¦ Complexity

Time: O(n Ã— k) because for every element, we look ahead up to k positions

Space: O(1)

ğŸ‘‰ Same problem using sliding window and Hash Set. O(n)
Goal:
ğŸŒŸ When scanning the array, always keep a window of the last k elements.
If the current number is already inside the window â†’ itâ€™s a duplicate within k distance.

âœ¨ Flashcard

â€œKeep last k elements in a set.
If current value is already inside â†’ close duplicate found.â€

âš¡ Full Explanation (Line-by-Line & Super Easy)
1. Create a window as a SET
window = set()
L = 0


window stores the last k elements weâ€™ve seen.

L is the left boundary of the sliding window.

Set is used because lookup is O(1) and perfect for checking duplicates.

2. Loop R from left to right (right boundary)
for R in range(len(nums)):


We move R across the array.

At each R, we check nums[R] with the window.

3. Make sure window size never exceeds k
if R - L + 1 > k:
    window.remove(nums[L])
    L += 1


Explanation:

The window length is (R - L + 1)

If it becomes bigger than k, we must â€œshrinkâ€ it

Remove the leftmost value (nums[L]) from the set

Move L right by 1

This guarantees the window always contains only the last k elements.

4. Check for close duplicate
if nums[R] in window:
    return True


If current value already exists in the window â†’
It means we found a duplicate within k distance.

Return True immediately.

5. Otherwise, add current value to the window
window.add(nums[R])


Now nums[R] becomes part of the last k elements.

6. If loop finishes with no matches
return False


Meaning:
No â€œclose duplicatesâ€ found.

ğŸ§  Mental Map (Very simple)

Imagine a window of k size sliding to the right:

Window holds only last k values

For each new number:

If itâ€™s already in window â†’ duplicate close by â†’ True

If not, add it to window

If window gets too big â†’ remove oldest value

ğŸ“Œ Example

nums = [1, 2, 3, 1], k = 3

Step by step:

R	Window	nums[R]	In window?
0	{}	1	No â†’ add
1	{1}	2	No â†’ add
2	{1,2}	3	No â†’ add
3	{1,2,3}	1	Yes! â†’ return True
â±ï¸ Complexity

Time: O(n)

Space: O(k)


ğŸ‘‰ Problem 1: Longest Subarray With All Equal Values

Find the length of the longest subarray where every element is the same.

You are given:

nums â†’ array of numbers

You must find:

The maximum length of a contiguous stretch where all values are identical

âœ¨ Key Idea

This type of pattern is perfect for a sliding window with two pointers (L and R).

We try to expand the window as long as all elements are equal.

The moment we find a different number:

We â€œresetâ€ the window

Move L to R

This starts a new segment of identical values

âœ¨ Flashcard

â€œTrack a block of equal numbers with L.
Move R forward.
If value changes â†’ set L = R (new block).
Longest block length = answer.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers: L and R

L marks the start of the current block of identical numbers.

R moves across the array (0 â†’ n-1).

Step 2 â€” Compare nums[L] and nums[R]

If they are equal â†’ we remain inside the same subarray.

If they are different â†’
The previous block ended.
Set:

L = R


This starts a new block from position R.

Step 3 â€” Track the maximum block length

At each R:

current_length = R - L + 1
update max_length

Step 4 â€” Continue to the end

The answer is the largest length found.

ğŸ§  Mental Picture

Think of walking through the array and grouping numbers:

[7 7 7 2 2 5 5 5 5 5]

When the value changes, you start counting again.

The longest â€œrunâ€ wins.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one scan through the array.

ğŸ‘‰ Problem 2: Shortest Subarray With Sum â‰¥ Target

Find the smallest subarray length whose sum is at least target.

You are given:

nums â†’ positive integers

target â†’ required minimum sum

Return:

Length of the shortest subarray with sum â‰¥ target

If none exists â†’ return 0

âœ¨ Key Idea

This is a classic expanding + shrinking sliding window.

Because all numbers are positive, the window sum only increases when R moves right â€” so shrinking works correctly.

âœ¨ Flashcard

â€œExpand R to grow sum.
When total â‰¥ target â†’ shrink from L to find smaller valid window.
Track minimum window length.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L = start of window

R = end of window

total = sum of current window

Step 2 â€” Expand the window by moving R

For each R:

total += nums[R]


This makes the window sum bigger.

Step 3 â€” When total â‰¥ target â†’ shrink

While the window is â€œheavy enoughâ€:

Update the minimum length:

length = min(length, R - L + 1)


Remove the leftmost element:

total -= nums[L]
L += 1


This tries to make the window smaller while still meeting the sum requirement.

Step 4 â€” Continue until R reaches end
Step 5 â€” If no window ever met the target

Return 0.

ğŸ§  Mental Picture

Imagine dragging a window that grows until it hits the target sum.

Then you tighten the window from the left to see if a smaller valid window exists.

Repeat until the end.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only linear time because each pointer (L and R) moves at most n steps.

ğŸ‘‰ Problem: Two Pointers (two_pointers.py)
ğŸ‘‰ Problem 1: Check if a String is a Palindrome

Determine whether a given string reads the same forwards and backwards.

You are given:

word â†’ a string of characters

You must return:

true if the string is a palindrome

false otherwise

âœ¨ Key Idea

Use the two-pointer pattern:

One pointer starts at the left

One pointer starts at the right

Compare characters while moving inward.

The moment characters donâ€™t match â†’ itâ€™s not a palindrome.

If we reach the center without mismatches â†’ it is a palindrome.

âœ¨ Flashcard

â€œUse two pointers from both ends.
If characters ever differ â†’ not a palindrome.
If pointers meet with no mismatches â†’ palindrome.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Initialize Two Pointers

Set:

L = 0 (start of the string)

R = len(word) âˆ’ 1 (end of the string)

Step 2 â€” Compare Characters

While L < R:

If word[L] == word[R] â†’ good, keep moving toward the middle

If they differ â†’ instantly return false

Step 3 â€” Move Pointers

After each comparison:

Increment L

Decrement R

This gradually checks symmetrical positions.

Step 4 â€” Reaching the Middle

If the loop completes without finding a mismatch â†’
The string is a palindrome â†’ return true

ğŸ§  Mental Picture

Imagine folding a string from both ends toward the center.
If all mirrored characters match perfectly â†’ palindrome.

Example:

racecar
L-----R (r == r)
 L---R  (a == a)
  L-R   (c == c)
   center

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only scans the string once, using constant memory.

ğŸ‘‰ Problem 2: Two Numbers Sum to Target (In Sorted Array)

Find two numbers in a sorted list that add up to a given target.

You are given:

nums â†’ a sorted array of integers

target â†’ the required sum

You must return:

The indices of the two numbers (L, R) that add up to the target

There is guaranteed exactly one solution

âœ¨ Key Idea

Use the two-pointer technique on the sorted array.

Because it's sorted:

If the sum is too big â†’ move the right pointer left

If the sum is too small â†’ move the left pointer right

If the sum matches â†’ done!

âœ¨ Flashcard

â€œUse two pointers on sorted array.
If sum too big â†’ move R left.
If sum too small â†’ move L right.
When sum matches â†’ return [L, R].â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with Two Pointers

Set:

L = 0 (start of the array)

R = len(nums) âˆ’ 1 (end of the array)

Step 2 â€” Check the Sum of nums[L] + nums[R]

Three cases:

Sum > target
The right value is too large
â†’ Move R left

Sum < target
The left value is too small
â†’ Move L right

Sum == target
Perfect match
â†’ Return [L, R]

Step 3 â€” Repeat Until They Meet

Pointers move inward until the sum is found.

ğŸ§  Mental Picture

You're looking at a scale:

small ......... big
 L           R


If the total is too heavy â†’ shift right pointer left.
If too light â†’ shift left pointer right.

Eventually, the balance matches the target.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Just a single pass through the array.

ğŸ‘‰ Prefix Sum â€“ Range Sum Query (O(1) per query)

1ï¸âƒ£ Prefix Sum Technique

(Preprocessing O(n), Query O(1))

âœ… Key Idea

Store cumulative sums so any subarray sum can be computed using subtraction instead of re-summing elements.

âœ¨ Flashcard

"Precompute sums once â†’ subtract boundaries â†’ get range sum instantly."

âš¡ Full Approach

Steps:

Initialize an empty array prefix.

Set a variable total = 0.

Traverse the input array from left to right:

Add the current element to total.

Append total to the prefix array.

To answer a range sum query (left, right):

Take prefix[right] as the sum from index 0 to right.

If left > 0, subtract prefix[left âˆ’ 1].

If left == 0, subtract 0.

The result is the sum of elements from index left to right.

â±ï¸ Complexity

Preprocessing Time: O(n)

Query Time: O(1)

Space: O(n)

âœ… Notes

Ideal when multiple range sum queries are needed.

Simple logic, very fast queries.

Not suitable if the array is frequently updated.

Commonly used in interviews and competitive programming.



ğŸ‘‰ Floydâ€™s Tortoise and Hare

Detect cycles, find middle, or locate cycle start in a linked list using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs. Meet? â†’ cycle exists. Rewind slow â†’ start of cycle.â€

âš¡ Full Explanation (Very Easy)

1. Find the middle of a linked list

Goal
Find the middle node of a linked list efficiently.

ğŸ” How the code works (Line-by-Line)

Initialize pointers

slow, fast = head, head


slow â†’ moves 1 step at a time

fast â†’ moves 2 steps at a time

Traverse until fast reaches the end

while fast and fast.next:
    slow = slow.next
    fast = fast.next.next


Fast moves twice as fast â†’ when fast hits the end, slow is in the middle.

Return slow

return slow


Middle node found!

ğŸ§  Mental Map
â€œFast pointer finishes first â†’ slow pointer is middle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

2. Detect if a cycle exists

Goal
Check if the linked list loops back on itself.

ğŸ” How the code works (Line-by-Line)

Initialize slow & fast

slow, fast = head, head


Traverse

while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        return True


Fast catches up with slow inside the cycle â†’ cycle exists

If no meeting

return False


Fast reaches the end â†’ no cycle

ğŸ§  Mental Map
â€œTwo runners. Meet? â†’ cycle. Reach end? â†’ no cycle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

3. Find the start of the cycle

Goal
Return the first node of the cycle, if it exists.

ğŸ” How the code works (Line-by-Line)

Initialize pointers and detect meeting

slow, fast = head, head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        break


First meeting point inside the cycle

Check if no cycle

if not fast or not fast.next:
    return None


Find cycle start

slow2 = head
while slow != slow2:
    slow = slow.next
    slow2 = slow2.next
return slow


Move slow from meeting & slow2 from head one step at a time

They meet at the start of the cycle

ğŸ§  Mental Map
â€œRewind slow to head. Both walk 1 step â†’ meet at cycle start.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

ğŸ‘‰ Trie (Prefix Tree)

Store words efficiently and answer search and prefix queries by sharing common letter paths.

âœ¨ Flashcard

â€œLetters form paths.
Only some nodes are word endings.
Prefix â‰  word.â€

âš¡ Full Explanation (Very Easy)
1. Inserting a word
ğŸ¯ Goal

Store a word letter by letter while reusing common prefixes.

ğŸ” How it works

â€¢ Start from the root (empty node)
â€¢ Move through each letter in order
â€¢ If a letter path doesnâ€™t exist â†’ create it
â€¢ Move forward until the last letter

âš¡ At the last letter, mark:

â€œA complete word ends here.â€

This is what the word flag represents.

ğŸ§  Mental Map

â€œWalk letters â†’ stop â†’ stamp END OF WORD.â€

2. Searching for a word
ğŸ¯ Goal

Confirm whether a full word exists â€” not just a prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Follow the path of each letter
â€¢ If any letter is missing â†’ word does not exist
â€¢ After the final letter, check:

âš¡ Is this node marked as a word end?

âœ” Yes â†’ valid word
âŒ No â†’ only a prefix

ğŸ§  Mental Map

â€œPath exists + word-end stamp â†’ word found.â€

3. Checking a prefix (startsWith)
ğŸ¯ Goal

Check whether any word starts with this prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Walk through prefix letters
â€¢ If all letters exist in sequence â†’ prefix exists

ğŸš« No need to check word ending

ğŸ§  Mental Map

â€œPrefix only needs a path, not a destination.â€

â­ Why the word flag is CRITICAL

Imagine storing:

â€¢ car
â€¢ cat

Both share the path: c â†’ a

But:

â€¢ car ends at r
â€¢ cat ends at t

Without a word-ending marker:
âŒ The Trie cannot tell whether â€œcaâ€ is a word or just a prefix.

ğŸ‘‰ The word flag answers one question only:

â€œDoes a complete word stop here?â€

ğŸ“¦ Complexity

â€¢ Time per operation: linear in word length
â€¢ Extra space: only for new letters

ğŸ§  One-Line Intuition

â€œTrie remembers paths.
word = True remembers when to stop.â€

ğŸ‘‰ Union-Find (Disjoint Set Union - DSU)

Efficiently track connected components and merge groups while keeping everything fast and balanced.

âœ¨ Flashcard

â€œEach node points upward.
Root = group leader.
Flatten while climbing.
Attach small under big.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Initialization

ğŸ¯ Goal

Start with n separate nodes â€” each in its own group.

ğŸ” How it works

â€¢ Every node begins as its own parent
â€¢ Every node starts with height (rank) = 0

So initially:

1   2   3   4
â†‘   â†‘   â†‘   â†‘


Everyone is their own leader.

ğŸ§  Mental Map

â€œEveryone starts alone.â€

2ï¸âƒ£ Finding a Leader (Find Operation)

ğŸ¯ Goal

Figure out which group a node belongs to.

ğŸ” How it works

â€¢ Start from the node
â€¢ Move upward through parents
â€¢ Stop when you reach a node that points to itself

That node is the root (leader).

âš¡ Path Compression (The Speed Trick)

While climbing:

â€¢ Make each node skip its parent
â€¢ Point it closer to the root

This flattens the structure.

Instead of:

1 â†’ 2 â†’ 3 â†’ 4


It gradually becomes:

1 â†’ 4
2 â†’ 4
3 â†’ 4


Future searches become extremely fast.

ğŸ§  Mental Map

â€œClimb to the leader.
Shorten the ladder while climbing.â€

3ï¸âƒ£ Merging Two Groups (Union Operation)

ğŸ¯ Goal

Combine two different groups into one.

ğŸ” How it works

â€¢ Find the leader of node A
â€¢ Find the leader of node B
â€¢ If same leader â†’ already connected
â€¢ If different â†’ attach one tree under the other

âš¡ Union by Rank (Balance Control)

To prevent long chains:

â€¢ Attach smaller-height tree under taller tree
â€¢ If same height â†’ attach one and increase height by 1

This keeps trees shallow.

ğŸ§  Mental Map

â€œSmall tree goes under big tree.â€

â­ Why Rank + Path Compression Together Are Powerful

Without them:

1 â†’ 2 â†’ 3 â†’ 4 â†’ 5


Find becomes slow.

With both optimizations:

Tree becomes flat.

Each operation becomes almost constant time.

ğŸ“¦ Complexity

â€¢ Each operation â‰ˆ O(1) in practice
â€¢ More precisely: O(Î±(n))
(Inverse Ackermann â€” grows so slowly it's basically constant)

ğŸš€ When Is Union-Find Used?

Union-Find is used when you need to:

1ï¸âƒ£ Detect Cycles in Graphs

If connecting two nodes that already have the same leader â†’ cycle detected.

Common in:
â€¢ Undirected graph cycle detection
â€¢ Kruskalâ€™s Minimum Spanning Tree

2ï¸âƒ£ Find Number of Connected Components

Example:
â€¢ Number of provinces
â€¢ Number of friend circles
â€¢ Network connectivity problems

3ï¸âƒ£ Dynamic Connectivity Problems

When connections are added over time and you must quickly check:

â€œAre these two nodes connected?â€

4ï¸âƒ£ Kruskalâ€™s Algorithm (Minimum Spanning Tree)

Before adding an edge:
â€¢ Check if it forms a cycle
â€¢ If not â†’ union them

5ï¸âƒ£ Grid Problems

Examples:
â€¢ Number of islands
â€¢ Surrounded regions
â€¢ Accounts merge
â€¢ Redundant connection

ğŸ§  One-Line Intuition

â€œUnion-Find remembers groups.
Find tells you the leader.
Union merges leaders efficiently.â€

ğŸ‘‰ Segment Tree - Node Based

Efficiently handle range queries + point updates in logarithmic time.

Perfect when:

You need many range sums

And values change over time

âœ¨ Flashcard

â€œSplit range in half.
Store sum at each node.
Update one leaf.
Fix sums while returning.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal

Store array information in a tree so queries become fast.

ğŸ” How it works

Each node stores:

sum â†’ total of its range

L, R â†’ range it represents

left, right â†’ children

If array is:

[2, 4, 5, 7]


Tree looks like:

            [0-3]
           sum=18
          /      \
      [0-1]      [2-3]
      sum=6      sum=12
      /   \      /    \
   [0]   [1]   [2]    [3]
    2     4     5      7


ğŸ§  Mental Map

â€œEach node owns a range.â€

2ï¸âƒ£ Building the Tree (build) â€” O(n)
@staticmethod
def build(nums, L, R):


ğŸ¯ Goal

Construct the full tree from the array.

ğŸ” How it works

â€¢ If L == R â†’ leaf node
â€¢ Otherwise:

Split range in half

Build left child

Build right child

Sum = left.sum + right.sum

Key idea:

Build children first
Then compute parent


ğŸ§  Mental Map

â€œDivide range.
Build children.
Combine results.â€

â“ Why is build a static method?

Because:

â€¢ It does NOT use self
â€¢ Tree does not exist yet
â€¢ It creates and returns the first node

So it belongs to the class,
but doesnâ€™t depend on an object.

Think:

â€œFactory method to create tree.â€

3ï¸âƒ£ Update Operation â€” O(log n)
def update(self, index, val):


ğŸ¯ Goal

Change one value in the array.

ğŸ” How it works

â€¢ Move down to the correct leaf
â€¢ Update its value
â€¢ While returning back:

Recalculate parent sums

Only one path from root â†’ leaf is visited.

If tree height is log n â†’ time is log n.

ğŸ§  Mental Map

â€œGo to the leaf.
Fix sums while climbing back.â€

4ï¸âƒ£ Range Query â€” O(log n)
def rangeQuery(self, L, R):


ğŸ¯ Goal

Return sum of any subarray.

ğŸ” How it works

Three cases:

1ï¸âƒ£ Exact match â†’ return sum immediately
2ï¸âƒ£ Entirely left â†’ go left
3ï¸âƒ£ Entirely right â†’ go right
4ï¸âƒ£ Split across middle â†’ query both sides

We only visit relevant branches.

ğŸ§  Mental Map

â€œOnly walk where the range overlaps.â€

â­ Why Segment Tree Is Powerful

Without it:

Range sum â†’ O(n)
Update â†’ O(1)

With it:

Range sum â†’ O(log n)
Update â†’ O(log n)

Best when both operations are frequent.

ğŸ“¦ Complexity

â€¢ Build â†’ O(n)
â€¢ Update â†’ O(log n)
â€¢ Range Query â†’ O(log n)
â€¢ Space â†’ O(n)

ğŸš€ When Is Segment Tree Used?

1ï¸âƒ£ Range Sum Queries
2ï¸âƒ£ Range Minimum / Maximum
3ï¸âƒ£ Dynamic array problems
4ï¸âƒ£ Competitive programming
5ï¸âƒ£ Any problem with:

Many updates

Many range queries

ğŸ§  One-Line Intuition

â€œBreak array into ranges.
Store partial sums.
Touch only needed pieces.â€

ğŸ‘‰ Segment Tree â€“ Array Based

Efficiently handle range queries + point updates in logarithmic time.

Perfect when:

You want fast range max, min, or sum queries

Array values change over time

You donâ€™t want the overhead of objects

âœ¨ Flashcard

â€œStore ranges in an array.
Update a leaf.
Propagate changes.
Query a range recursively.â€

âš¡ Full Explanation (Very Easy)
1ï¸âƒ£ Structure

ğŸ¯ Goal:
Store array information in a binary tree using an array to make queries and updates fast.

ğŸ” How it works:

tree â†’ array representing segment tree nodes

size â†’ maximum number of elements / range size

Leaf nodes â†’ represent actual array values

Parent nodes â†’ store aggregate function (max, sum, min) of children

Example array: [2, 4, 5, 7]
Array-based tree structure (conceptual):

Node array indices: [1,2,3,4,...]
tree[1] = root = max or sum of full range
tree[2] = left child
tree[3] = right child
...
Leaf nodes store actual values


ğŸ§  Mental Map:
â€œEach node stores aggregate info about a range.â€

2ï¸âƒ£ Build / Initialization â€” O(n)
self.tree = [default] * (4*size)


ğŸ¯ Goal:
Initialize a segment tree array to store all ranges.

ğŸ” How it works:

4*size â†’ ensures enough space for all nodes

Leaves â†’ store values of the original array

Parents â†’ store aggregate (max, sum, etc.)

ğŸ§  Mental Map:
â€œReserve space for all ranges, even if tree is not perfect.â€

â“ Why 4*size?

Worst-case full binary tree may require up to 4*n nodes

Safe, simple rule to prevent overflow

3ï¸âƒ£ Update Operation â€” O(log n)
def update(self, index, value, node=1, start=1, end=None):


ğŸ¯ Goal:
Update one value in the array and reflect changes in all relevant ranges.

ğŸ” How it works:

Go down recursively to the leaf representing index

Update the leaf value

While returning back, update parent nodes:

tree[node] = func(tree[2*node], tree[2*node+1])


Only the path from root â†’ leaf is touched â†’ O(log n)

ğŸ§  Mental Map:
â€œGo to the leaf. Fix all parents while climbing back.â€

4ï¸âƒ£ Range Query â€” O(log n)
def query(self, left, right, node=1, start=1, end=None):


ğŸ¯ Goal:
Return aggregate value (max, sum, min) in the range [left, right].

ğŸ” How it works:

Three cases:

No overlap â†’ return default (0 for sum/max, inf for min)

Total overlap â†’ return tree[node]

Partial overlap â†’ query left and right children and combine

Recursion ensures only relevant branches are visited

ğŸ§  Mental Map:
â€œOnly walk down ranges that overlap with the query.â€

â­ Why Array-Based Segment Tree Is Powerful

Without it:

Operation	Time
Range query	O(n)
Update value	O(1)

With it:

Operation	Time
Range query	O(log n)
Update value	O(log n)

Best when:

Many updates + many queries

ğŸ“¦ Complexity

Build / init â†’ O(n)

Update â†’ O(log n)

Range query â†’ O(log n)

Space â†’ O(4*n)

ğŸš€ When to Use Array-Based Segment Tree

Range Sum Queries

Range Maximum / Minimum

Dynamic array problems

Competitive programming

Problems with many updates + many range queries

ğŸ§  One-Line Intuition

â€œBreak array into ranges. Store partial results in an array. Touch only the ranges you need.â€

ğŸ‘‰ Two Heaps â€“ Running Median (Median in Data Stream)

Efficiently maintain median while numbers are inserted dynamically.

Perfect when:

You need median after every insertion

Numbers come in a stream

Sorting every time is too slow

âœ¨ Flashcard

â€œSplit into two halves.
Max heap â†’ left side.
Min heap â†’ right side.
Balance sizes.
Median is at the top.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal:
Keep smaller half and larger half separated so median is always accessible fast.

ğŸ” How it works:

self.small â†’ Max Heap â†’ stores smaller half
self.large â†’ Min Heap â†’ stores larger half

Python has only min heap â†’ so max heap is simulated using negative values.

Example stream:
[5, 2, 10, 4]

Heaps become:

small (max heap) â†’ [4, 2]
large (min heap) â†’ [5, 10]

ğŸ§  Mental Map:
â€œLeft heap â†’ smaller numbers
Right heap â†’ larger numbers
Median sits at the boundaryâ€

2ï¸âƒ£ Insert Operation â€” O(log n)
heapq.heappush(self.small, -1 * num)


ğŸ¯ Goal:
Insert number into correct half.

ğŸ” How it works:

Step 1: Always push into small (max heap)

Why?

Because easier to move from small â†’ large if needed.

Step 2: Fix order property
if (-1 * self.small[0]) > self.large[0]:


ğŸ¯ Meaning:

Largest of small > smallest of large â†’ WRONG order

So swap

Example:

small â†’ [10]
large â†’ [5]

Wrong â†’ move 10 to large

ğŸ§  Mental Map:
â€œLeft side must always be â‰¤ Right sideâ€

Step 3: Balance sizes
if len(self.small) > len(self.large) + 1:


ğŸ¯ Goal:

Heaps size difference must not exceed 1

Why?

Because median must stay in middle

Balance by moving root between heaps

ğŸ§  Mental Map:
â€œHeaps must stay equal heightâ€

3ï¸âƒ£ Get Median â€” O(1)
def getMedian(self):


ğŸ¯ Goal:
Return middle value

Case 1: small bigger

Example:
[2,4,5]

Median = top of small

return -self.small[0]

Case 2: large bigger

Example:
[2,4,5]

Median = top of large

return self.large[0]

Case 3: equal size

Example:
[2,4,5,10]

Median = average of two middles

return (left + right) / 2


ğŸ§  Mental Map:
â€œMedian is either one top, or average of two topsâ€

â­ Why Two Heaps Is Powerful

Without it:

Operation Time
Insert O(n)
Median O(1)

With sorting every time â†’ O(n log n)

With Two Heaps:

Operation Time
Insert O(log n)
Median O(1)

Best for streaming data

ğŸ“¦ Complexity

Insert â†’ O(log n)

Get Median â†’ O(1)

Space â†’ O(n)

ğŸš€ When to Use Two Heaps

Median in data stream

Running median problems

Sliding window median

Priority based partition problems

LeetCode:

Find Median from Data Stream

Sliding Window Median

ğŸ§  One-Line Intuition

â€œKeep smaller half left, larger half right, median always on top.â€

ğŸ‘‰ Backtracking â€“ Generate All Subsets (Power Set)

Efficiently generate all possible subsets using recursion and decisions.

Perfect when:

You need all combinations

Each element has two choices â†’ include or exclude

Order doesnâ€™t matter

Duplicates may or may not exist

âœ¨ Flashcard

â€œEvery element â†’ two choices.
Include it.
Or skip it.
Recursively explore both.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal:

Generate all subsets of a list.

Example:

Input:
[1,2]

Output:
[], [1], [2], [1,2]

ğŸ” Core Idea:

Each element has 2 choices

Include
Exclude

So total subsets:

2â¿

ğŸ§  Mental Map:

            []
        /        \
      [1]        []
     /   \      /   \
 [1,2]  [1]  [2]    []


Decision Tree

Each level â†’ decision point

2ï¸âƒ£ Core Variables
subsets â†’ final result

curSet â†’ current subset being built

i â†’ current index


ğŸ§  Mental Map:

subsets â†’ storage box

curSet â†’ subset under construction

i â†’ current element position

3ï¸âƒ£ Base Case

Code:

if i >= len(nums):
    subsets.append(curSet.copy())
    return


ğŸ¯ Goal:

When all elements processed â†’ store result

âš ï¸ Why copy?

Because curSet changes later

Without copy â†’ all results same

ğŸ§  Mental Map:

â€œReached leaf â†’ save subsetâ€

4ï¸âƒ£ Include Decision

Code:

curSet.append(nums[i])
helper(i + 1, nums, curSet, subsets)
curSet.pop()


ğŸ¯ Goal:

Choose current element

Step-by-step:

Add element

Explore further

Remove element (BACKTRACK)

Example:

nums = [1,2]

curSet = []

Include 1 â†’ [1]

Include 2 â†’ [1,2]

ğŸ§  Mental Map:

â€œChoose â†’ Explore â†’ Undoâ€

This is Backtracking

5ï¸âƒ£ Exclude Decision

Code:

helper(i + 1, nums, curSet, subsets)


ğŸ¯ Goal:

Skip current element

Example:

Skip 1 â†’ []

Include 2 â†’ [2]

ğŸ§  Mental Map:

â€œSkip and exploreâ€

6ï¸âƒ£ Full Flow Example

Input:

[1,2]

Execution:

Start []

Include 1 â†’ [1]

Include 2 â†’ [1,2] â†’ save

Exclude 2 â†’ [1] â†’ save

Backtrack

Exclude 1 â†’ []

Include 2 â†’ [2] â†’ save

Exclude 2 â†’ [] â†’ save


Final:

[]
[1]
[2]
[1,2]


â­ Why Backtracking Is Powerful

Because it explores:

All possibilities

Without storing full tree

Memory efficient

7ï¸âƒ£ Handling Duplicates Version

Function:

subsetsWithDuplicates(nums)


ğŸ¯ Problem:

Input:

[1,2,2]

Normal solution gives duplicate subsets:

[2] appears twice

WRONG

8ï¸âƒ£ Solution: Skip Duplicates

Code:

while i + 1 < len(nums) and nums[i] == nums[i + 1]:
    i += 1


ğŸ¯ Meaning:

Skip duplicate elements

Example:

[2,2,2]

Skip extra copies

Only process once

ğŸ§  Mental Map:

â€œSkip identical twinsâ€

9ï¸âƒ£ Why Sorting Is Required

Code:

nums.sort()


ğŸ¯ Goal:

Bring duplicates together

Example:

[2,1,2]

Becomes:

[1,2,2]

Now easy to skip

ğŸ§  Mental Map:

â€œSort â†’ detect duplicates easilyâ€

10ï¸âƒ£ Visual Example with Duplicates

Input:

[1,2,2]

Tree:

            []
        /         \
      [1]         []
     /   \       /   \
 [1,2]  [1]   [2]   []
   |
 [1,2,2]


Duplicates skipped properly

ğŸ“¦ Complexity

Time â†’ O(n Ã— 2â¿)

Why?

2â¿ subsets

Each copy takes O(n)

Space â†’ O(n)

Recursion depth

ğŸš€ When to Use Backtracking Subsets

Power set problems

Combination problems

Decision problems

Include-exclude problems

LeetCode:

Subsets

Subsets II

Combination Sum

Permutations

ğŸ§  One-Line Intuition

â€œEvery element â†’ include or skip â†’ explore both recursively.â€


ğŸ‘‰ Backtracking â€“ Generate Combinations (n Choose k)

Efficiently generate all combinations of size k from numbers 1 to n using recursion and decisions.

Perfect when:

You need fixed-size combinations

Order doesnâ€™t matter

Each number has two choices â†’ include or skip

Classic nCk problem

âœ¨ Flashcard

â€œEach number â†’ include or skip.
Stop when combination size = k.â€

âš¡ Full Explanation (Very Easy)

1ï¸âƒ£ Structure

ğŸ¯ Goal:

Generate all combinations of size k from numbers 1 to n.

Example:

Input:

n = 4, k = 2

Output:

[1,2]
[1,3]
[1,4]
[2,3]
[2,4]
[3,4]

ğŸ” Core Idea:

Each number has 2 choices:

Include
Exclude

But stop early when size = k

ğŸ§  Mental Map:

Start []

Include 1 â†’ [1]
    Include 2 â†’ [1,2] âœ…
    Skip 2 â†’ Include 3 â†’ [1,3] âœ…
    Skip 3 â†’ Include 4 â†’ [1,4] âœ…

Skip 1 â†’ Include 2 â†’ [2]
    Include 3 â†’ [2,3] âœ…
    Include 4 â†’ [2,4] âœ…

Skip 2 â†’ Include 3 â†’ [3]
    Include 4 â†’ [3,4] âœ…


Decision Tree

2ï¸âƒ£ Core Variables
combs â†’ final result

curComb â†’ current combination

i â†’ current number


ğŸ§  Mental Map:

combs â†’ storage box

curComb â†’ combination under construction

i â†’ current number

3ï¸âƒ£ Base Case

Code:

if len(curComb) == k:
    combs.append(curComb.copy())
    return


ğŸ¯ Goal:

Combination complete â†’ store result

âš ï¸ Why copy?

Because curComb will change later

ğŸ§  Mental Map:

â€œCombination ready â†’ save itâ€

4ï¸âƒ£ Include Decision

Code:

curComb.append(i)
helper(i + 1, curComb, combs, n, k)
curComb.pop()


ğŸ¯ Goal:

Choose current number

Step-by-step:

Add number

Explore further

Remove number (BACKTRACK)

Example:

curComb = []

Include 1 â†’ [1]

Include 2 â†’ [1,2] âœ…

ğŸ§  Mental Map:

â€œChoose â†’ Explore â†’ Undoâ€

5ï¸âƒ£ Exclude Decision

Code:

helper(i + 1, curComb, combs, n, k)


ğŸ¯ Goal:

Skip current number

Example:

Skip 1 â†’ try combinations starting from 2

ğŸ§  Mental Map:

â€œSkip and explore nextâ€

6ï¸âƒ£ Stop Condition

Code:

if i > n:
    return


ğŸ¯ Goal:

No more numbers left

Stop recursion

ğŸ§  Mental Map:

â€œOut of numbers â†’ stopâ€

7ï¸âƒ£ Full Flow Example

Input:

n = 3, k = 2

Execution:

Start []

Include 1 â†’ [1]

Include 2 â†’ [1,2] âœ…

Backtrack

Include 3 â†’ [1,3] âœ…

Backtrack

Skip 1

Include 2 â†’ [2]

Include 3 â†’ [2,3] âœ…

Final:

[1,2]
[1,3]
[2,3]

â­ Why Backtracking Is Powerful

Because it explores:

Only valid combinations

Avoids unnecessary storage

Memory efficient

8ï¸âƒ£ Optimized Version (FOR LOOP Template)

Function:

helper2()


Code:

for j in range(i, n + 1):
    curComb.append(j)
    helper2(j + 1, curComb, combs, n, k)
    curComb.pop()


ğŸ¯ Why this is faster?

It avoids unnecessary exclude calls

Directly tries next possible number

ğŸ§  Mental Map:

â€œPick next available numberâ€

Visual:

[]
â”œâ”€â”€ [1]
â”‚   â”œâ”€â”€ [1,2]
â”‚   â”œâ”€â”€ [1,3]
â”‚   â””â”€â”€ [1,4]
â”œâ”€â”€ [2]
â”‚   â”œâ”€â”€ [2,3]
â”‚   â””â”€â”€ [2,4]
â””â”€â”€ [3]
    â””â”€â”€ [3,4]


Cleaner tree

9ï¸âƒ£ Why FOR LOOP Version Is Better

Because:

Avoids useless recursion

More efficient

Most used in interviews

Comparison:

Include/Exclude â†’ slower
For loop â†’ faster âœ…

ğŸ“¦ Complexity

Include/Exclude version:

Time â†’ O(k Ã— 2â¿)

FOR LOOP version:

Time â†’ O(k Ã— C(n,k))

Space â†’ O(k)

ğŸš€ When to Use This Pattern

Combination problems

Fixed-size subset problems

nCk problems

LeetCode:

Combinations (77)

Combination Sum

Subsets

Permutations

ğŸ§  One-Line Intuition

â€œBuild combination step-by-step and stop when size reaches k.â€