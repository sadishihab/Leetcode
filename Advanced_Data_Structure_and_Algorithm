ğŸ‘‰ (Maximum Subarray â€“ Three Approaches)
1ï¸âƒ£ Brute Force â€“ O(nÂ²)
âœ… Key Idea

Try every possible subarray and keep track of the largest sum.

At each index i, extend the subarray to the right (j) and accumulate the sum.

âœ¨ Flashcard:
"Pick a start â†’ extend right â†’ update max â†’ repeat for all starts."

âš¡ Full Approach
Steps:

Initialize maxSum to the first element.

Loop i from 0 to nâˆ’1 (start of subarray).

Set curSum = 0 for each new starting point.

Loop j from i to nâˆ’1 (extend the subarray).

Add nums[j] to curSum.

Update maxSum = max(maxSum, curSum).

After checking all subarrays â†’ return maxSum.

â±ï¸ Complexity

Time: O(nÂ²) â€” every (i, j) pair is checked.
Space: O(1) â€” uses constant extra space.

âœ… Notes

Very easy to understand.

Very slow for big inputs.

Good as a baseline, bad in interviews for large arrays.

2ï¸âƒ£ Kadaneâ€™s Algorithm â€“ O(n)
âœ… Key Idea

Walk through the array and maintain a running sum.
If the running sum becomes negative, drop it (reset to 0).

âœ¨ Flashcard:
"If current sum < 0 â†’ reset. Add each number and keep max."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Loop through each number n in nums:

If curSum is negative, reset it: curSum = max(curSum, 0)

Add current number: curSum += n

Update best: maxSum = max(maxSum, curSum)

Return maxSum.

â±ï¸ Complexity

Time: O(n) â€” single pass.
Space: O(1).

âœ… Notes

Works even when array contains negative numbers.

Extremely efficient.

Most common interview solution.

3ï¸âƒ£ Sliding Window Variant of Kadane â€” O(n), with indices
âœ… Key Idea

Same as Kadane, but also track where the max subarray starts and ends.

âœ¨ Flashcard:
"Reset window when sum < 0. Expand right. Update best window when new max is found."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Track indices:

L = current window start

maxL, maxR = best window

For each R in range(len(nums)):

If curSum < 0:

reset curSum = 0

move L = R (new window start)

Add current number: curSum += nums[R]

If curSum beats maxSum:

update maxSum

update maxL, maxR = L, R

Return [maxL, maxR].

â±ï¸ Complexity

Time: O(n)
Space: O(1)

âœ… Notes

Same speed as Kadane.

But it also gives the start and end indices of the best subarray.

Very useful when we need the actual slice of the array.


ğŸ§  First: The Thinking Method & Mental Map

All three functions solve Maximum Subarray Sum (LeetCode 53):
Find a subarray (continuous part) that gives the biggest sum.

1. Brute Force â€“ Thinking Method (Try Everything)

Mental Map:
Imagine pointing at each index i.
Then from that i, extend a window to the right step-by-step (j).
For every possible slice, compute the sum.
Keep track of the biggest one.

ğŸ‘‰ This is like checking all possible subarrays.

2. Kadaneâ€™s Algorithm â€“ Thinking Method (Smart skipping)

Mental Map:
Walk through the array once.
Keep a running sum (curSum).
If the running sum becomes negative, drop it.
Because a negative sum will only pull future sums down.
Always update the best result (maxSum).

ğŸ‘‰ This is like saying:
â€œIf what I have so far is harmful (negative), I'll start over.â€

3. Sliding Window Variation â€“ Thinking Method (Kadane + indices)

Kadane normally returns only the sum.
This version also returns left and right indices of the best subarray.

Mental Map:
Still reset curSum when it becomes negative.
At the moment you reset, the new potential start index = R.

Any time you find a new maxSum, record:
The current start (L)

The current end (R)

ğŸ‘‰ It tracks where the best window starts and ends.

