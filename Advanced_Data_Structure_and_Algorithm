ğŸ‘‰ (Maximum Subarray â€“ Three Approaches)
1ï¸âƒ£ Brute Force â€“ O(nÂ²)
âœ… Key Idea

Try every possible subarray and keep track of the largest sum.

At each index i, extend the subarray to the right (j) and accumulate the sum.

âœ¨ Flashcard:
"Pick a start â†’ extend right â†’ update max â†’ repeat for all starts."

âš¡ Full Approach
Steps:

Initialize maxSum to the first element.

Loop i from 0 to nâˆ’1 (start of subarray).

Set curSum = 0 for each new starting point.

Loop j from i to nâˆ’1 (extend the subarray).

Add nums[j] to curSum.

Update maxSum = max(maxSum, curSum).

After checking all subarrays â†’ return maxSum.

â±ï¸ Complexity

Time: O(nÂ²) â€” every (i, j) pair is checked.
Space: O(1) â€” uses constant extra space.

âœ… Notes

Very easy to understand.

Very slow for big inputs.

Good as a baseline, bad in interviews for large arrays.

2ï¸âƒ£ Kadaneâ€™s Algorithm â€“ O(n)
âœ… Key Idea

Walk through the array and maintain a running sum.
If the running sum becomes negative, drop it (reset to 0).

âœ¨ Flashcard:
"If current sum < 0 â†’ reset. Add each number and keep max."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Loop through each number n in nums:

If curSum is negative, reset it: curSum = max(curSum, 0)

Add current number: curSum += n

Update best: maxSum = max(maxSum, curSum)

Return maxSum.

â±ï¸ Complexity

Time: O(n) â€” single pass.
Space: O(1).

âœ… Notes

Works even when array contains negative numbers.

Extremely efficient.

Most common interview solution.

3ï¸âƒ£ Sliding Window Variant of Kadane â€” O(n), with indices
âœ… Key Idea

Same as Kadane, but also track where the max subarray starts and ends.

âœ¨ Flashcard:
"Reset window when sum < 0. Expand right. Update best window when new max is found."

âš¡ Full Approach
Steps:

maxSum = nums[0]

curSum = 0

Track indices:

L = current window start

maxL, maxR = best window

For each R in range(len(nums)):

If curSum < 0:

reset curSum = 0

move L = R (new window start)

Add current number: curSum += nums[R]

If curSum beats maxSum:

update maxSum

update maxL, maxR = L, R

Return [maxL, maxR].

â±ï¸ Complexity

Time: O(n)
Space: O(1)

âœ… Notes

Same speed as Kadane.

But it also gives the start and end indices of the best subarray.

Very useful when we need the actual slice of the array.


ğŸ§  First: The Thinking Method & Mental Map

All three functions solve Maximum Subarray Sum (LeetCode 53):
Find a subarray (continuous part) that gives the biggest sum.

1. Brute Force â€“ Thinking Method (Try Everything)

Mental Map:
Imagine pointing at each index i.
Then from that i, extend a window to the right step-by-step (j).
For every possible slice, compute the sum.
Keep track of the biggest one.

âš¡ This is like checking all possible subarrays.

2. Kadaneâ€™s Algorithm â€“ Thinking Method (Smart skipping)

Mental Map:
Walk through the array once.
Keep a running sum (curSum).
If the running sum becomes negative, drop it.
Because a negative sum will only pull future sums down.
Always update the best result (maxSum).

âš¡ This is like saying:
â€œIf what I have so far is harmful (negative), I'll start over.â€

3. Sliding Window Variation â€“ Thinking Method (Kadane + indices)

Kadane normally returns only the sum.
This version also returns left and right indices of the best subarray.

Mental Map:
Still reset curSum when it becomes negative.
At the moment you reset, the new potential start index = R.

Any time you find a new maxSum, record:
The current start (L)

The current end (R)

âš¡ It tracks where the best window starts and ends.


ğŸ‘‰ Problem - Sliding WIndow Fixed (sliding_window_fixed.py)

Check if the array has two equal numbers that are close to each other â€”
specifically, their indices differ by less than k.

Example:
If k = 3, then valid pairs are within 3 steps:
(L, L+1), (L, L+2)

âœ¨ Flashcard

â€œFix left. Check next k positions: any match? â†’ True.â€

âš¡ Full Explanation (Very Easy)
Goal

We are trying to find two identical values such that:

indices are close (difference < k)

ğŸ” How the code works (Line-by-Line)
1. Outer loop â†’ pick a starting index L
for L in range(len(nums)):


Think of L as the left pointer.
We will check if nums[L] has a matching twin nearby.

2. Inner loop â†’ look ahead up to k positions
for R in range(L + 1, min(len(nums), L + k)):


Start from the next position L+1

Look forward only up to k steps (not the whole array)

Stop early if the array ends

So this checks only the close neighbors.

3. Compare values at L and R
if nums[L] == nums[R]:
    return True


If we find any match within k steps â†’ answer is True.

Example:
If L = 2 and nums[2] == nums[4], and 4 - 2 < k, then return True.

4. If loops finish with no match
return False


Means:
â€œNo two close duplicates exist.â€

ğŸ§  Mental Map (Very Simple)

Pick a number.

Look at the next k numbers only.

If any of them is the same â†’ found!

If after checking all positions â†’ none found, return False.

ğŸ“¦ Complexity

Time: O(n Ã— k) because for every element, we look ahead up to k positions

Space: O(1)

ğŸ‘‰ Same problem using sliding window and Hash Set. O(n)
Goal:
ğŸŒŸ When scanning the array, always keep a window of the last k elements.
If the current number is already inside the window â†’ itâ€™s a duplicate within k distance.

âœ¨ Flashcard

â€œKeep last k elements in a set.
If current value is already inside â†’ close duplicate found.â€

âš¡ Full Explanation (Line-by-Line & Super Easy)
1. Create a window as a SET
window = set()
L = 0


window stores the last k elements weâ€™ve seen.

L is the left boundary of the sliding window.

Set is used because lookup is O(1) and perfect for checking duplicates.

2. Loop R from left to right (right boundary)
for R in range(len(nums)):


We move R across the array.

At each R, we check nums[R] with the window.

3. Make sure window size never exceeds k
if R - L + 1 > k:
    window.remove(nums[L])
    L += 1


Explanation:

The window length is (R - L + 1)

If it becomes bigger than k, we must â€œshrinkâ€ it

Remove the leftmost value (nums[L]) from the set

Move L right by 1

This guarantees the window always contains only the last k elements.

4. Check for close duplicate
if nums[R] in window:
    return True


If current value already exists in the window â†’
It means we found a duplicate within k distance.

Return True immediately.

5. Otherwise, add current value to the window
window.add(nums[R])


Now nums[R] becomes part of the last k elements.

6. If loop finishes with no matches
return False


Meaning:
No â€œclose duplicatesâ€ found.

ğŸ§  Mental Map (Very simple)

Imagine a window of k size sliding to the right:

Window holds only last k values

For each new number:

If itâ€™s already in window â†’ duplicate close by â†’ True

If not, add it to window

If window gets too big â†’ remove oldest value

ğŸ“Œ Example

nums = [1, 2, 3, 1], k = 3

Step by step:

R	Window	nums[R]	In window?
0	{}	1	No â†’ add
1	{1}	2	No â†’ add
2	{1,2}	3	No â†’ add
3	{1,2,3}	1	Yes! â†’ return True
â±ï¸ Complexity

Time: O(n)

Space: O(k)


ğŸ‘‰ Problem 1: Longest Subarray With All Equal Values

Find the length of the longest subarray where every element is the same.

You are given:

nums â†’ array of numbers

You must find:

The maximum length of a contiguous stretch where all values are identical

âœ¨ Key Idea

This type of pattern is perfect for a sliding window with two pointers (L and R).

We try to expand the window as long as all elements are equal.

The moment we find a different number:

We â€œresetâ€ the window

Move L to R

This starts a new segment of identical values

âœ¨ Flashcard

â€œTrack a block of equal numbers with L.
Move R forward.
If value changes â†’ set L = R (new block).
Longest block length = answer.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers: L and R

L marks the start of the current block of identical numbers.

R moves across the array (0 â†’ n-1).

Step 2 â€” Compare nums[L] and nums[R]

If they are equal â†’ we remain inside the same subarray.

If they are different â†’
The previous block ended.
Set:

L = R


This starts a new block from position R.

Step 3 â€” Track the maximum block length

At each R:

current_length = R - L + 1
update max_length

Step 4 â€” Continue to the end

The answer is the largest length found.

ğŸ§  Mental Picture

Think of walking through the array and grouping numbers:

[7 7 7 2 2 5 5 5 5 5]

When the value changes, you start counting again.

The longest â€œrunâ€ wins.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only one scan through the array.

ğŸ‘‰ Problem 2: Shortest Subarray With Sum â‰¥ Target

Find the smallest subarray length whose sum is at least target.

You are given:

nums â†’ positive integers

target â†’ required minimum sum

Return:

Length of the shortest subarray with sum â‰¥ target

If none exists â†’ return 0

âœ¨ Key Idea

This is a classic expanding + shrinking sliding window.

Because all numbers are positive, the window sum only increases when R moves right â€” so shrinking works correctly.

âœ¨ Flashcard

â€œExpand R to grow sum.
When total â‰¥ target â†’ shrink from L to find smaller valid window.
Track minimum window length.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Use two pointers

L = start of window

R = end of window

total = sum of current window

Step 2 â€” Expand the window by moving R

For each R:

total += nums[R]


This makes the window sum bigger.

Step 3 â€” When total â‰¥ target â†’ shrink

While the window is â€œheavy enoughâ€:

Update the minimum length:

length = min(length, R - L + 1)


Remove the leftmost element:

total -= nums[L]
L += 1


This tries to make the window smaller while still meeting the sum requirement.

Step 4 â€” Continue until R reaches end
Step 5 â€” If no window ever met the target

Return 0.

ğŸ§  Mental Picture

Imagine dragging a window that grows until it hits the target sum.

Then you tighten the window from the left to see if a smaller valid window exists.

Repeat until the end.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only linear time because each pointer (L and R) moves at most n steps.

ğŸ‘‰ Problem: Two Pointers (two_pointers.py)
ğŸ‘‰ Problem 1: Check if a String is a Palindrome

Determine whether a given string reads the same forwards and backwards.

You are given:

word â†’ a string of characters

You must return:

true if the string is a palindrome

false otherwise

âœ¨ Key Idea

Use the two-pointer pattern:

One pointer starts at the left

One pointer starts at the right

Compare characters while moving inward.

The moment characters donâ€™t match â†’ itâ€™s not a palindrome.

If we reach the center without mismatches â†’ it is a palindrome.

âœ¨ Flashcard

â€œUse two pointers from both ends.
If characters ever differ â†’ not a palindrome.
If pointers meet with no mismatches â†’ palindrome.â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Initialize Two Pointers

Set:

L = 0 (start of the string)

R = len(word) âˆ’ 1 (end of the string)

Step 2 â€” Compare Characters

While L < R:

If word[L] == word[R] â†’ good, keep moving toward the middle

If they differ â†’ instantly return false

Step 3 â€” Move Pointers

After each comparison:

Increment L

Decrement R

This gradually checks symmetrical positions.

Step 4 â€” Reaching the Middle

If the loop completes without finding a mismatch â†’
The string is a palindrome â†’ return true

ğŸ§  Mental Picture

Imagine folding a string from both ends toward the center.
If all mirrored characters match perfectly â†’ palindrome.

Example:

racecar
L-----R (r == r)
 L---R  (a == a)
  L-R   (c == c)
   center

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Only scans the string once, using constant memory.

ğŸ‘‰ Problem 2: Two Numbers Sum to Target (In Sorted Array)

Find two numbers in a sorted list that add up to a given target.

You are given:

nums â†’ a sorted array of integers

target â†’ the required sum

You must return:

The indices of the two numbers (L, R) that add up to the target

There is guaranteed exactly one solution

âœ¨ Key Idea

Use the two-pointer technique on the sorted array.

Because it's sorted:

If the sum is too big â†’ move the right pointer left

If the sum is too small â†’ move the left pointer right

If the sum matches â†’ done!

âœ¨ Flashcard

â€œUse two pointers on sorted array.
If sum too big â†’ move R left.
If sum too small â†’ move L right.
When sum matches â†’ return [L, R].â€

âš¡ Full Approach (Step-by-Step, No Code)
Step 1 â€” Start with Two Pointers

Set:

L = 0 (start of the array)

R = len(nums) âˆ’ 1 (end of the array)

Step 2 â€” Check the Sum of nums[L] + nums[R]

Three cases:

Sum > target
The right value is too large
â†’ Move R left

Sum < target
The left value is too small
â†’ Move L right

Sum == target
Perfect match
â†’ Return [L, R]

Step 3 â€” Repeat Until They Meet

Pointers move inward until the sum is found.

ğŸ§  Mental Picture

You're looking at a scale:

small ......... big
 L           R


If the total is too heavy â†’ shift right pointer left.
If too light â†’ shift left pointer right.

Eventually, the balance matches the target.

â±ï¸ Complexity
Operation	Cost
Time	O(n)
Space	O(1)

Just a single pass through the array.

ğŸ‘‰ Prefix Sum â€“ Range Sum Query (O(1) per query)

1ï¸âƒ£ Prefix Sum Technique

(Preprocessing O(n), Query O(1))

âœ… Key Idea

Store cumulative sums so any subarray sum can be computed using subtraction instead of re-summing elements.

âœ¨ Flashcard

"Precompute sums once â†’ subtract boundaries â†’ get range sum instantly."

âš¡ Full Approach

Steps:

Initialize an empty array prefix.

Set a variable total = 0.

Traverse the input array from left to right:

Add the current element to total.

Append total to the prefix array.

To answer a range sum query (left, right):

Take prefix[right] as the sum from index 0 to right.

If left > 0, subtract prefix[left âˆ’ 1].

If left == 0, subtract 0.

The result is the sum of elements from index left to right.

â±ï¸ Complexity

Preprocessing Time: O(n)

Query Time: O(1)

Space: O(n)

âœ… Notes

Ideal when multiple range sum queries are needed.

Simple logic, very fast queries.

Not suitable if the array is frequently updated.

Commonly used in interviews and competitive programming.



ğŸ‘‰ Floydâ€™s Tortoise and Hare

Detect cycles, find middle, or locate cycle start in a linked list using two pointers: slow (1 step) & fast (2 steps).

âœ¨ Flashcard

â€œSlow walks, fast runs. Meet? â†’ cycle exists. Rewind slow â†’ start of cycle.â€

âš¡ Full Explanation (Very Easy)

1. Find the middle of a linked list

Goal
Find the middle node of a linked list efficiently.

ğŸ” How the code works (Line-by-Line)

Initialize pointers

slow, fast = head, head


slow â†’ moves 1 step at a time

fast â†’ moves 2 steps at a time

Traverse until fast reaches the end

while fast and fast.next:
    slow = slow.next
    fast = fast.next.next


Fast moves twice as fast â†’ when fast hits the end, slow is in the middle.

Return slow

return slow


Middle node found!

ğŸ§  Mental Map
â€œFast pointer finishes first â†’ slow pointer is middle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

2. Detect if a cycle exists

Goal
Check if the linked list loops back on itself.

ğŸ” How the code works (Line-by-Line)

Initialize slow & fast

slow, fast = head, head


Traverse

while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        return True


Fast catches up with slow inside the cycle â†’ cycle exists

If no meeting

return False


Fast reaches the end â†’ no cycle

ğŸ§  Mental Map
â€œTwo runners. Meet? â†’ cycle. Reach end? â†’ no cycle.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

3. Find the start of the cycle

Goal
Return the first node of the cycle, if it exists.

ğŸ” How the code works (Line-by-Line)

Initialize pointers and detect meeting

slow, fast = head, head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        break


First meeting point inside the cycle

Check if no cycle

if not fast or not fast.next:
    return None


Find cycle start

slow2 = head
while slow != slow2:
    slow = slow.next
    slow2 = slow2.next
return slow


Move slow from meeting & slow2 from head one step at a time

They meet at the start of the cycle

ğŸ§  Mental Map
â€œRewind slow to head. Both walk 1 step â†’ meet at cycle start.â€

ğŸ“¦ Complexity

Time: O(n)

Space: O(1)

ğŸ‘‰ Trie (Prefix Tree)

Store words efficiently and answer search and prefix queries by sharing common letter paths.

âœ¨ Flashcard

â€œLetters form paths.
Only some nodes are word endings.
Prefix â‰  word.â€

âš¡ Full Explanation (Very Easy)
1. Inserting a word
ğŸ¯ Goal

Store a word letter by letter while reusing common prefixes.

ğŸ” How it works

â€¢ Start from the root (empty node)
â€¢ Move through each letter in order
â€¢ If a letter path doesnâ€™t exist â†’ create it
â€¢ Move forward until the last letter

âš¡ At the last letter, mark:

â€œA complete word ends here.â€

This is what the word flag represents.

ğŸ§  Mental Map

â€œWalk letters â†’ stop â†’ stamp END OF WORD.â€

2. Searching for a word
ğŸ¯ Goal

Confirm whether a full word exists â€” not just a prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Follow the path of each letter
â€¢ If any letter is missing â†’ word does not exist
â€¢ After the final letter, check:

âš¡ Is this node marked as a word end?

âœ” Yes â†’ valid word
âŒ No â†’ only a prefix

ğŸ§  Mental Map

â€œPath exists + word-end stamp â†’ word found.â€

3. Checking a prefix (startsWith)
ğŸ¯ Goal

Check whether any word starts with this prefix.

ğŸ” How it works

â€¢ Start from the root
â€¢ Walk through prefix letters
â€¢ If all letters exist in sequence â†’ prefix exists

ğŸš« No need to check word ending

ğŸ§  Mental Map

â€œPrefix only needs a path, not a destination.â€

â­ Why the word flag is CRITICAL

Imagine storing:

â€¢ car
â€¢ cat

Both share the path: c â†’ a

But:

â€¢ car ends at r
â€¢ cat ends at t

Without a word-ending marker:
âŒ The Trie cannot tell whether â€œcaâ€ is a word or just a prefix.

ğŸ‘‰ The word flag answers one question only:

â€œDoes a complete word stop here?â€

ğŸ“¦ Complexity

â€¢ Time per operation: linear in word length
â€¢ Extra space: only for new letters

ğŸ§  One-Line Intuition

â€œTrie remembers paths.
word = True remembers when to stop.â€
