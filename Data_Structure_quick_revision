üëâ Type: Static Array

1. Insert at End

‚ú® Flashcard
"Place at arr[length] ‚Üí increment length."

‚ö° Full Approach
Steps:

Check if there‚Äôs capacity (length < capacity).
Insert the new value at arr[length].
Return updated length (length + 1).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct insertion.
Space: O(1) ‚Üí No extra memory.

2. Remove from End

‚ú® Flashcard
"Clear arr[length-1] ‚Üí decrement length."

‚ö° Full Approach
Steps:

Check if the array is non-empty (length > 0).
Reset last element (arr[length-1] = 0).
Return updated length (length - 1).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct removal.
Space: O(1) ‚Üí No extra memory.

3. Insert in Middle

‚ú® Flashcard
"Shift right ‚Üí place value ‚Üí increment length."

‚ö° Full Approach
Steps:

Start from the last real element (length - 1) down to i.
Shift each element one step to the right (arr[index + 1] = arr[index]).
Insert the value at position i.
Return updated length (length + 1).

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Shifting elements.
Space: O(1) ‚Üí No extra memory.

4. Remove from Middle

‚ú® Flashcard
"Shift left ‚Üí clear last slot ‚Üí decrement length."

‚ö° Full Approach
Steps:

Start from i+1 to the end (length - 1).
Shift elements one step to the left (arr[index-1] = arr[index]).
Reset last slot (arr[length-1] = 0).
Return updated length (length - 1).

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Shifting elements.
Space: O(1) ‚Üí No extra memory.

5. Print Array

‚ú® Flashcard
"Loop from 0 ‚Üí capacity ‚Üí print each value."

‚ö° Full Approach
Steps:

Loop through 0 to capacity-1.
Print each arr[i].

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Iterate through array.

Space: O(1) ‚Üí No extra memory.

üëâ Type: Stack (Dynamic Array)

1. Push (Insert at Top)

‚ú® Flashcard
"Append to list ‚Üí top grows upward."

‚ö° Full Approach
Steps:

Call append(n) to add element at the end of the list.
The new element becomes the top of the stack.

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct append.
Space: O(1) ‚Üí No extra memory (except element storage).

2. Pop (Remove from Top)

‚ú® Flashcard
"Pop last ‚Üí return top element."

‚ö° Full Approach
Steps:

Call pop() to remove the last element.
Return the removed element (the previous top).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct pop from end.
Space: O(1) ‚Üí No extra memory.

üëâ Type: Singly Linked List

1. Insert Node at End

‚ú® Flashcard
"Create new_node ‚Üí link tail.next ‚Üí move tail."

‚ö° Full Approach
Steps:

Create a new node (new_node = ListNode(val)).
Link the current tail node to the new node (self.tail.next = new_node).
Move self.tail to point to the new node (self.tail = new_node).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct tail reference.
Space: O(1) ‚Üí No extra memory.

2. Remove Node at Given Index

‚ú® Flashcard
"Traverse to node before target ‚Üí skip target ‚Üí update tail if last node removed."

‚ö° Full Approach
Steps:

Start from the dummy head node (curr = self.head).
Use a for loop to move curr forward index times.
If curr.next is None, index is out of range ‚Üí exit function.

Once at the node before the target, update link:
curr.next = curr.next.next

If we removed the last node, update:
self.tail = curr

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Traverses up to index.
Space: O(1) ‚Üí In-place modification.