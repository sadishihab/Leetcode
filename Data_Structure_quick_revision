👉 Type: Static Array

1. Insert at End

✨ Flashcard
"Place at arr[length] → increment length."

⚡ Full Approach
Steps:

Check if there’s capacity (length < capacity).
Insert the new value at arr[length].
Return updated length (length + 1).

⏱️ Complexity

Time: O(1) → Direct insertion.
Space: O(1) → No extra memory.

2. Remove from End

✨ Flashcard
"Clear arr[length-1] → decrement length."

⚡ Full Approach
Steps:

Check if the array is non-empty (length > 0).
Reset last element (arr[length-1] = 0).
Return updated length (length - 1).

⏱️ Complexity

Time: O(1) → Direct removal.
Space: O(1) → No extra memory.

3. Insert in Middle

✨ Flashcard
"Shift right → place value → increment length."

⚡ Full Approach
Steps:

Start from the last real element (length - 1) down to i.
Shift each element one step to the right (arr[index + 1] = arr[index]).
Insert the value at position i.
Return updated length (length + 1).

⏱️ Complexity

Time: O(n) → Shifting elements.
Space: O(1) → No extra memory.

4. Remove from Middle

✨ Flashcard
"Shift left → clear last slot → decrement length."

⚡ Full Approach
Steps:

Start from i+1 to the end (length - 1).
Shift elements one step to the left (arr[index-1] = arr[index]).
Reset last slot (arr[length-1] = 0).
Return updated length (length - 1).

⏱️ Complexity

Time: O(n) → Shifting elements.
Space: O(1) → No extra memory.

5. Print Array

✨ Flashcard
"Loop from 0 → capacity → print each value."

⚡ Full Approach
Steps:

Loop through 0 to capacity-1.
Print each arr[i].

⏱️ Complexity

Time: O(n) → Iterate through array.

Space: O(1) → No extra memory.

👉 Type: Stack (Dynamic Array)

1. Push (Insert at Top)

✨ Flashcard
"Append to list → top grows upward."

⚡ Full Approach
Steps:

Call append(n) to add element at the end of the list.
The new element becomes the top of the stack.

⏱️ Complexity

Time: O(1) → Direct append.
Space: O(1) → No extra memory (except element storage).

2. Pop (Remove from Top)

✨ Flashcard
"Pop last → return top element."

⚡ Full Approach
Steps:

Call pop() to remove the last element.
Return the removed element (the previous top).

⏱️ Complexity

Time: O(1) → Direct pop from end.
Space: O(1) → No extra memory.

👉 Type: Singly Linked List

1. Insert Node at End

✨ Flashcard
"Create new_node → link tail.next → move tail."

⚡ Full Approach
Steps:

Create a new node (new_node = ListNode(val)).
Link the current tail node to the new node (self.tail.next = new_node).
Move self.tail to point to the new node (self.tail = new_node).

⏱️ Complexity

Time: O(1) → Direct tail reference.
Space: O(1) → No extra memory.

2. Remove Node at Given Index

✨ Flashcard
"Traverse to node before target → skip target → update tail if last node removed."

⚡ Full Approach
Steps:

Start from the dummy head node (curr = self.head).
Use a for loop to move curr forward index times.
If curr.next is None, index is out of range → exit function.

Once at the node before the target, update link:
curr.next = curr.next.next

If we removed the last node, update:
self.tail = curr

⏱️ Complexity

Time: O(n) → Traverses up to index.
Space: O(1) → In-place modification.

👉 Type: Doubly Linked List

1. Insert at Front
Key principle When inserting a node:
Link the new node to the existing nodes first. Then update the dummy node (head or tail) to point to the new node.

✨ Flashcard
"Create a new node → link between head and first real node."

head -> 5 -> 10 -> 20 -> tail       think with this example list for easier visualization

⚡ Full Approach
Steps:

Create a new_node with the value.
Set new_node.prev = head.
Set new_node.next = head.next (the old first node).
Update the old first node’s prev to point to new_node.
Update head.next to point to new_node.

⏱️ Complexity

Time: O(1) → Direct pointer updates.
Space: O(1) → No extra memory.

2. Insert at End

✨ Flashcard
"Create a new node → link between last node and tail."

head -> 5 -> 10 -> 20 -> tail

⚡ Full Approach
Steps:

Create a new_node with the value.
Set new_node.next = tail.
Set new_node.prev = tail.prev (the old last node).
Update the old last node’s next to point to new_node.
Update tail.prev to point to new_node.

⏱️ Complexity

Time: O(1)
Space: O(1)

3. Remove from Front
Key principle When removing a node:
Reconnect the previous and next nodes to each other first, then detach the target node.

✨ Flashcard
"Skip the first node by connecting head to the second node."

head -> 5 -> 10 -> 20 -> tail


⚡ Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update head.next to point to the second node.
Update the second node’s prev to point to head.

⏱️ Complexity

Time: O(1)
Space: O(1)

4. Remove from End

✨ Flashcard
"Skip the last node by connecting tail to the second-last node."

head -> 5 -> 10 -> 20 -> tail

⚡ Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update tail.prev to point to the second-last node.
Update the second-last node’s next to point to tail.

⏱️ Complexity

Time: O(1)
Space: O(1)

5. Print List

✨ Flashcard
"Traverse from head to tail, printing each value."

⚡ Full Approach
Steps:

Start at the node after head.
Keep moving forward using next.
Print each node’s value until reaching tail.

⏱️ Complexity

Time: O(n) → Must traverse all nodes.
Space: O(1) → No extra memory.

🔹 When to use deque vs list?
Use deque when you need fast appends/pops from both ends (O(1) time).
Use list when you need fast random access (indexing, slicing).
👉 Type: Queue (Linked List with Dummy Node)

1. Enqueue (Insert at Tail)

✨ Flashcard
"Create a new node → attach to tail.next → move tail pointer."

⚡ Full Approach
Steps:
Create a new node with the given value.
Link the current tail.next to this new node.
Update tail to point to the new node.

⏱️ Complexity

Time: O(1) → Constant-time insertion at the end.
Space: O(1) → No extra memory besides the new node.

2. Dequeue (Remove from Head)

✨ Flashcard
"Take value from head.next → move head.next forward → reset tail if empty."

⚡ Full Approach

Steps:
If head.next is None, the queue is empty → return None.
Store the value from head.next.val.
Update head.next to skip the removed node (head.next.next).
If the queue is now empty, reset tail = head.
Return the stored value.

⏱️ Complexity

Time: O(1) → Constant-time removal from the front.
Space: O(1) → No extra memory.