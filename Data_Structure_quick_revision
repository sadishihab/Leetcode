üëâ Type: Static Array

1. Insert at End

‚ú® Flashcard
"Place at arr[length] ‚Üí increment length."

‚ö° Full Approach
Steps:

Check if there‚Äôs capacity (length < capacity).
Insert the new value at arr[length].
Return updated length (length + 1).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct insertion.
Space: O(1) ‚Üí No extra memory.

2. Remove from End

‚ú® Flashcard
"Clear arr[length-1] ‚Üí decrement length."

‚ö° Full Approach
Steps:

Check if the array is non-empty (length > 0).
Reset last element (arr[length-1] = 0).
Return updated length (length - 1).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct removal.
Space: O(1) ‚Üí No extra memory.

3. Insert in Middle

‚ú® Flashcard
"Shift right ‚Üí place value ‚Üí increment length."

‚ö° Full Approach
Steps:

Start from the last real element (length - 1) down to i.
Shift each element one step to the right (arr[index + 1] = arr[index]).
Insert the value at position i.
Return updated length (length + 1).

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Shifting elements.
Space: O(1) ‚Üí No extra memory.

4. Remove from Middle

‚ú® Flashcard
"Shift left ‚Üí clear last slot ‚Üí decrement length."

‚ö° Full Approach
Steps:

Start from i+1 to the end (length - 1).
Shift elements one step to the left (arr[index-1] = arr[index]).
Reset last slot (arr[length-1] = 0).
Return updated length (length - 1).

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Shifting elements.
Space: O(1) ‚Üí No extra memory.

5. Print Array

‚ú® Flashcard
"Loop from 0 ‚Üí capacity ‚Üí print each value."

‚ö° Full Approach
Steps:

Loop through 0 to capacity-1.
Print each arr[i].

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Iterate through array.

Space: O(1) ‚Üí No extra memory.

üëâ Type: Stack (Dynamic Array)

1. Push (Insert at Top)

‚ú® Flashcard
"Append to list ‚Üí top grows upward."

‚ö° Full Approach
Steps:

Call append(n) to add element at the end of the list.
The new element becomes the top of the stack.

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct append.
Space: O(1) ‚Üí No extra memory (except element storage).

2. Pop (Remove from Top)

‚ú® Flashcard
"Pop last ‚Üí return top element."

‚ö° Full Approach
Steps:

Call pop() to remove the last element.
Return the removed element (the previous top).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct pop from end.
Space: O(1) ‚Üí No extra memory.

üëâ Type: Singly Linked List

1. Insert Node at End

‚ú® Flashcard
"Create new_node ‚Üí link tail.next ‚Üí move tail."

‚ö° Full Approach
Steps:

Create a new node (new_node = ListNode(val)).
Link the current tail node to the new node (self.tail.next = new_node).
Move self.tail to point to the new node (self.tail = new_node).

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct tail reference.
Space: O(1) ‚Üí No extra memory.

2. Remove Node at Given Index

‚ú® Flashcard
"Traverse to node before target ‚Üí skip target ‚Üí update tail if last node removed."

‚ö° Full Approach
Steps:

Start from the dummy head node (curr = self.head).
Use a for loop to move curr forward index times.
If curr.next is None, index is out of range ‚Üí exit function.

Once at the node before the target, update link:
curr.next = curr.next.next

If we removed the last node, update:
self.tail = curr

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Traverses up to index.
Space: O(1) ‚Üí In-place modification.

üëâ Type: Doubly Linked List

1. Insert at Front
Key principle When inserting a node:
Link the new node to the existing nodes first. Then update the dummy node (head or tail) to point to the new node.

‚ú® Flashcard
"Create a new node ‚Üí link between head and first real node."

head -> 5 -> 10 -> 20 -> tail       think with this example list for easier visualization

‚ö° Full Approach
Steps:

Create a new_node with the value.
Set new_node.prev = head.
Set new_node.next = head.next (the old first node).
Update the old first node‚Äôs prev to point to new_node.
Update head.next to point to new_node.

‚è±Ô∏è Complexity

Time: O(1) ‚Üí Direct pointer updates.
Space: O(1) ‚Üí No extra memory.

2. Insert at End

‚ú® Flashcard
"Create a new node ‚Üí link between last node and tail."

head -> 5 -> 10 -> 20 -> tail

‚ö° Full Approach
Steps:

Create a new_node with the value.
Set new_node.next = tail.
Set new_node.prev = tail.prev (the old last node).
Update the old last node‚Äôs next to point to new_node.
Update tail.prev to point to new_node.

‚è±Ô∏è Complexity

Time: O(1)
Space: O(1)

3. Remove from Front
Key principle When removing a node:
Reconnect the previous and next nodes to each other first, then detach the target node.

‚ú® Flashcard
"Skip the first node by connecting head to the second node."

head -> 5 -> 10 -> 20 -> tail


‚ö° Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update head.next to point to the second node.
Update the second node‚Äôs prev to point to head.

‚è±Ô∏è Complexity

Time: O(1)
Space: O(1)

4. Remove from End

‚ú® Flashcard
"Skip the last node by connecting tail to the second-last node."

head -> 5 -> 10 -> 20 -> tail

‚ö° Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update tail.prev to point to the second-last node.
Update the second-last node‚Äôs next to point to tail.

‚è±Ô∏è Complexity

Time: O(1)
Space: O(1)

5. Print List

‚ú® Flashcard
"Traverse from head to tail, printing each value."

‚ö° Full Approach
Steps:

Start at the node after head.
Keep moving forward using next.
Print each node‚Äôs value until reaching tail.

‚è±Ô∏è Complexity

Time: O(n) ‚Üí Must traverse all nodes.
Space: O(1) ‚Üí No extra memory.