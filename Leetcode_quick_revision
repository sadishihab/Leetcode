LeetCode Quick Revision Flashcards:

üëâ Problem type: Static Arrays

1. Remove Duplicates from Sorted Array (LeetCode 26)

‚ú® Flashcard:
‚ÄúSorted array ‚Üí two pointers. i to scan, k to track for unique."

‚ö° Full Approach:

Use two pointers:
i to scan array.
k to track next position for unique element.
Iterate from index 1:   Because index 0, means the first element will always be unique.
If nums[i] != nums[i-1], place nums[i] at nums[k], increment k.
Return k (count of unique elements).

Notes: The problem can be solved efficiently using a two-pointer technique since the array is already sorted. it is used because:
        #In-Place Modification: The problem requires modifying the array in-place without using extra space. The two-pointer method allows us to overwrite duplicate elements with unique ones.
        #Efficient Traversal: Since the array is sorted, duplicates are adjacent. By comparing adjacent elements, we can identify unique elements in a single pass (O(n) time).
        #Track Unique Elements: One pointer (k) tracks the position where the next unique element should be placed, while the other (i) iterates through the array to find unique elements.
        #Simplicity and Order Preservation: The approach ensures unique elements are placed in the correct order (as they appear in the sorted array) with minimal operations.


‚è±Ô∏è Complexity
Time: O(n) ‚Üí one pass through the array
Space: O(1) ‚Üí in-place, no extra memory

2. Remove Element (LeetCode 27)

‚ú® Flashcard:
‚ÄúTwo pointers. i to scan, k to track for the position of non-val elements.‚Äù

‚ö° Full Approach:

Use two pointers: i scans array, k tracks next position for non-val elements.
Iterate array:
If nums[i] != val, place at nums[k], increment k.
Skip elements equal to val.
Return k (count of non-val elements).

#Notes: Two-Pointer Technique. this technique is used to:
    #Modify the array in-place: The problem requires you to rearrange nums without using additional space (e.g., no new array).
    #Efficiently track valid elements: One pointer (k) keeps track of where to place the next non-val element, while the other pointer (i) iterates through the array to find non-val elements.
    #Minimize operations: By only copying non-val elements to the correct position, the algorithm avoids unnecessary swaps or movements, achieving O(n) time complexity with O(1) space complexity.

‚è±Ô∏è Complexity
Time: O(n) ‚Üí one pass through the array
Space: O(1) ‚Üí in-place, no extra memory

3. Shuffle the array (LeetCode 1470)

‚ú® Flashcard:

"To shuffle the elements of an array in a specific order, Just take a new array, fill it with desired output,
then copy the array to nums and return."

‚ö° Full Approach:

Initialize an empty result array.
Iterate i from 0 to n-1:
Append nums[i] (element from first half).
Append nums[i + n] (element from second half).
Replace original array with result (nums[:] = result).
Return nums.

‚è±Ô∏è Complexity
Time: O(n) ‚Äî the loop runs n times, and each append is O(1)
Space: O(n) ‚Äî result stores 2n elements before copying back to nums

üíé Array & Hash-map
4. Two Sum (LeetCode 1)

‚ú® Flashcard:
‚ÄúWhile looping, check if target‚Äìnum exists in map. If yes ‚Üí return indices. If no ‚Üí save num:index.‚Äù

‚ö° Full Approach:

Use a hash map to store numbers we‚Äôve seen (key = number, value = index).
Iterate through the array:
Compute complement = target - num.
If complement exists in the map ‚Üí return [index_of_complement, current_index].
Otherwise, store num:index in the map.
Return the pair of indices when found.

‚è±Ô∏è Complexity
Time: O(n) (one pass)
Space: O(n) (for hash map)


üëâ Problem type: Dynamic Arrays

1. Concatenation of Array (LeetCode 1929)

‚ú® Flashcard:
‚ÄúConcatenate the array with itself using nums + nums. Return the result.‚Äù

‚ö° Full Approach:

Concatenate the array:
Use Python's list concatenation operator (+) to append the array to itself.
This creates a new list where the original array appears twice consecutively.

Return the result:
Return the concatenated list as the output.

Notes:
As the final output is duplication of the same array, i can just add it with itself in python. and the commented part is the normal solution. but just adding it reduce the runtime.
While both solutions are O(n), the concatenation approach avoids the overhead of initializing an array with zeros and manually assigning values in a loop. Python's list concatenation is highly optimized at the C level, potentially reducing constant factors in runtime.


Time: O(n) ‚Äî concatenating two lists of length n requires iterating over all elements
Space: O(n) ‚Äî a new list of size 2n is created


üëâ Problem type: Stacks

1. Baseball Game (LeetCode 682)

‚ú® Flashcard:
‚ÄúStack for scores. '+': sum last 2, 'D': double last, 'C': pop last, number: push. Return sum of stack.‚Äù

‚ö° Full Approach:

Use a stack to track valid scores.
Iterate operations:
'+': sum of last two ‚Üí push.
'D': double last ‚Üí push.
'C': pop last.
Number: push as int.
Return sum of stack after all operations.

‚è±Ô∏è Complexity
Time: O(n) ‚Äî each operation takes O(1), but summing the stack at the end takes O(n)
Space: O(n) ‚Äî for the stack storing the valid scores

üíé Stack & Hash-map
2. Valid Parentheses (LeetCode 20)

‚ú® Flashcard:
‚ÄúPush opens to stack. For closes, check top matches. If mismatch/empty ‚Üí invalid. End: valid if stack empty.‚Äù

‚ö° Full Approach:

Use a stack to keep track of opening brackets.
Create mapping: ')':'(', ']':'[', '}':'{'.
Iterate string:
Push opening brackets.
For closing brackets: check if stack top matches. If not or empty ‚Üí invalid.
At the end, stack must be empty ‚Üí valid.

‚è±Ô∏è Complexity
Time: O(n) (each character processed once)
Space: O(n) (in worst case, all characters are opens)

3. Min Stack (LeetCode 155)

‚ú® Flashcard:
‚ÄúTwo stacks: stack for values, minStack for mins. push ‚Üí push val & min(val,last). pop ‚Üí pop both. getMin = top of minStack.‚Äù

‚ö° Full Approach:

Use two stacks: stack for all values, minStack for current minimums.
On push(val):
Push val to stack.
Push min(val, minStack[-1]) to minStack.
On pop(): pop both stacks.
top(): return top of stack.
getMin(): return top of minStack.

‚è±Ô∏è Complexity
Time: O(1) for all operations.
Space: O(n) for the two stacks.

üëâ Problem type: Singly linked lists

1. Reverse Linked List (LeetCode 206) - iterative approach

‚ú® Flashcard:
‚ÄúIterate list. Reverse pointer at each node. Move prev & curr forward. Return prev.‚Äù

‚ö° Full Approach:

Use three pointers: prev = None, curr = head, next_node.
Iterate through the list:
Save curr.next in next_node.
Reverse curr.next to point to prev.
Move prev and curr forward.
Return prev as the new head.

‚è±Ô∏è Complexity
Time: O(n) ‚Äî we traverse each node of the linked list exactly once
Space: O(1) ‚Äî only a few pointers (prev, current, next_node) are used regardless of list size

üîÑ Recursive approach:

‚ú® Flashcard:
‚ÄúUse recursion: reverse the rest of the list, then flip the current node‚Äôs pointer. Return the new head.‚Äù

Notes: Base case: empty list or single node ‚Üí return head. Otherwise, recurse, fix pointers (head.next.next = head, head.next = None), and return new head.

‚ö° Full Approach:

Base case: If head is None or has only one node, return head.
Recursive call: Reverse the list starting from head.next.

Fix pointers:
head.next.next = head (make next node point back to current).
head.next = None (break the old link).
Return the new_head from recursive calls (this will be the last node of the original list).

‚è±Ô∏è Complexity

Time: O(n) ‚Üí every node is visited once.
Space: O(n) ‚Üí recursion stack stores n calls.


2. Merge Two Sorted Lists (LeetCode 21) ‚Äì Iterative Approach

list1: 1 -> 2 -> 4    list2: 1 -> 3 -> 4    merged_list: 1 -> 1 -> 2 -> 3 -> 4 -> 4

‚ú® Flashcard:
"Use a dummy node. Compare heads, link smaller node, move pointer. Finally, return dummy.next."

‚ö° Full Approach:

Create a dummy node and a curr pointer (to build the merged list).
Loop while both list1 and list2 are not empty:
Compare list1.val and list2.val.
Link curr.next to the smaller node.
Move the pointer (list1 or list2) forward.
Move curr forward to keep building the list.
Attach the remaining part of the non-empty list (if any).
Return dummy.next as the head of the merged sorted list.

‚è±Ô∏è Complexity

Time: O(n + m) ‚Äî each node of both lists is visited exactly once.
Space: O(1) ‚Äî only a few pointers (dummy, curr, list1, list2) are used.