LeetCode Quick Revision Flashcards:

👉 Problem type: Static Arrays

1. Remove Duplicates from Sorted Array (LeetCode 26)

✨ Flashcard:
“Sorted array → two pointers. i to scan, k to track for unique."

⚡ Full Approach:

Use two pointers:
i to scan array.
k to track next position for unique element.
Iterate from index 1:   Because index 0, means the first element will always be unique.
If nums[i] != nums[i-1], place nums[i] at nums[k], increment k.
Return k (count of unique elements).

Notes: The problem can be solved efficiently using a two-pointer technique since the array is already sorted. it is used because:
        #In-Place Modification: The problem requires modifying the array in-place without using extra space. The two-pointer method allows us to overwrite duplicate elements with unique ones.
        #Efficient Traversal: Since the array is sorted, duplicates are adjacent. By comparing adjacent elements, we can identify unique elements in a single pass (O(n) time).
        #Track Unique Elements: One pointer (k) tracks the position where the next unique element should be placed, while the other (i) iterates through the array to find unique elements.
        #Simplicity and Order Preservation: The approach ensures unique elements are placed in the correct order (as they appear in the sorted array) with minimal operations.


⏱️ Complexity
Time: O(n) → one pass through the array
Space: O(1) → in-place, no extra memory

2. Remove Element (LeetCode 27)

✨ Flashcard:
“Two pointers. i to scan, k to track for the position of non-val elements.”

⚡ Full Approach:

Use two pointers: i scans array, k tracks next position for non-val elements.
Iterate array:
If nums[i] != val, place at nums[k], increment k.
Skip elements equal to val.
Return k (count of non-val elements).

#Notes: Two-Pointer Technique. this technique is used to:
    #Modify the array in-place: The problem requires you to rearrange nums without using additional space (e.g., no new array).
    #Efficiently track valid elements: One pointer (k) keeps track of where to place the next non-val element, while the other pointer (i) iterates through the array to find non-val elements.
    #Minimize operations: By only copying non-val elements to the correct position, the algorithm avoids unnecessary swaps or movements, achieving O(n) time complexity with O(1) space complexity.

⏱️ Complexity
Time: O(n) → one pass through the array
Space: O(1) → in-place, no extra memory

3. Shuffle the array (LeetCode 1470)

✨ Flashcard:

"To shuffle the elements of an array in a specific order, Just take a new array, fill it with desired output,
then copy the array to nums and return."

⚡ Full Approach:

Initialize an empty result array.
Iterate i from 0 to n-1:
Append nums[i] (element from first half).
Append nums[i + n] (element from second half).
Replace original array with result (nums[:] = result).
Return nums.

⏱️ Complexity
Time: O(n) — the loop runs n times, and each append is O(1)
Space: O(n) — result stores 2n elements before copying back to nums

💎 Array & Hash-map
4. Two Sum (LeetCode 1)

✨ Flashcard:
“While looping, check if target–num exists in map. If yes → return indices. If no → save num:index.”

⚡ Full Approach:

Use a hash map to store numbers we’ve seen (key = number, value = index).
Iterate through the array:
Compute complement = target - num.
If complement exists in the map → return [index_of_complement, current_index].
Otherwise, store num:index in the map.
Return the pair of indices when found.

⏱️ Complexity
Time: O(n) (one pass)
Space: O(n) (for hash map)


👉 Problem type: Dynamic Arrays

1. Concatenation of Array (LeetCode 1929)

✨ Flashcard:
“Concatenate the array with itself using nums + nums. Return the result.”

⚡ Full Approach:

Concatenate the array:
Use Python's list concatenation operator (+) to append the array to itself.
This creates a new list where the original array appears twice consecutively.

Return the result:
Return the concatenated list as the output.

Notes:
As the final output is duplication of the same array, i can just add it with itself in python. and the commented part is the normal solution. but just adding it reduce the runtime.
While both solutions are O(n), the concatenation approach avoids the overhead of initializing an array with zeros and manually assigning values in a loop. Python's list concatenation is highly optimized at the C level, potentially reducing constant factors in runtime.


Time: O(n) — concatenating two lists of length n requires iterating over all elements
Space: O(n) — a new list of size 2n is created


👉 Problem type: Stacks

1. Baseball Game (LeetCode 682)

✨ Flashcard:
“Stack for scores. '+': sum last 2, 'D': double last, 'C': pop last, number: push. Return sum of stack.”

⚡ Full Approach:

Use a stack to track valid scores.
Iterate operations:
'+': sum of last two → push.
'D': double last → push.
'C': pop last.
Number: push as int.
Return sum of stack after all operations.

⏱️ Complexity
Time: O(n) — each operation takes O(1), but summing the stack at the end takes O(n)
Space: O(n) — for the stack storing the valid scores

💎 Stack & Hash-map
2. Valid Parentheses (LeetCode 20)

✨ Flashcard:
“Push opens to stack. For closes, check top matches. If mismatch/empty → invalid. End: valid if stack empty.”

⚡ Full Approach:

Use a stack to keep track of opening brackets.
Create mapping: ')':'(', ']':'[', '}':'{'.
Iterate string:
Push opening brackets.
For closing brackets: check if stack top matches. If not or empty → invalid.
At the end, stack must be empty → valid.

⏱️ Complexity
Time: O(n) (each character processed once)
Space: O(n) (in worst case, all characters are opens)

3. Min Stack (LeetCode 155)

✨ Flashcard:
“Two stacks: stack for values, minStack for mins. push → push val & min(val,last). pop → pop both. getMin = top of minStack.”

⚡ Full Approach:

Use two stacks: stack for all values, minStack for current minimums.
On push(val):
Push val to stack.
Push min(val, minStack[-1]) to minStack.
On pop(): pop both stacks.
top(): return top of stack.
getMin(): return top of minStack.

⏱️ Complexity
Time: O(1) for all operations.
Space: O(n) for the two stacks.

👉 Problem type: Singly linked lists

1. Reverse Linked List (LeetCode 206) - iterative approach

✨ Flashcard:
“Iterate list. Reverse pointer at each node. Move prev & curr forward. Return prev.”

⚡ Full Approach:

Use three pointers: prev = None, curr = head, next_node.
Iterate through the list:
Save curr.next in next_node.
Reverse curr.next to point to prev.
Move prev and curr forward.
Return prev as the new head.

⏱️ Complexity
Time: O(n) — we traverse each node of the linked list exactly once
Space: O(1) — only a few pointers (prev, current, next_node) are used regardless of list size

🔄 Recursive approach:

✨ Flashcard:
“Use recursion: reverse the rest of the list, then flip the current node’s pointer. Return the new head.”

Notes: Base case: empty list or single node → return head. Otherwise, recurse, fix pointers (head.next.next = head, head.next = None), and return new head.

⚡ Full Approach:

Base case: If head is None or has only one node, return head.
Recursive call: Reverse the list starting from head.next.

Fix pointers:
head.next.next = head (make next node point back to current).
head.next = None (break the old link).
Return the new_head from recursive calls (this will be the last node of the original list).

⏱️ Complexity

Time: O(n) → every node is visited once.
Space: O(n) → recursion stack stores n calls.


2. Merge Two Sorted Lists (LeetCode 21) – Iterative Approach

list1: 1 -> 2 -> 4    list2: 1 -> 3 -> 4    merged_list: 1 -> 1 -> 2 -> 3 -> 4 -> 4

✨ Flashcard:
"Use a dummy node. Compare heads, link smaller node, move pointer. Finally, return dummy.next."

⚡ Full Approach:

Create a dummy node and a curr pointer (to build the merged list).
Loop while both list1 and list2 are not empty:
Compare list1.val and list2.val.
Link curr.next to the smaller node.
Move the pointer (list1 or list2) forward.
Move curr forward to keep building the list.
Attach the remaining part of the non-empty list (if any).
Return dummy.next as the head of the merged sorted list.

⏱️ Complexity

Time: O(n + m) — each node of both lists is visited exactly once.
Space: O(1) — only a few pointers (dummy, curr, list1, list2) are used.

🔄 Recursive approach:

✨ Flashcard:
“Compare heads recursively. Smaller node points to merged of the rest. Return the smaller node as head.”

⚡ Full Approach:

Base case:

If list1 is None, return list2.
If list2 is None, return list1.

Recursive case:

Compare list1.val and list2.val.
The smaller node becomes the current head.
Recursively merge the rest of the lists and assign it to head.next.
Return the current head as the merged list.

⏱️ Complexity

Time: O(n + m) — each node is visited exactly once.
Space: O(n + m) — due to recursion stack (one call per node).

👉 Problem type: Doubly Linked List
1. Design Linked List (LeetCode 707)

1️⃣ Insert at Head (addAtHead)

✨ Flashcard
“Create a new node. Link between head and first real node. Increment size.”

⚡ Full Approach

Create new_node with value val.
Set new_node.prev = head.
Set new_node.next = head.next (old first node).
Update old first node’s prev = new_node.
Update head.next = new_node.
Increment size.

⏱️ Complexity

Time: O(1) — constant pointer updates
Space: O(1) — no extra memory

2️⃣ Insert at Tail (addAtTail)

✨ Flashcard
“Create a new node. Link between last real node and tail. Increment size.”

⚡ Full Approach

Create new_node with value val.
Set new_node.next = tail.
Set new_node.prev = tail.prev (old last node).
Update old last node’s next = new_node.
Update tail.prev = new_node.
Increment size.

⏱️ Complexity

Time: O(1)
Space: O(1)

3️⃣ Get Value at Index (get)

✨ Flashcard
“Use _getNode to find node. Return its value. If invalid index, return -1.”

⚡ Full Approach

If index < 0 or index >= size, return -1.
Call _getNode(index) → traverse from head or tail depending on index.
Return curr.val.

⏱️ Complexity

Time: O(n/2) average → optimized bidirectional traversal
Space: O(1)

4️⃣ Insert at Index (addAtIndex)

✨ Flashcard
“Use _getNode to find node at index. Link new node between prev and curr. Increment size.”

⚡ Full Approach

If index < 0 or index > size, return.
If index == size, call addAtTail(val).
Get curr = _getNode(index).
Create new_node with value val.
Set new_node.next = curr.
Set new_node.prev = curr.prev.
Update curr.prev.next = new_node.
Update curr.prev = new_node.
Increment size.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

5️⃣ Delete at Index (deleteAtIndex)

✨ Flashcard
“Use _getNode → bypass node to remove it. Decrement size.”

⚡ Full Approach

If index < 0 or index >= size, return.
Get curr = _getNode(index).
Update curr.prev.next = curr.next.
Update curr.next.prev = curr.prev.
Decrement size.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

6️⃣ Get Node (_getNode)

✨ Flashcard
“If index < size//2 → traverse from head, else from tail.”

⚡ Full Approach

If index < size // 2, start from head.next and move index steps forward.
Else, start from tail.prev and move size - index - 1 steps backward.
Return the node.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

2. Design Browser History (LeetCode 1472)

✨ Flashcard:
“Use doubly linked list. visit clears forward nodes, back & forward iterate limited steps.”

⚡ Full Approach:

Node Structure: Each page is a ListNode with val, prev, and next.
Initialization: curr points to the homepage node.

Visit(url):
Clear forward history by setting curr.next = None.
Create a new node with url.
Link new_node.prev = curr and curr.next = new_node.
Move curr to the new node.

Back(steps):
While steps > 0 and curr.prev exists: move curr = curr.prev, decrement steps.
Return curr.val.

Forward(steps):
While steps > 0 and curr.next exists: move curr = curr.next, decrement steps.
Return curr.val.

⏱️ Complexity:

visit: O(1) → direct pointer update
back: O(steps) → iterate at most steps nodes
forward: O(steps) → iterate at most steps nodes

Space: O(n) → one node per visited page

Optimized Note:
For instant back/forward, you can store history in a list instead of a linked list → O(1) for back and forward

👉 Problem type: Queue

1. Number of Students Unable to Eat Lunch (LeetCode 1700)

The core idea of the algorithm:
At each step, the top sandwich must be taken for the process to continue.
If no student in the queue wants that sandwich, it will stay there forever.
As a result, the queue will just keep rotating endlessly, and no more sandwiches can be served.

✨ Flashcard:
“Count preferences → process stack until stuck → remaining count = unable students.”

⚡ Full Approach:

Count how many students want 0 and 1.
Loop through the sandwich stack:
If top sandwich matches a preference, decrement that count.
If no one wants that sandwich, break — queue is stuck.
Return the sum of remaining 0s and 1s as students unable to eat.

⏱️ Complexity

Time: O(n) → one pass to count, one pass to process stack
Space: O(1) → only counters used, in-place calculation

2. Implement Stack Using Two Queues (LIFO) (LeetCode 225)

The core idea of the algorithm:
We simulate a stack (LIFO) using two queues (FIFO).
Always keep the newest element at the front of q1.
To do this, during push, we insert the new element into q2 and move all elements from q1 to q2, then swap queues.
pop and top then simply operate on the front of q1.

✨ Flashcard:
“Push to q2 → move q1 to q2 → swap → pop/top from q1 front.”

⚡ Full Approach:
Initialize:
q1 = main queue holding stack elements.
q2 = temporary queue.

Push(x):
Append x to q2.
Move all elements from q1 → q2 (so newest is at front).
Swap q1 and q2 (q1 now has correct order).

Pop():
Remove and return q1.popleft() (top of stack).

Top():
Return q1[0] (peek front).

Empty():
Return not q1 (True if empty, else False).

⏱️ Complexity:

Push: O(n) → move all elements to maintain LIFO order
Pop: O(1) → remove front
Top: O(1) → peek front
Empty: O(1)

2-a. Implement Stack Using Single Queue (LeetCode 225):

✨ Flashcard:
“Append to right → pop from right → peek right → check if empty.”

⚡ Full Approach:
Initialize:
q1 = deque() → holds all stack elements.

Push(x):
Append x to the right end of q1.  → Top of stack is always at the right.

Pop():
Remove and return the rightmost element (q1.pop()) → top of stack.

Top():
Peek the rightmost element (q1[-1]) without removing it.

Empty():
Return not q1 → True if deque is empty, else False

⏱️ Complexity:

Push: O(1) → append to right
Pop: O(1) → remove rightmost element
Top: O(1) → peek rightmost element
Empty: O(1) → check if deque is empty

👉 Problem type: Recursion with memorization

Climbing Stairs (LeetCode 70)

✨ Flashcard:
“Ways(n) = Ways(n-1) + Ways(n-2) → use memo to avoid recomputation.”

⚡ Full Approach:
Recurrence Idea:
To reach step n, you can come from:
Step n-1 (1 step jump)
Step n-2 (2 steps jump)

So:
f(n)=f(n−1)+f(n−2)

Base Cases:
f(1) = 1 (only one way → single step)
f(2) = 2 (two ways → 1+1 or 2)

Memoization:
Store computed results in self.memo dictionary.
If n already solved, return it directly → avoids repeated recursion.

⏱️ Complexity:

Time: O(n) → each subproblem (n) solved once.
Space: O(n) → recursion stack + memo dictionary.

🔹 Climbing Stairs (Bottom-Up DP, Iterative)

✨ Flashcard:
“Use Fibonacci relation → track last two results → shift forward until n.”

⚡ Full Approach:
Core Idea:
From the recurrence:
f(n)=f(n−1)+f(n−2)

We only ever need the last two values (f(n-1) and f(n-2)) to compute the next.
Instead of recursion, use a loop to build results from bottom up.

Steps:

Handle small cases:
If n = 1, return 1.
If n = 2, return 2.

Initialize two variables:
a = f(1) = 1
b = f(2) = 2

For each step i from 3 → n:
Compute new value = a + b (ways for step i).
Update a = b (shift forward), b = new (latest result).
After the loop, b holds the number of ways for n

⏱️ Complexity:
Time: O(n) → single pass loop.
Space: O(1) → only two variables (a, b).

👉 Problem type: Divide & Conquer

Sort an Array (LeetCode 912)

The core idea of the algorithm:
Pick a random pivot and partition the array into three groups:
Smaller than pivot
Equal to pivot
Larger than pivot

Recursively sort only the smaller and larger groups.
The middle (equal) group is already in the right position, so no extra merging is needed.

✨ Flashcard:
“Pick random pivot → smaller left, equal middle, larger right → recursively sort sides → done.”

⚡ Full Approach:

Random Pivot:
Pick a random index in the current subarray.
Swap it with the last element for convenience.

3-Way Partitioning:

Use three pointers:

lt → boundary of elements < pivot
i → current element being checked
gt → boundary of elements > pivot

Loop while i <= gt:

If nums[i] < pivot → swap with lt, move both lt and i forward.
If nums[i] > pivot → swap with gt, move gt backward (check new element at i).
If nums[i] == pivot → just move i forward.

Recursive Sort:

Recursively sort left (start to lt - 1)
Recursively sort right (gt + 1 to end)

Base Case:

Stop recursion if subarray has 0 or 1 element.

⏱️ Complexity:

Time:
Average: O(n log n)
Worst-case: O(n²) (very rare due to random pivot)

Space: O(log n) recursion stack

Stable: ❌ Not stable (equal elements may change order)

👉 Problem type: Divide & Conquer
 Merge k Sorted Lists (LeetCode 23)

✨ Core Idea
Use divide & conquer (merge sort style):
Split the k lists into halves.
Recursively solve each half.
Merge the two halves with a helper function that merges two sorted lists.

✨ Flashcard

“Split k lists into halves → recursively solve → merge two sorted lists → repeat until one list remains.”

⚡ Full Approach

1. Base Case:
If there’s only one list, just return it.

2. Divide:
Pick the middle index.
Split the lists into two halves: left and right.

3. Conquer:
Recursively merge the left half into a single sorted list.
Recursively merge the right half into a single sorted list.

4. Combine:
Merge the two sorted linked lists (l1 and l2) into one final sorted list.
Use a helper (mergeTwoLists) that walks through both lists, attaching the smaller node each time.

5. Finish:
Continue merging until only one fully sorted list remains.

⏱️ Complexity

Time:
Each merge of two lists costs O(n) where n = total nodes.
Divide & conquer merges lists in O(log k) levels.
Total = O(N log k) (optimal), where N = total number of nodes.

Space:
Only recursion stack depth → O(log k).

Stable: ✅ Yes (nodes with equal values keep their relative order).


👉 Problem type: Divide & Conquer
Kth Largest Element in an Array (LeetCode 215) using "Quick-Select"

✨ Core Idea
Use in-place 3-way Quickselect (like quicksort partitioning) to find the kth largest element:

Pick a random pivot.
Partition the array into three parts: < pivot, = pivot, > pivot.
Decide which partition contains the kth largest element and recurse only into that part.

✨ Flashcard
“Pick pivot → partition into <, =, > → recurse into correct partition → repeat until pivot is kth largest.”

⚡ Full Approach

Base Case:
If the partition has only one element, return it.

Divide:
Randomly pick a pivot from the current subarray.
Swap pivot with the last element for convenience.

Conquer (Partition):
Walk through the subarray with three pointers:

lt → end of < pivot region
i → current element
gt → start of > pivot region
Move elements into < pivot, = pivot, > pivot regions.

Combine (Select the partition):
Count elements strictly greater than pivot: num_greater = end - gt
Count elements greater or equal: num_greater_equal = end - lt + 1
If k <= num_greater, recurse into > pivot region.
If k <= num_greater_equal, pivot is the answer.
Otherwise, recurse into < pivot region adjusting k accordingly.

Finish:
Continue recursively until the kth largest element is found.

⏱️ Complexity

Time:

Average: O(n) → each partition step scans the subarray once.
Worst-case: O(n²) → occurs if pivot selections are extremely unbalanced.

Space:

Only recursion stack → O(log n) on average.
Stable: ❌ (partitioning swaps elements, so relative order may change).


👉 Problem type: Heap / Priority Queue
Kth Largest Element in an Array (LeetCode 215) using Min-Heap

✨ Core Idea
Maintain a min-heap of size k. Push elements one by one, and whenever the heap exceeds size k, remove the smallest. After processing all elements, the heap contains the k largest elements, and the smallest in the heap is the kth largest.

✨ Flashcard
“Maintain a min-heap of size k → push elements → pop if heap exceeds k → kth largest = root of heap.”

⚡ Full Approach

Initialize:
Start with an empty min-heap.
Iterate through the array:
Push each number into the heap.
If heap size > k → pop the smallest element.

Finish:
After all numbers are processed, the heap has exactly k largest elements.
Return the root of the heap → min_heap[0] → kth largest element.

⏱️ Complexity

Time:
O(n log k) → each push/pop is log k, done n times.

Space:
O(k) → heap stores k elements only.

Stable: ❌ (heap does not maintain relative order).