LeetCode Quick Revision Flashcards:

👉 Problem type: Static Arrays

1. Remove Duplicates from Sorted Array (LeetCode 26)

✨ Flashcard:
“Sorted array → two pointers. i to scan, k to track for unique."

⚡ Full Approach:

Use two pointers:
i to scan array.
k to track next position for unique element.
Iterate from index 1:   Because index 0, means the first element will always be unique.
If nums[i] != nums[i-1], place nums[i] at nums[k], increment k.
Return k (count of unique elements).

Notes: The problem can be solved efficiently using a two-pointer technique since the array is already sorted. it is used because:
        #In-Place Modification: The problem requires modifying the array in-place without using extra space. The two-pointer method allows us to overwrite duplicate elements with unique ones.
        #Efficient Traversal: Since the array is sorted, duplicates are adjacent. By comparing adjacent elements, we can identify unique elements in a single pass (O(n) time).
        #Track Unique Elements: One pointer (k) tracks the position where the next unique element should be placed, while the other (i) iterates through the array to find unique elements.
        #Simplicity and Order Preservation: The approach ensures unique elements are placed in the correct order (as they appear in the sorted array) with minimal operations.


⏱️ Complexity
Time: O(n) → one pass through the array
Space: O(1) → in-place, no extra memory

2. Remove Element (LeetCode 27)

✨ Flashcard:
“Two pointers. i to scan, k to track for the position of non-val elements.”

⚡ Full Approach:

Use two pointers: i scans array, k tracks next position for non-val elements.
Iterate array:
If nums[i] != val, place at nums[k], increment k.
Skip elements equal to val.
Return k (count of non-val elements).

#Notes: Two-Pointer Technique. this technique is used to:
    #Modify the array in-place: The problem requires you to rearrange nums without using additional space (e.g., no new array).
    #Efficiently track valid elements: One pointer (k) keeps track of where to place the next non-val element, while the other pointer (i) iterates through the array to find non-val elements.
    #Minimize operations: By only copying non-val elements to the correct position, the algorithm avoids unnecessary swaps or movements, achieving O(n) time complexity with O(1) space complexity.

⏱️ Complexity
Time: O(n) → one pass through the array
Space: O(1) → in-place, no extra memory

3. Shuffle the array (LeetCode 1470)

✨ Flashcard:

"To shuffle the elements of an array in a specific order, Just take a new array, fill it with desired output,
then copy the array to nums and return."

⚡ Full Approach:

Initialize an empty result array.
Iterate i from 0 to n-1:
Append nums[i] (element from first half).
Append nums[i + n] (element from second half).
Replace original array with result (nums[:] = result).
Return nums.

⏱️ Complexity
Time: O(n) — the loop runs n times, and each append is O(1)
Space: O(n) — result stores 2n elements before copying back to nums

💎 Array & Hash-map
4. Two Sum (LeetCode 1)

✨ Flashcard:
“While looping, check if target–num exists in map. If yes → return indices. If no → save num:index.”

⚡ Full Approach:

Use a hash map to store numbers we’ve seen (key = number, value = index).
Iterate through the array:
Compute complement = target - num.
If complement exists in the map → return [index_of_complement, current_index].
Otherwise, store num:index in the map.
Return the pair of indices when found.

⏱️ Complexity
Time: O(n) (one pass)
Space: O(n) (for hash map)


👉 Problem type: Dynamic Arrays

1. Concatenation of Array (LeetCode 1929)

✨ Flashcard:
“Concatenate the array with itself using nums + nums. Return the result.”

⚡ Full Approach:

Concatenate the array:
Use Python's list concatenation operator (+) to append the array to itself.
This creates a new list where the original array appears twice consecutively.

Return the result:
Return the concatenated list as the output.

Notes:
As the final output is duplication of the same array, i can just add it with itself in python. and the commented part is the normal solution. but just adding it reduce the runtime.
While both solutions are O(n), the concatenation approach avoids the overhead of initializing an array with zeros and manually assigning values in a loop. Python's list concatenation is highly optimized at the C level, potentially reducing constant factors in runtime.


Time: O(n) — concatenating two lists of length n requires iterating over all elements
Space: O(n) — a new list of size 2n is created


👉 Problem type: Stacks

1. Baseball Game (LeetCode 682)

✨ Flashcard:
“Stack for scores. '+': sum last 2, 'D': double last, 'C': pop last, number: push. Return sum of stack.”

⚡ Full Approach:

Use a stack to track valid scores.
Iterate operations:
'+': sum of last two → push.
'D': double last → push.
'C': pop last.
Number: push as int.
Return sum of stack after all operations.

⏱️ Complexity
Time: O(n) — each operation takes O(1), but summing the stack at the end takes O(n)
Space: O(n) — for the stack storing the valid scores

💎 Stack & Hash-map
2. Valid Parentheses (LeetCode 20)

✨ Flashcard:
“Push opens to stack. For closes, check top matches. If mismatch/empty → invalid. End: valid if stack empty.”

⚡ Full Approach:

Use a stack to keep track of opening brackets.
Create mapping: ')':'(', ']':'[', '}':'{'.
Iterate string:
Push opening brackets.
For closing brackets: check if stack top matches. If not or empty → invalid.
At the end, stack must be empty → valid.

⏱️ Complexity
Time: O(n) (each character processed once)
Space: O(n) (in worst case, all characters are opens)

3. Min Stack (LeetCode 155)

✨ Flashcard:
“Two stacks: stack for values, minStack for mins. push → push val & min(val,last). pop → pop both. getMin = top of minStack.”

⚡ Full Approach:

Use two stacks: stack for all values, minStack for current minimums.
On push(val):
Push val to stack.
Push min(val, minStack[-1]) to minStack.
On pop(): pop both stacks.
top(): return top of stack.
getMin(): return top of minStack.

⏱️ Complexity
Time: O(1) for all operations.
Space: O(n) for the two stacks.

👉 Problem type: Singly linked lists

1. Reverse Linked List (LeetCode 206) - iterative approach

✨ Flashcard:
“Iterate list. Reverse pointer at each node. Move prev & curr forward. Return prev.”

⚡ Full Approach:

Use three pointers: prev = None, curr = head, next_node.
Iterate through the list:
Save curr.next in next_node.
Reverse curr.next to point to prev.
Move prev and curr forward.
Return prev as the new head.

⏱️ Complexity
Time: O(n) — we traverse each node of the linked list exactly once
Space: O(1) — only a few pointers (prev, current, next_node) are used regardless of list size

🔄 Recursive approach:

✨ Flashcard:
“Use recursion: reverse the rest of the list, then flip the current node’s pointer. Return the new head.”

Notes: Base case: empty list or single node → return head. Otherwise, recurse, fix pointers (head.next.next = head, head.next = None), and return new head.

⚡ Full Approach:

Base case: If head is None or has only one node, return head.
Recursive call: Reverse the list starting from head.next.

Fix pointers:
head.next.next = head (make next node point back to current).
head.next = None (break the old link).
Return the new_head from recursive calls (this will be the last node of the original list).

⏱️ Complexity

Time: O(n) → every node is visited once.
Space: O(n) → recursion stack stores n calls.


2. Merge Two Sorted Lists (LeetCode 21) – Iterative Approach

list1: 1 -> 2 -> 4    list2: 1 -> 3 -> 4    merged_list: 1 -> 1 -> 2 -> 3 -> 4 -> 4

✨ Flashcard:
"Use a dummy node. Compare heads, link smaller node, move pointer. Finally, return dummy.next."

⚡ Full Approach:

Create a dummy node and a curr pointer (to build the merged list).
Loop while both list1 and list2 are not empty:
Compare list1.val and list2.val.
Link curr.next to the smaller node.
Move the pointer (list1 or list2) forward.
Move curr forward to keep building the list.
Attach the remaining part of the non-empty list (if any).
Return dummy.next as the head of the merged sorted list.

⏱️ Complexity

Time: O(n + m) — each node of both lists is visited exactly once.
Space: O(1) — only a few pointers (dummy, curr, list1, list2) are used.

🔄 Recursive approach:

✨ Flashcard:
“Compare heads recursively. Smaller node points to merged of the rest. Return the smaller node as head.”

⚡ Full Approach:

Base case:

If list1 is None, return list2.
If list2 is None, return list1.

Recursive case:

Compare list1.val and list2.val.
The smaller node becomes the current head.
Recursively merge the rest of the lists and assign it to head.next.
Return the current head as the merged list.

⏱️ Complexity

Time: O(n + m) — each node is visited exactly once.
Space: O(n + m) — due to recursion stack (one call per node).

👉 Problem type: Doubly Linked List
1. Design Linked List (LeetCode 707)

1️⃣ Insert at Head (addAtHead)

✨ Flashcard
“Create a new node. Link between head and first real node. Increment size.”

⚡ Full Approach

Create new_node with value val.
Set new_node.prev = head.
Set new_node.next = head.next (old first node).
Update old first node’s prev = new_node.
Update head.next = new_node.
Increment size.

⏱️ Complexity

Time: O(1) — constant pointer updates
Space: O(1) — no extra memory

2️⃣ Insert at Tail (addAtTail)

✨ Flashcard
“Create a new node. Link between last real node and tail. Increment size.”

⚡ Full Approach

Create new_node with value val.
Set new_node.next = tail.
Set new_node.prev = tail.prev (old last node).
Update old last node’s next = new_node.
Update tail.prev = new_node.
Increment size.

⏱️ Complexity

Time: O(1)
Space: O(1)

3️⃣ Get Value at Index (get)

✨ Flashcard
“Use _getNode to find node. Return its value. If invalid index, return -1.”

⚡ Full Approach

If index < 0 or index >= size, return -1.
Call _getNode(index) → traverse from head or tail depending on index.
Return curr.val.

⏱️ Complexity

Time: O(n/2) average → optimized bidirectional traversal
Space: O(1)

4️⃣ Insert at Index (addAtIndex)

✨ Flashcard
“Use _getNode to find node at index. Link new node between prev and curr. Increment size.”

⚡ Full Approach

If index < 0 or index > size, return.
If index == size, call addAtTail(val).
Get curr = _getNode(index).
Create new_node with value val.
Set new_node.next = curr.
Set new_node.prev = curr.prev.
Update curr.prev.next = new_node.
Update curr.prev = new_node.
Increment size.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

5️⃣ Delete at Index (deleteAtIndex)

✨ Flashcard
“Use _getNode → bypass node to remove it. Decrement size.”

⚡ Full Approach

If index < 0 or index >= size, return.
Get curr = _getNode(index).
Update curr.prev.next = curr.next.
Update curr.next.prev = curr.prev.
Decrement size.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

6️⃣ Get Node (_getNode)

✨ Flashcard
“If index < size//2 → traverse from head, else from tail.”

⚡ Full Approach

If index < size // 2, start from head.next and move index steps forward.
Else, start from tail.prev and move size - index - 1 steps backward.
Return the node.

⏱️ Complexity

Time: O(n/2) average
Space: O(1)

2. Design Browser History (LeetCode 1472)

✨ Flashcard:
“Use doubly linked list. visit clears forward nodes, back & forward iterate limited steps.”

⚡ Full Approach:

Node Structure: Each page is a ListNode with val, prev, and next.
Initialization: curr points to the homepage node.

Visit(url):
Clear forward history by setting curr.next = None.
Create a new node with url.
Link new_node.prev = curr and curr.next = new_node.
Move curr to the new node.

Back(steps):
While steps > 0 and curr.prev exists: move curr = curr.prev, decrement steps.
Return curr.val.

Forward(steps):
While steps > 0 and curr.next exists: move curr = curr.next, decrement steps.
Return curr.val.

⏱️ Complexity:

visit: O(1) → direct pointer update
back: O(steps) → iterate at most steps nodes
forward: O(steps) → iterate at most steps nodes

Space: O(n) → one node per visited page

Optimized Note:
For instant back/forward, you can store history in a list instead of a linked list → O(1) for back and forward

👉 Problem type: Queue

1. Number of Students Unable to Eat Lunch (LeetCode 1700)

The core idea of the algorithm:
At each step, the top sandwich must be taken for the process to continue.
If no student in the queue wants that sandwich, it will stay there forever.
As a result, the queue will just keep rotating endlessly, and no more sandwiches can be served.

✨ Flashcard:
“Count preferences → process stack until stuck → remaining count = unable students.”

⚡ Full Approach:

Count how many students want 0 and 1.
Loop through the sandwich stack:
If top sandwich matches a preference, decrement that count.
If no one wants that sandwich, break — queue is stuck.
Return the sum of remaining 0s and 1s as students unable to eat.

⏱️ Complexity

Time: O(n) → one pass to count, one pass to process stack
Space: O(1) → only counters used, in-place calculation

