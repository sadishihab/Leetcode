LeetCode Quick Revision Flashcards:

ğŸ‘‰ Problem type: Static Arrays

1. Remove Duplicates from Sorted Array (LeetCode 26)

âœ¨ Flashcard:
â€œSorted array â†’ two pointers. i to scan, k to track for unique."

âš¡ Full Approach:

Use two pointers:
i to scan array.
k to track next position for unique element.
Iterate from index 1:   Because index 0, means the first element will always be unique.
If nums[i] != nums[i-1], place nums[i] at nums[k], increment k.
Return k (count of unique elements).

Notes: The problem can be solved efficiently using a two-pointer technique since the array is already sorted. it is used because:
        #In-Place Modification: The problem requires modifying the array in-place without using extra space. The two-pointer method allows us to overwrite duplicate elements with unique ones.
        #Efficient Traversal: Since the array is sorted, duplicates are adjacent. By comparing adjacent elements, we can identify unique elements in a single pass (O(n) time).
        #Track Unique Elements: One pointer (k) tracks the position where the next unique element should be placed, while the other (i) iterates through the array to find unique elements.
        #Simplicity and Order Preservation: The approach ensures unique elements are placed in the correct order (as they appear in the sorted array) with minimal operations.


â±ï¸ Complexity
Time: O(n) â†’ one pass through the array
Space: O(1) â†’ in-place, no extra memory

2. Remove Element (LeetCode 27)

âœ¨ Flashcard:
â€œTwo pointers. i to scan, k to track for the position of non-val elements.â€

âš¡ Full Approach:

Use two pointers: i scans array, k tracks next position for non-val elements.
Iterate array:
If nums[i] != val, place at nums[k], increment k.
Skip elements equal to val.
Return k (count of non-val elements).

#Notes: Two-Pointer Technique. this technique is used to:
    #Modify the array in-place: The problem requires you to rearrange nums without using additional space (e.g., no new array).
    #Efficiently track valid elements: One pointer (k) keeps track of where to place the next non-val element, while the other pointer (i) iterates through the array to find non-val elements.
    #Minimize operations: By only copying non-val elements to the correct position, the algorithm avoids unnecessary swaps or movements, achieving O(n) time complexity with O(1) space complexity.

â±ï¸ Complexity
Time: O(n) â†’ one pass through the array
Space: O(1) â†’ in-place, no extra memory

3. Shuffle the array (LeetCode 1470)

âœ¨ Flashcard:

"To shuffle the elements of an array in a specific order, Just take a new array, fill it with desired output,
then copy the array to nums and return."

âš¡ Full Approach:

Initialize an empty result array.
Iterate i from 0 to n-1:
Append nums[i] (element from first half).
Append nums[i + n] (element from second half).
Replace original array with result (nums[:] = result).
Return nums.

â±ï¸ Complexity
Time: O(n) â€” the loop runs n times, and each append is O(1)
Space: O(n) â€” result stores 2n elements before copying back to nums

ğŸ’ Array & Hash-map
4. Two Sum (LeetCode 1)

âœ¨ Flashcard:
â€œWhile looping, check if targetâ€“num exists in map. If yes â†’ return indices. If no â†’ save num:index.â€

âš¡ Full Approach:

Use a hash map to store numbers weâ€™ve seen (key = number, value = index).
Iterate through the array:
Compute complement = target - num.
If complement exists in the map â†’ return [index_of_complement, current_index].
Otherwise, store num:index in the map.
Return the pair of indices when found.

â±ï¸ Complexity
Time: O(n) (one pass)
Space: O(n) (for hash map)


ğŸ‘‰ Problem type: Dynamic Arrays

1. Concatenation of Array (LeetCode 1929)

âœ¨ Flashcard:
â€œConcatenate the array with itself using nums + nums. Return the result.â€

âš¡ Full Approach:

Concatenate the array:
Use Python's list concatenation operator (+) to append the array to itself.
This creates a new list where the original array appears twice consecutively.

Return the result:
Return the concatenated list as the output.

Notes:
As the final output is duplication of the same array, i can just add it with itself in python. and the commented part is the normal solution. but just adding it reduce the runtime.
While both solutions are O(n), the concatenation approach avoids the overhead of initializing an array with zeros and manually assigning values in a loop. Python's list concatenation is highly optimized at the C level, potentially reducing constant factors in runtime.


Time: O(n) â€” concatenating two lists of length n requires iterating over all elements
Space: O(n) â€” a new list of size 2n is created


ğŸ‘‰ Problem type: Stacks

1. Baseball Game (LeetCode 682)

âœ¨ Flashcard:
â€œStack for scores. '+': sum last 2, 'D': double last, 'C': pop last, number: push. Return sum of stack.â€

âš¡ Full Approach:

Use a stack to track valid scores.
Iterate operations:
'+': sum of last two â†’ push.
'D': double last â†’ push.
'C': pop last.
Number: push as int.
Return sum of stack after all operations.

â±ï¸ Complexity
Time: O(n) â€” each operation takes O(1), but summing the stack at the end takes O(n)
Space: O(n) â€” for the stack storing the valid scores

ğŸ’ Stack & Hash-map
2. Valid Parentheses (LeetCode 20)

âœ¨ Flashcard:
â€œPush opens to stack. For closes, check top matches. If mismatch/empty â†’ invalid. End: valid if stack empty.â€

âš¡ Full Approach:

Use a stack to keep track of opening brackets.
Create mapping: ')':'(', ']':'[', '}':'{'.
Iterate string:
Push opening brackets.
For closing brackets: check if stack top matches. If not or empty â†’ invalid.
At the end, stack must be empty â†’ valid.

â±ï¸ Complexity
Time: O(n) (each character processed once)
Space: O(n) (in worst case, all characters are opens)

3. Min Stack (LeetCode 155)

âœ¨ Flashcard:
â€œTwo stacks: stack for values, minStack for mins. push â†’ push val & min(val,last). pop â†’ pop both. getMin = top of minStack.â€

âš¡ Full Approach:

Use two stacks: stack for all values, minStack for current minimums.
On push(val):
Push val to stack.
Push min(val, minStack[-1]) to minStack.
On pop(): pop both stacks.
top(): return top of stack.
getMin(): return top of minStack.

â±ï¸ Complexity
Time: O(1) for all operations.
Space: O(n) for the two stacks.

ğŸ‘‰ Problem type: Singly linked lists

1. Reverse Linked List (LeetCode 206) - iterative approach

âœ¨ Flashcard:
â€œIterate list. Reverse pointer at each node. Move prev & curr forward. Return prev.â€

âš¡ Full Approach:

Use three pointers: prev = None, curr = head, next_node.
Iterate through the list:
Save curr.next in next_node.
Reverse curr.next to point to prev.
Move prev and curr forward.
Return prev as the new head.

â±ï¸ Complexity
Time: O(n) â€” we traverse each node of the linked list exactly once
Space: O(1) â€” only a few pointers (prev, current, next_node) are used regardless of list size

ğŸ”„ Recursive approach:

âœ¨ Flashcard:
â€œUse recursion: reverse the rest of the list, then flip the current nodeâ€™s pointer. Return the new head.â€

Notes: Base case: empty list or single node â†’ return head. Otherwise, recurse, fix pointers (head.next.next = head, head.next = None), and return new head.

âš¡ Full Approach:

Base case: If head is None or has only one node, return head.
Recursive call: Reverse the list starting from head.next.

Fix pointers:
head.next.next = head (make next node point back to current).
head.next = None (break the old link).
Return the new_head from recursive calls (this will be the last node of the original list).

â±ï¸ Complexity

Time: O(n) â†’ every node is visited once.
Space: O(n) â†’ recursion stack stores n calls.


2. Merge Two Sorted Lists (LeetCode 21) â€“ Iterative Approach

list1: 1 -> 2 -> 4    list2: 1 -> 3 -> 4    merged_list: 1 -> 1 -> 2 -> 3 -> 4 -> 4

âœ¨ Flashcard:
"Use a dummy node. Compare heads, link smaller node, move pointer. Finally, return dummy.next."

âš¡ Full Approach:

Create a dummy node and a curr pointer (to build the merged list).
Loop while both list1 and list2 are not empty:
Compare list1.val and list2.val.
Link curr.next to the smaller node.
Move the pointer (list1 or list2) forward.
Move curr forward to keep building the list.
Attach the remaining part of the non-empty list (if any).
Return dummy.next as the head of the merged sorted list.

â±ï¸ Complexity

Time: O(n + m) â€” each node of both lists is visited exactly once.
Space: O(1) â€” only a few pointers (dummy, curr, list1, list2) are used.

ğŸ”„ Recursive approach:

âœ¨ Flashcard:
â€œCompare heads recursively. Smaller node points to merged of the rest. Return the smaller node as head.â€

âš¡ Full Approach:

Base case:

If list1 is None, return list2.
If list2 is None, return list1.

Recursive case:

Compare list1.val and list2.val.
The smaller node becomes the current head.
Recursively merge the rest of the lists and assign it to head.next.
Return the current head as the merged list.

â±ï¸ Complexity

Time: O(n + m) â€” each node is visited exactly once.
Space: O(n + m) â€” due to recursion stack (one call per node).

ğŸ‘‰ Problem type: Doubly Linked List
1. Design Linked List (LeetCode 707)

1ï¸âƒ£ Insert at Head (addAtHead)

âœ¨ Flashcard
â€œCreate a new node. Link between head and first real node. Increment size.â€

âš¡ Full Approach

Create new_node with value val.
Set new_node.prev = head.
Set new_node.next = head.next (old first node).
Update old first nodeâ€™s prev = new_node.
Update head.next = new_node.
Increment size.

â±ï¸ Complexity

Time: O(1) â€” constant pointer updates
Space: O(1) â€” no extra memory

2ï¸âƒ£ Insert at Tail (addAtTail)

âœ¨ Flashcard
â€œCreate a new node. Link between last real node and tail. Increment size.â€

âš¡ Full Approach

Create new_node with value val.
Set new_node.next = tail.
Set new_node.prev = tail.prev (old last node).
Update old last nodeâ€™s next = new_node.
Update tail.prev = new_node.
Increment size.

â±ï¸ Complexity

Time: O(1)
Space: O(1)

3ï¸âƒ£ Get Value at Index (get)

âœ¨ Flashcard
â€œUse _getNode to find node. Return its value. If invalid index, return -1.â€

âš¡ Full Approach

If index < 0 or index >= size, return -1.
Call _getNode(index) â†’ traverse from head or tail depending on index.
Return curr.val.

â±ï¸ Complexity

Time: O(n/2) average â†’ optimized bidirectional traversal
Space: O(1)

4ï¸âƒ£ Insert at Index (addAtIndex)

âœ¨ Flashcard
â€œUse _getNode to find node at index. Link new node between prev and curr. Increment size.â€

âš¡ Full Approach

If index < 0 or index > size, return.
If index == size, call addAtTail(val).
Get curr = _getNode(index).
Create new_node with value val.
Set new_node.next = curr.
Set new_node.prev = curr.prev.
Update curr.prev.next = new_node.
Update curr.prev = new_node.
Increment size.

â±ï¸ Complexity

Time: O(n/2) average
Space: O(1)

5ï¸âƒ£ Delete at Index (deleteAtIndex)

âœ¨ Flashcard
â€œUse _getNode â†’ bypass node to remove it. Decrement size.â€

âš¡ Full Approach

If index < 0 or index >= size, return.
Get curr = _getNode(index).
Update curr.prev.next = curr.next.
Update curr.next.prev = curr.prev.
Decrement size.

â±ï¸ Complexity

Time: O(n/2) average
Space: O(1)

6ï¸âƒ£ Get Node (_getNode)

âœ¨ Flashcard
â€œIf index < size//2 â†’ traverse from head, else from tail.â€

âš¡ Full Approach

If index < size // 2, start from head.next and move index steps forward.
Else, start from tail.prev and move size - index - 1 steps backward.
Return the node.

â±ï¸ Complexity

Time: O(n/2) average
Space: O(1)

2. Design Browser History (LeetCode 1472)

âœ¨ Flashcard:
â€œUse doubly linked list. visit clears forward nodes, back & forward iterate limited steps.â€

âš¡ Full Approach:

Node Structure: Each page is a ListNode with val, prev, and next.
Initialization: curr points to the homepage node.

Visit(url):
Clear forward history by setting curr.next = None.
Create a new node with url.
Link new_node.prev = curr and curr.next = new_node.
Move curr to the new node.

Back(steps):
While steps > 0 and curr.prev exists: move curr = curr.prev, decrement steps.
Return curr.val.

Forward(steps):
While steps > 0 and curr.next exists: move curr = curr.next, decrement steps.
Return curr.val.

â±ï¸ Complexity:

visit: O(1) â†’ direct pointer update
back: O(steps) â†’ iterate at most steps nodes
forward: O(steps) â†’ iterate at most steps nodes

Space: O(n) â†’ one node per visited page

Optimized Note:
For instant back/forward, you can store history in a list instead of a linked list â†’ O(1) for back and forward

ğŸ‘‰ Problem type: Queue

1. Number of Students Unable to Eat Lunch (LeetCode 1700)

The core idea of the algorithm:
At each step, the top sandwich must be taken for the process to continue.
If no student in the queue wants that sandwich, it will stay there forever.
As a result, the queue will just keep rotating endlessly, and no more sandwiches can be served.

âœ¨ Flashcard:
â€œCount preferences â†’ process stack until stuck â†’ remaining count = unable students.â€

âš¡ Full Approach:

Count how many students want 0 and 1.
Loop through the sandwich stack:
If top sandwich matches a preference, decrement that count.
If no one wants that sandwich, break â€” queue is stuck.
Return the sum of remaining 0s and 1s as students unable to eat.

â±ï¸ Complexity

Time: O(n) â†’ one pass to count, one pass to process stack
Space: O(1) â†’ only counters used, in-place calculation

2. Implement Stack Using Two Queues (LIFO) (LeetCode 225)

The core idea of the algorithm:
We simulate a stack (LIFO) using two queues (FIFO).
Always keep the newest element at the front of q1.
To do this, during push, we insert the new element into q2 and move all elements from q1 to q2, then swap queues.
pop and top then simply operate on the front of q1.

âœ¨ Flashcard:
â€œPush to q2 â†’ move q1 to q2 â†’ swap â†’ pop/top from q1 front.â€

âš¡ Full Approach:
Initialize:
q1 = main queue holding stack elements.
q2 = temporary queue.

Push(x):
Append x to q2.
Move all elements from q1 â†’ q2 (so newest is at front).
Swap q1 and q2 (q1 now has correct order).

Pop():
Remove and return q1.popleft() (top of stack).

Top():
Return q1[0] (peek front).

Empty():
Return not q1 (True if empty, else False).

â±ï¸ Complexity:

Push: O(n) â†’ move all elements to maintain LIFO order
Pop: O(1) â†’ remove front
Top: O(1) â†’ peek front
Empty: O(1)

2-a. Implement Stack Using Single Queue (LeetCode 225):

âœ¨ Flashcard:
â€œAppend to right â†’ pop from right â†’ peek right â†’ check if empty.â€

âš¡ Full Approach:
Initialize:
q1 = deque() â†’ holds all stack elements.

Push(x):
Append x to the right end of q1.  â†’ Top of stack is always at the right.

Pop():
Remove and return the rightmost element (q1.pop()) â†’ top of stack.

Top():
Peek the rightmost element (q1[-1]) without removing it.

Empty():
Return not q1 â†’ True if deque is empty, else False

â±ï¸ Complexity:

Push: O(1) â†’ append to right
Pop: O(1) â†’ remove rightmost element
Top: O(1) â†’ peek rightmost element
Empty: O(1) â†’ check if deque is empty

ğŸ‘‰ Problem type: Recursion with memorization

Climbing Stairs (LeetCode 70)

âœ¨ Flashcard:
â€œWays(n) = Ways(n-1) + Ways(n-2) â†’ use memo to avoid recomputation.â€

âš¡ Full Approach:
Recurrence Idea:
To reach step n, you can come from:
Step n-1 (1 step jump)
Step n-2 (2 steps jump)

So:
f(n)=f(nâˆ’1)+f(nâˆ’2)

Base Cases:
f(1) = 1 (only one way â†’ single step)
f(2) = 2 (two ways â†’ 1+1 or 2)

Memoization:
Store computed results in self.memo dictionary.
If n already solved, return it directly â†’ avoids repeated recursion.

â±ï¸ Complexity:

Time: O(n) â†’ each subproblem (n) solved once.
Space: O(n) â†’ recursion stack + memo dictionary.

ğŸ”¹ Climbing Stairs (Bottom-Up DP, Iterative)

âœ¨ Flashcard:
â€œUse Fibonacci relation â†’ track last two results â†’ shift forward until n.â€

âš¡ Full Approach:
Core Idea:
From the recurrence:
f(n)=f(nâˆ’1)+f(nâˆ’2)

We only ever need the last two values (f(n-1) and f(n-2)) to compute the next.
Instead of recursion, use a loop to build results from bottom up.

Steps:

Handle small cases:
If n = 1, return 1.
If n = 2, return 2.

Initialize two variables:
a = f(1) = 1
b = f(2) = 2

For each step i from 3 â†’ n:
Compute new value = a + b (ways for step i).
Update a = b (shift forward), b = new (latest result).
After the loop, b holds the number of ways for n

â±ï¸ Complexity:
Time: O(n) â†’ single pass loop.
Space: O(1) â†’ only two variables (a, b).

ğŸ‘‰ Problem type: Divide & Conquer

Sort an Array (LeetCode 912)

The core idea of the algorithm:
Pick a random pivot and partition the array into three groups:
Smaller than pivot
Equal to pivot
Larger than pivot

Recursively sort only the smaller and larger groups.
The middle (equal) group is already in the right position, so no extra merging is needed.

âœ¨ Flashcard:
â€œPick random pivot â†’ smaller left, equal middle, larger right â†’ recursively sort sides â†’ done.â€

âš¡ Full Approach:

Random Pivot:
Pick a random index in the current subarray.
Swap it with the last element for convenience.

3-Way Partitioning:

Use three pointers:

lt â†’ boundary of elements < pivot
i â†’ current element being checked
gt â†’ boundary of elements > pivot

Loop while i <= gt:

If nums[i] < pivot â†’ swap with lt, move both lt and i forward.
If nums[i] > pivot â†’ swap with gt, move gt backward (check new element at i).
If nums[i] == pivot â†’ just move i forward.

Recursive Sort:

Recursively sort left (start to lt - 1)
Recursively sort right (gt + 1 to end)

Base Case:

Stop recursion if subarray has 0 or 1 element.

â±ï¸ Complexity:

Time:
Average: O(n log n)
Worst-case: O(nÂ²) (very rare due to random pivot)

Space: O(log n) recursion stack

Stable: âŒ Not stable (equal elements may change order)

ğŸ‘‰ Problem type: Divide & Conquer
 Merge k Sorted Lists (LeetCode 23)

âœ¨ Core Idea
Use divide & conquer (merge sort style):
Split the k lists into halves.
Recursively solve each half.
Merge the two halves with a helper function that merges two sorted lists.

âœ¨ Flashcard

â€œSplit k lists into halves â†’ recursively solve â†’ merge two sorted lists â†’ repeat until one list remains.â€

âš¡ Full Approach

1. Base Case:
If thereâ€™s only one list, just return it.

2. Divide:
Pick the middle index.
Split the lists into two halves: left and right.

3. Conquer:
Recursively merge the left half into a single sorted list.
Recursively merge the right half into a single sorted list.

4. Combine:
Merge the two sorted linked lists (l1 and l2) into one final sorted list.
Use a helper (mergeTwoLists) that walks through both lists, attaching the smaller node each time.

5. Finish:
Continue merging until only one fully sorted list remains.

â±ï¸ Complexity

Time:
Each merge of two lists costs O(n) where n = total nodes.
Divide & conquer merges lists in O(log k) levels.
Total = O(N log k) (optimal), where N = total number of nodes.

Space:
Only recursion stack depth â†’ O(log k).

Stable: âœ… Yes (nodes with equal values keep their relative order).


ğŸ‘‰ Problem type: Divide & Conquer
Kth Largest Element in an Array (LeetCode 215) using "Quick-Select"

âœ¨ Core Idea
Use in-place 3-way Quickselect (like quicksort partitioning) to find the kth largest element:

Pick a random pivot.
Partition the array into three parts: < pivot, = pivot, > pivot.
Decide which partition contains the kth largest element and recurse only into that part.

âœ¨ Flashcard
â€œPick pivot â†’ partition into <, =, > â†’ recurse into correct partition â†’ repeat until pivot is kth largest.â€

âš¡ Full Approach

Base Case:
If the partition has only one element, return it.

Divide:
Randomly pick a pivot from the current subarray.
Swap pivot with the last element for convenience.

Conquer (Partition):
Walk through the subarray with three pointers:

lt â†’ end of < pivot region
i â†’ current element
gt â†’ start of > pivot region
Move elements into < pivot, = pivot, > pivot regions.

Combine (Select the partition):
Count elements strictly greater than pivot: num_greater = end - gt
Count elements greater or equal: num_greater_equal = end - lt + 1
If k <= num_greater, recurse into > pivot region.
If k <= num_greater_equal, pivot is the answer.
Otherwise, recurse into < pivot region adjusting k accordingly.

Finish:
Continue recursively until the kth largest element is found.

â±ï¸ Complexity

Time:

Average: O(n) â†’ each partition step scans the subarray once.
Worst-case: O(nÂ²) â†’ occurs if pivot selections are extremely unbalanced.

Space:

Only recursion stack â†’ O(log n) on average.
Stable: âŒ (partitioning swaps elements, so relative order may change).


ğŸ‘‰ Problem type: Heap / Priority Queue
Kth Largest Element in an Array (LeetCode 215) using Min-Heap

âœ¨ Core Idea
Maintain a min-heap of size k. Push elements one by one, and whenever the heap exceeds size k, remove the smallest. After processing all elements, the heap contains the k largest elements, and the smallest in the heap is the kth largest.

âœ¨ Flashcard
â€œMaintain a min-heap of size k â†’ push elements â†’ pop if heap exceeds k â†’ kth largest = root of heap.â€

âš¡ Full Approach

Initialize:
Start with an empty min-heap.
Iterate through the array:
Push each number into the heap.
If heap size > k â†’ pop the smallest element.

Finish:
After all numbers are processed, the heap has exactly k largest elements.
Return the root of the heap â†’ min_heap[0] â†’ kth largest element.

â±ï¸ Complexity

Time:
O(n log k) â†’ each push/pop is log k, done n times.

Space:
O(k) â†’ heap stores k elements only.

Stable: âŒ (heap does not maintain relative order).

ğŸ‘‰ Problem: Leet code 704 - binary search
This is simple binary search

ğŸ‘‰ Problem: (Leetcode 74, Binary Search in 2D Matrix)

âœ… Key Idea
The given matrix is â€œflattened sortedâ€:

Each row is sorted.
First element of a row > last element of the previous row.

So if you read the matrix row by row, itâ€™s equivalent to a 1D sorted array of length m * n.
That means we can apply binary search directly on this â€œvirtualâ€ 1D array.

âœ¨ Flashcard
"Flatten 2D â†’ pretend itâ€™s 1D â†’ binary search with index mapping (row = mid // n, col = mid % n)."

âš¡ Full Approach

Matrix size:
Rows = m
Cols = n
Total elements = m * n.

Binary Search:
Search range: left = 0, right = m * n - 1.

Midpoint: mid = (left + right) // 2.

Index Mapping:
Convert 1D mid index to 2D (row, col) using:
row = mid // n
col = mid % n

Check:

If matrix[row][col] == target â†’ return True.
If matrix[row][col] < target â†’ search right half.
Else â†’ search left half.
If loop ends, return False.

â±ï¸ Complexity

Time: O(log(m * n)) (binary search on all elements).
Space: O(1) (only a few variables).

ğŸ‘‰ Problem: (Leetcode 700)
Simple implementation of binary search tree.

ğŸ‘‰ Problem: Lowest Common Ancestor in a BST (Leetcode 235)

âœ… Key Idea
Use the BST property to locate the split point between p and q:
If both p and q are smaller than root â†’ LCA lies in left subtree.
If both p and q are greater than root â†’ LCA lies in right subtree.
Otherwise, the current root is the lowest node where they diverge, i.e., the LCA.

âœ¨ Flashcard
"Both smaller â†’ go left. Both bigger â†’ go right. Otherwise â†’ current root is the LCA."

âš¡ Full Approach

Start from the root.
If p and q are both < root.val â†’ move to root.left.
If p and q are both > root.val â†’ move to root.right.
Otherwise â†’ split point found â†’ return root as LCA.

This works because in a BST:
Left subtree values < root.
Right subtree values > root.

â±ï¸ Complexity

Time: O(h), where h = height of the tree.
Worst case (skewed tree): O(n).
Best case (balanced tree): O(log n).
Space: O(1) (iterative, no recursion stack).

âœ… Notes:

A recursive version works identically but uses O(h) space.
This only works for BSTs, not for arbitrary binary trees.

ğŸ‘‰ Problem: (Leetcode 701)
Simple insertion in a binary search tree

ğŸ‘‰ Problem: (Leetcode 450)
Simple deletion in a binary search tree

ğŸ‘‰ Problem: (Leetcode 94)
Simple inorder traversal

ğŸ‘‰ Problem: Kth Smallest Element in a BST (Leetcode 230)
Simple inorder traversal to sort, then return kth element

ğŸ‘‰ Why can we rebuild the original tree?

Because preorder and inorder together give us two key things:

1ï¸âƒ£ Preorder â†’ tells us who the root is
In preorder traversal, the very first element is always the root.

Example:
preorder = [3, 9, 20, 15, 7]
â†’ Root = 3

2ï¸âƒ£ Inorder â†’ tells us where the root splits left vs right

In inorder traversal, everything before the root is the left subtree, and everything after the root is the right subtree.

Example:
inorder = [9, 3, 15, 20, 7]
             â†‘
           root = 3

Left subtree = [9]
Right subtree = [15, 20, 7]

3ï¸âƒ£ Repeat this process (recursion)

Take next root from preorder.
Use inorder to split it into left and right.
Keep repeating until youâ€™ve placed all nodes.

Easy Analogy ğŸŒ³

Think of preorder as:
â€œWhich node to build first, second, thirdâ€¦â€

And inorder as:
â€œWhere to attach nodes: left or right of the parent.â€

ğŸ”‘ Example Quick Build
Preorder: [3, 9, 20, 15, 7]
Inorder:  [9, 3, 15, 20, 7]


Root = 3 (from preorder).
Split inorder â†’ left = [9], right = [15,20,7].

Next root = 9 (from preorder).
In inorder [9] â†’ left and right are empty â†’ just a leaf.

Next root = 20.
In inorder [15,20,7] â†’ left = [15], right = [7].

Next root = 15 â†’ leaf.

Next root = 7 â†’ leaf.

âœ… Thatâ€™s why we can exactly reconstruct the tree.


ğŸ‘‰ Problem: Build Binary Tree from Preorder and Inorder (Leetcode 105)

âœ… Key Idea

Preorder gives the root first.
Inorder tells us how to split the tree into left and right subtrees.
Recursively apply the same idea to build subtrees.

âœ¨ Flashcard
"Preorder â†’ pick root. Inorder â†’ split left/right. Recurse."

âš¡ Full Approach

Base Case:

If preorder or inorder is empty â†’ return None.

Pick Root:

root_val = preorder[0] â†’ first element in preorder is the root.
Create root = TreeNode(root_val).

Find Root Index in Inorder:
mid = inorder.index(root_val)

Everything before mid â†’ left subtree.
Everything after mid â†’ right subtree.
Build Subtrees Recursively:

Left: preorder[1:mid+1], inorder[:mid]
Right: preorder[mid+1:], inorder[mid+1:]

Return Root:

root now has left and right children attached.

â±ï¸ Complexity

Time: O(nÂ²) â†’ index() search at each recursive call.
Space: O(n) â†’ recursion stack and new slices.

âœ… Notes

Using a hashmap to store inorder indices can reduce time to O(n).
Works only if all node values are unique.
This approach reconstructs the original tree exactly.

ğŸ‘‰ Problem: Binary Tree Level Order Traversal (Leetcode 102)
simple BFS implementation

ğŸ‘‰ Problem: Binary Tree Right Side View (Leetcode 199)
simple BFS implementation. Only add the last node of each level to the result.


ğŸ‘‰ Problem: Path Sum (Leetcode 112)

âœ… Key Idea

We want to check if there exists a root-to-leaf path in the binary tree such that the sum of node values equals targetSum.
At each node, subtract the nodeâ€™s value from targetSum.
If we reach a leaf and the remaining sum equals the leafâ€™s value â†’ return True.
Otherwise, recursively check left and right subtrees.

âœ¨ Flashcard
"At a leaf: check if targetSum == node.val.
Otherwise: check left OR right with updated sum."

âš¡ Full Approach

Base Case:
If root is None â†’ no path â†’ return False.

Leaf Case:
If root is a leaf (not root.left and not root.right) â†’ check if targetSum == root.val.

Recursive Step:
Recurse on left and right children with targetSum - root.val.

If either side returns True, the whole function returns True.

â±ï¸ Complexity

Time: O(n) â†’ visit each node once.
Space: O(h) â†’ recursion stack, where h = height of the tree.


ğŸ‘‰ Problem: Subsets (Leetcode 78)

âœ… Key Idea

Each element has two choices: include it in the subset or skip it.
We use backtracking:

Add the current path as a subset.

Loop through remaining elements, append one to the path, recurse with i+1 (so we donâ€™t reuse elements), then backtrack.

âœ¨ Flashcard
"At each step: choose an element, recurse with next index, then backtrack."

âš¡ Full Approach

Base Step

Add the current path (subset) to results: res.append(path[:]).
This ensures every possible subset is collected (even empty []).

Recursive Step

For each index i starting from start:

Include nums[i] â†’ path.append(nums[i]).

Recurse with backtrack(i+1, path) so only later elements are considered.

Backtrack (path.pop()) to remove the last choice and explore other options.

This builds all subsets systematically without duplicates.

â±ï¸ Complexity

Time: O(2â¿ Â· n)
2â¿ subsets, and copying each path can take up to n.

Space: O(n) recursion depth + O(2â¿) for storing results.

âœ… Example (nums = [1,2,3])

Recursion tree:

[]
â”œâ”€â”€ [1]
â”‚   â”œâ”€â”€ [1,2]
â”‚   â”‚    â””â”€â”€ [1,2,3]
â”‚   â””â”€â”€ [1,3]
â”œâ”€â”€ [2]
â”‚   â””â”€â”€ [2,3]
â””â”€â”€ [3]


Result:

[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]

ğŸ‘‰ Problem: Combination Sum (Leetcode 39)

âœ… Key Idea

We need all unique combinations of numbers that add up to target.
At each index, we can:

Choose the current candidate (and stay at same index, since reuse is allowed).

Skip to the next candidate.

We use backtracking to explore all possibilities.

âœ¨ Flashcard
"At each step: pick a candidate, recurse with reduced target (stay at same index for reuse), then backtrack."

âš¡ Full Approach

Base Cases

If target == 0 â†’ we found a valid combination â†’ add a copy of path to res.

If target < 0 â†’ sum exceeded target â†’ stop.

Recursive Step

Loop over candidates starting from start.
Include candidates[i] â†’ append to path.
Recurse with backtrack(i, path, target - candidates[i]) â†’ stay at i because reuse is allowed.
Backtrack â†’ pop the last element to try the next option.

This explores all combinations systematically without duplicates.

â±ï¸ Complexity

Time: Exponential, worst case O(2^(target/min)) where min is the smallest candidate (since each number can be reused many times).
Space: O(target/min) recursion depth + result storage.

âœ… Example (candidates = [2,3,6,7], target = 7)

Recursion tree:

[]
â”œâ”€â”€ [2] (target=5)
â”‚    â”œâ”€â”€ [2,2] (target=3)
â”‚    â”‚    â”œâ”€â”€ [2,2,2] (target=1) âœ˜ stop
â”‚    â”‚    â””â”€â”€ [2,2,3] (target=0) âœ”
â”‚    â””â”€â”€ [2,3] (target=2)
â”‚         â””â”€â”€ [2,3,3] (target=-1) âœ˜ stop
â”œâ”€â”€ [3] (target=4)
â”‚    â””â”€â”€ [3,3] (target=1) âœ˜ stop
â”œâ”€â”€ [6] (target=1) âœ˜ stop
â””â”€â”€ [7] (target=0) âœ”


âœ… Result

[[2,2,3], [7]]


ğŸ‘‰ Problem: Kth Largest Element in a Stream (LeetCode 703)

âœ… Key Idea

We want to maintain the kth largest element in a dynamic stream of numbers.
Use a min-heap of size k to keep track of the top k largest elements.
The smallest element in this heap is always the kth largest overall.
For each new number added:
Push it into the heap.

If heap size > k â†’ pop the smallest.

Return the root of the heap â†’ kth largest.

âœ¨ Flashcard
"Keep a min-heap of size k â†’ smallest element is kth largest â†’ push new numbers â†’ pop if heap exceeds k."

âš¡ Full Approach

Constructor (__init__)
Store k in self.k.
Convert nums into a min-heap using heapq.heapify.
Remove extra elements if nums has more than k elements:

while len(self.min_heap) > k:
    heapq.heappop(self.min_heap)


Add method (add)
Push the new value into the heap.
If heap size > k â†’ pop the smallest element.
Return self.min_heap[0] â†’ the kth largest number.

Why this works:
The heap always contains the k largest numbers seen so far.
The root of the min-heap is the smallest among these k numbers, i.e., the kth largest in the whole stream.

â±ï¸ Complexity
__init__:
Heapify â†’ O(n)
Trim heap to size k â†’ O(n log n) in worst case
add(val) â†’ O(log k) per insertion
Space â†’ O(k) (only store k largest numbers)

âœ… Example (k=3, nums=[4,5,8,2])

kthLargest = KthLargest(3, [4,5,8,2])
kthLargest.add(3)   # return 4
kthLargest.add(5)   # return 5
kthLargest.add(10)  # return 5
kthLargest.add(9)   # return 8
kthLargest.add(4)   # return 8


Heap evolution (min-heap shown as tree):

Initial heap (size 3):

        4
       / \
      5   8


Add 3 â†’ ignored (heap size > k):

        4
       / \
      5   8


kth largest = 4

Add 5 â†’ pop 4:

        5
       / \
      5   8


kth largest = 5

Add 10 â†’ pop 5:

        5
       / \
      10  8


kth largest = 5

Add 9 â†’ pop 5:

        8
       / \
      10  9


kth largest = 8

Add 4 â†’ ignored (heap size > k):

        8
       / \
      10  9


kth largest = 8

âœ… Result

[null, 4, 5, 5, 8, 8]

null â†’ corresponds to the constructor call (no return value)
Rest â†’ results of add() calls


ğŸ‘‰ Problem: Last Stone Weight (LeetCode 1046)

âœ… Key Idea

We always smash the two heaviest stones together.
After each smash:
If equal â†’ both destroyed
If not equal â†’ remaining stone = y - x (heavier minus lighter)
To efficiently find the two largest stones each turn â†’ use a max-heap.

âœ¨ Flashcard
"Use a max-heap to always get the two largest stones. Smash them. Push the result if non-zero."

âš¡ Full Approach

Convert all stones to a max-heap.
Python heapq is min-heap, so store -stone to simulate max-heap.

While more than one stone remains:
Pop the two largest stones (x and y)

If x != y â†’ push back the difference (y - x)
If x == y â†’ both are destroyed (do nothing)

Return the remaining stone (or 0 if heap is empty).

â±ï¸ Complexity

Heapify: O(n)

Each smash operation: O(log n) per push/pop
Max total operations â‰ˆ n â†’ O(n log n)
Space: O(n) (heap storage)

âœ… Example 1

stones = [2,7,4,1,8,1]

Heap evolution:
Heap â†’ [8,7,4,2,1,1]
Smash 8 & 7 â†’ new stone 1 â†’ [4,2,1,1,1]
Smash 4 & 2 â†’ new stone 2 â†’ [2,1,1,1]
Smash 2 & 1 â†’ new stone 1 â†’ [1,1,1]
Smash 1 & 1 â†’ both destroyed â†’ [1]

âœ… Last stone weight = 1

âœ… Example 2

stones = [1]
Only one stone â†’ return 1


ğŸ‘‰ Problem: K Closest Points to Origin (LeetCode 973)

âœ… Key Idea

We need to find the k closest points to the origin (0, 0).
The distance formula is âˆš(xÂ² + yÂ²), but we can skip the square root since it doesnâ€™t affect ordering.

To efficiently track the k smallest distances, we use a max-heap of size k.
This way, the farthest point among the current k is always on top â€” if we find a closer point, we remove the farthest.

âœ¨ Flashcard
"Use a max-heap of size k to keep the closest k points â€” push negative distance since Pythonâ€™s heapq is a min-heap."

âš¡ Full Approach

1ï¸âƒ£ Initialize an empty heap max_heap.
2ï¸âƒ£ For each point (x, y):

Compute the squared distance dist = x*x + y*y.

Push (-dist, x, y) into the heap (negative for max-heap behavior).
3ï¸âƒ£ If heap size > k: remove one element using heapq.heappop(max_heap) â€” this ensures only k closest points remain.
4ï¸âƒ£ Return the coordinates from the heap, ignoring the distance values.

â±ï¸ Complexity

Time: O(n log k) â†’ each push/pop takes O(log k), and we process n points.

Space: O(k) â†’ heap stores only k elements.

âœ… Example 1

points = [[1,3], [-2,2]]
k = 1

Steps:

dist(1,3) = 10 â†’ push (-10, 1, 3)

dist(-2,2) = 8 â†’ push (-8, -2, 2)
â†’ heap has size 2 > 1 â†’ pop (-10, 1, 3)

Remaining heap â†’ [(-8, -2, 2)]
âœ… Closest point = [[-2, 2]]

âœ… Example 2

points = [[3,3], [5,-1], [-2,4]]
k = 2

Heap evolution:

Push (-18, 3, 3)
Push (-26, 5, -1)
Push (-20, -2, 4) â†’ size > 2 â†’ pop (-26, 5, -1)

Remaining heap â†’ [(-20, -2, 4), (-18, 3, 3)]
âœ… Closest points = [[-2, 4], [3, 3]]

ğŸ‘‰ Problem: Contains Duplicate (LeetCode 217)

simple hashmap or set

ğŸ‘‰ Problem: LRU Cache (LeetCode 146)

âœ… Key Idea

An LRU (Least Recently Used) Cache evicts the least recently accessed item when capacity is exceeded.
We need O(1) average time for both get and put.

To achieve this efficiently:
Use a hash map (dictionary) for fast key â†’ node lookup.

Use a doubly linked list to track recently used order:
Head â†’ most recently used
Tail â†’ least recently used

On access or insertion, move the node to the head.
If capacity is exceeded, remove the tail node.

âœ¨ Flashcard
"LRU cache â†’ hash map for O(1) lookup, doubly linked list for O(1) eviction and ordering."

âš¡ Full Approach

1ï¸âƒ£ Node Structure:

Each node stores key, value, prev, and next.

2ï¸âƒ£ Doubly Linked List:

Maintain dummy head and tail to simplify insertions/removals.
New or recently accessed nodes are moved to head.
The tailâ€™s previous node is the least recently used.

3ï¸âƒ£ Hash Map:

Maps key â†’ node for O(1) lookup.

4ï¸âƒ£ Get Operation:

If key exists â†’ move node to head â†’ return value.
Else â†’ return -1.

5ï¸âƒ£ Put Operation:

If key exists â†’ update value â†’ move node to head.
Else â†’ create new node â†’ insert at head.

If capacity exceeded â†’ remove tail node and delete from hash map.

â±ï¸ Complexity

Get: O(1) time, O(capacity) space
Put: O(1) time, O(capacity) space
Overall space: O(capacity) for storing the doubly linked list nodes and the hash map

âœ… Example Walkthrough

Capacity = 2
Operations:
put(1,1) â†’ cache: {1=1}
put(2,2) â†’ cache: {1=1, 2=2}
get(1)    â†’ returns 1, cache order updated: 1 is MRU
put(3,3) â†’ LRU key 2 removed, cache: {1=1, 3=3}
get(2)    â†’ -1 (not found)
put(4,4) â†’ LRU key 1 removed, cache: {4=4, 3=3}
get(1)    â†’ -1 (not found)
get(3)    â†’ 3
get(4)    â†’ 4


ğŸ‘‰ Problem: Design HashSet (LeetCode 705)

âœ… Key Idea

A HashSet stores unique keys and supports three main operations efficiently:
Add â†’ insert a key
Remove â†’ delete a key
Contains â†’ check if a key exists

To achieve this efficiently, we use:
Hash function â†’ maps a key to a bucket (an index in a list of buckets)
Buckets â†’ each bucket is a small list storing keys that share the same hash
Separate chaining â†’ handles collisions by storing multiple keys in the same bucket

âœ¨ Flashcard
"HashSet â†’ stores unique keys with O(1) average operations using hashing and separate chaining."

âš¡ Full Approach

1ï¸âƒ£ Initialization

Create a fixed number of buckets (empty lists).
Each bucket will store keys that hash to its index.

2ï¸âƒ£ Hash Function

Converts any key into a bucket index using modulo (key % number_of_buckets).
Ensures the key is placed in a valid bucket.

3ï¸âƒ£ Add Operation

Compute the bucket index for the key using the hash function.
Go to that bucket.
If the key is not already in the bucket, add it.
This ensures all keys in the set are unique.

4ï¸âƒ£ Remove Operation

Compute the bucket index for the key.
Go to that bucket.
If the key exists, remove it.
If not, do nothing.

5ï¸âƒ£ Contains Operation

Compute the bucket index for the key.
Go to the corresponding bucket.
Return True if the key exists, otherwise False.

â±ï¸ Complexity

Add / Remove / Contains: O(1) average time
Space: O(n), where n is the number of keys stored
Worst case: O(n) if all keys collide into a single bucket, but rare for a good hash function

âœ… Example Walkthrough

Add 1 â†’ stored in bucket based on its hash â†’ set = [1]
Add 2 â†’ stored in its bucket â†’ set = [1, 2]
Check if 1 exists â†’ found â†’ True
Check if 3 exists â†’ not found â†’ False
Add 2 again â†’ ignored, because itâ€™s already present
Remove 2 â†’ deleted â†’ set = [1]
Check if 2 exists â†’ False


ğŸ‘‰ Problem: Design HashMap (LeetCode 706)

âœ… Key Idea

A HashMap stores key-value pairs and supports three main operations efficiently:

Put â†’ insert or update a key-value pair
Get â†’ retrieve the value for a key
Remove â†’ delete a key and its value

To achieve this efficiently, we use:

Hash function â†’ maps a key to a bucket (an index in a list of buckets)
Buckets â†’ each bucket is a small list storing key-value pairs that share the same hash
Separate chaining â†’ handles collisions by storing multiple key-value pairs in the same bucket

âœ¨ Flashcard
"HashMap â†’ stores key-value pairs with O(1) average operations using hashing and separate chaining."

âš¡ Full Approach

1ï¸âƒ£ Initialization

Create a fixed number of buckets (empty lists).
Each bucket will store key-value pairs that hash to its index.

2ï¸âƒ£ Hash Function

Converts any key into a bucket index using modulo (key % number_of_buckets).
Ensures the key is placed in a valid bucket.

3ï¸âƒ£ Put Operation

Compute the bucket index for the key using the hash function.
Go to that bucket.
If the key already exists in the bucket, update its value.
Otherwise, append a new [key, value] pair.

4ï¸âƒ£ Get Operation

Compute the bucket index for the key.
Go to the corresponding bucket.
Search for the key in the bucket.
Return its value if found, otherwise return -1.

5ï¸âƒ£ Remove Operation

Compute the bucket index for the key.
Go to the corresponding bucket.
Search for the key.
If found, remove the key-value pair.
If not found, do nothing.

â±ï¸ Complexity

Put Operation: O(1) average â€“ hash function maps key to bucket, and bucket size is small.
Get Operation: O(1) average â€“ locate bucket and search within it.
Remove Operation: O(1) average â€“ locate bucket and remove key-value pair if exists.
Space Complexity: O(n) â€“ stores all key-value pairs in buckets.
Worst-case: O(n) â€“ if all keys hash to the same bucket, operations degrade to linear time.

âœ… Example Walkthrough

Put (1, 100) â†’ stored in bucket based on hash â†’ map = {1:100}
Put (2, 200) â†’ stored in its bucket â†’ map = {1:100, 2:200}
Get 1 â†’ found â†’ returns 100
Get 3 â†’ not found â†’ returns -1
Put (2, 250) â†’ updates existing key â†’ map = {1:100, 2:250}
Remove 2 â†’ deletes key 2 â†’ map = {1:100}
Get 2 â†’ not found â†’ returns -1

This approach ensures all operations are efficient and handles collisions safely using separate chaining.


ğŸ‘‰ Problem: Number of Islands (LeetCode 200)
âœ… Key Idea

You are given a grid of '1's (land) and '0's (water).
An island is a group of '1's connected vertically or horizontally.
You need to count how many distinct islands exist in the grid.

To solve this, we use Depth-First Search (DFS) to explore each island completely and mark its cells as visited.

âœ¨ Flashcard:
â€œUse DFS or BFS to explore connected land cells and count how many times you start a new exploration â€” thatâ€™s your number of islands.â€

âš¡ Full Approach
1ï¸âƒ£ Initialization

Find grid dimensions: ROWS, COLS.

Create a visit set to track visited cells.

Initialize islands = 0.

2ï¸âƒ£ DFS Traversal

We define a helper function dfs(r, c) that:

Stops if the cell is out of bounds, already visited, or water ('0').

Otherwise, marks the current cell as visited and recursively explores its 4 neighbors:

Up â†’ dfs(r-1, c)

Down â†’ dfs(r+1, c)

Left â†’ dfs(r, c-1)

Right â†’ dfs(r, c+1)

3ï¸âƒ£ Counting Islands

Traverse every cell (r, c) in the grid.

When you find a '1' that hasnâ€™t been visited:

It means a new island has been found.

Call dfs(r, c) to mark the whole island.

Increment the islands counter by 1.

4ï¸âƒ£ Return the Result

After the loop ends, return islands.

â±ï¸ Complexity
Operation	Time Complexity	Space Complexity
DFS on all cells	O(ROWS Ã— COLS)	O(ROWS Ã— COLS) (recursive stack + visited set)

Even though DFS is recursive, each cell is visited exactly once, making it linear in total cells.

âœ… Example Walkthrough

Input Grid:

1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1


Step-by-step:

Start at (0,0): new island â†’ mark all connected land â†’ island count = 1

(0,1), (1,0), (1,1) already visited.

Move to (2,2): new island â†’ count = 2

Move to (3,3): new island â†’ count = 3

âœ… Output: 3

ğŸ§  Summary

DFS (or BFS) is ideal for exploring connected components.

Every new unvisited '1' cell starts a DFS â†’ represents a new island.

Time complexity stays linear with respect to the grid size.

ğŸ‘‰ Problem: Max Area of Island (LeetCode 695)

âœ… Key Idea

You are given a binary grid representing water (0) and land (1).
An island is a group of connected 1s (land) connected vertically or horizontally.
The area of an island is the number of connected land cells.
Your task is to find the maximum area among all islands.

To solve this, we use Depth-First Search (DFS) to explore each island and calculate its area.

âœ¨ Flashcard:
â€œUse DFS to explore every island and calculate its size â€” track the largest one to find the maximum area.â€

âš¡ Full Approach

1ï¸âƒ£ Initialization

Compute grid dimensions â†’ ROWS, COLS.

Create a visit set to track which cells have been visited.

Initialize max_area = 0 to store the largest island area.

2ï¸âƒ£ DFS Traversal
Define a recursive helper function dfs(r, c) that:

Returns 0 if the cell is out of bounds, already visited, or water (0).

Otherwise:

Marks the cell as visited.

Initializes area = 1 for the current land cell.

Recursively explores the 4 directions (up, down, left, right).

Returns the total accumulated area for that island.

3ï¸âƒ£ Main Loop

Iterate through every cell (r, c) in the grid.

When a land cell (1) is found thatâ€™s not visited:

Call dfs(r, c) to compute its area.

Update max_area = max(max_area, returned_area).

4ï¸âƒ£ Return the Result
After exploring all cells, return max_area â€” the largest island area found.

â±ï¸ Complexity Analysis

Operation	Time Complexity	Space Complexity
DFS on all cells	O(ROWS Ã— COLS)	O(ROWS Ã— COLS) (due to recursion + visited set)

Each cell is processed once, so the solution is linear in the number of grid cells.

âœ… Example Walkthrough

Input Grid:

[
 [0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]
]


Step-by-step:

Find land at (0,2): DFS explores â†’ area = 1

Find land at (0,7): DFS explores â†’ area = 6

Continue exploring all islands

Largest island area = 6

âœ… Output: 6

ğŸ§  Summary

Each DFS call explores one island and returns its area.

Keep track of the largest area found.

Same DFS idea as Number of Islands, but instead of counting islands, we measure their size.


ğŸ‘‰ Problem: Shortest Path in Binary Matrix (LeetCode 1091)

âœ… Key Idea

You are given an n x n binary grid where 0 represents an empty cell and 1 represents a blocked cell.
A clear path is a path from the top-left cell (0, 0) to the bottom-right cell (n-1, n-1) moving 8-directionally (horizontal, vertical, or diagonal).
The task is to return the length of the shortest clear path or -1 if no path exists.

We use Breadth-First Search (BFS) because it explores the nearest cells first, ensuring the first time we reach the target is the shortest path.

âœ¨ Flashcard:
â€œBFS in a grid â†’ explore level by level, track path length by levels, mark visited to avoid revisits. Guarantees shortest path in unweighted grids.â€

âš¡ Full Approach

1ï¸âƒ£ Initialization

Compute grid size â†’ n = len(grid).

Check start or end cell: if grid[0][0] == 1 or grid[n-1][n-1] == 1, return -1.

Initialize queue with the starting cell (0, 0).

Initialize visited set to track visited cells.

Set length = 1 to count the starting cell.

2ï¸âƒ£ BFS Traversal

Define 8 directions for movement: up, down, left, right, and 4 diagonals.

While queue is not empty:

For each cell in the current level:

Pop cell (r, c) from queue.

If (r, c) is the destination (n-1, n-1), return length.

Explore all 8 neighbors (nr, nc):

Skip if out of bounds, blocked, or visited.

Otherwise, append (nr, nc) to the queue and mark visited.

Increment length after processing all cells at the current level.

3ï¸âƒ£ Termination

If the queue empties without reaching the target, return -1 â€” no path exists.

â±ï¸ Complexity Analysis

Operation	Time Complexity	Space Complexity
BFS traversal	O(nÂ²)	O(nÂ²) (queue + visited set)

âœ… Example Walkthrough

Input Grid:

[
 [0,0,0],
 [1,1,0],
 [1,1,0]
]


Step-by-step:

Start at (0,0) â†’ enqueue neighbors (0,1), (1,1), (1,0) if valid.

Level 1 â†’ move to (0,1) and (1,2) etc.

Continue BFS level by level.

Reach (2,2) after 4 steps â†’ shortest path = 4.

âœ… Output: 4

ğŸ§  Summary

BFS guarantees shortest path in an unweighted grid.
Track path length by BFS levels.
Visited set prevents revisiting cells.
Include all 8-directional moves to explore diagonals.

ğŸ‘‰ Problem: Rotting Oranges (LeetCode 994)

âœ… Key Idea

You are given an m x n grid where:

0 represents an empty cell,

1 represents a fresh orange,

2 represents a rotten orange.

Every minute, any fresh orange adjacent (4-directionally) to a rotten orange becomes rotten.
The task is to return the minimum number of minutes until all oranges are rotten, or -1 if impossible.

We use Breadth-First Search (BFS) to simulate the rotting process level by level, where each level corresponds to one minute.

âœ¨ Flashcard:
â€œBFS in a grid â†’ process rotten oranges level by level, rot adjacent fresh oranges, count minutes per BFS level. Returns -1 if unreachable fresh oranges remain.â€

âš¡ Full Approach

1ï¸âƒ£ Initialization

Compute grid dimensions â†’ ROWS = len(grid), COLS = len(grid[0]).

Initialize a queue for BFS.

Count total fresh oranges.

Add all initial rotten oranges to the queue.

2ï¸âƒ£ BFS Traversal

Define 4 directions for movement: up, down, left, right.

Initialize minutes = 0.

While the queue is not empty and fresh oranges remain:

For each orange in the current level (current minute):

Pop (r, c) from the queue.

For each neighbor (nr, nc):

Skip if out of bounds or not a fresh orange.

Otherwise, mark the orange as rotten, decrease fresh count, and add (nr, nc) to the queue.

Increment minutes after processing the current level.

3ï¸âƒ£ Termination

If all fresh oranges are rotten, return minutes.

Otherwise, return -1.

â±ï¸ Complexity Analysis

Operation	Time Complexity	Space Complexity
BFS traversal	O(m Ã— n)	O(m Ã— n) (queue)

âœ… Example Walkthrough

Input Grid:

[[2,1,1],
 [1,1,0],
 [0,1,1]]


Step-by-step:

Minute 0 â†’ rotten oranges at (0,0).

Minute 1 â†’ rot neighbors: (0,1), (1,0).

Minute 2 â†’ rot neighbors: (0,2), (1,1).

Minute 3 â†’ rot neighbors: (2,1).

Minute 4 â†’ rot neighbors: (2,2).

All oranges rotten â†’ return 4.

âœ… Output: 4

ğŸ§  Summary

BFS guarantees level-by-level rotting.
Track fresh oranges to determine if all can rot.
Each BFS level corresponds to 1 minute.

ğŸ‘‰ Problem: Clone Graph (LeetCode 133)

âœ… Key Idea
Use BFS to traverse the given graph node by node.
For each node, create its clone and connect cloned neighbors accordingly.
Maintain a clone_map to link each original node to its cloned copy.

âœ¨ Flashcard
â€œClone Graph â†’ Traverse original using BFS/DFS.
For each node: create clone, store mapping, and connect neighbors.â€

âš¡ Full Approach

1ï¸âƒ£ Check Base Case
If the input node is None, return None (empty graph).

2ï¸âƒ£ Create Mapping Dictionary
Use a clone_map to store the mapping between original and cloned nodes.
clone_map[orig_node] = cloned_node

3ï¸âƒ£ Traverse the Graph (BFS)

Use a queue initialized with the starting node.

For each node dequeued:

Traverse all its neighbors.

If a neighbor isnâ€™t cloned yet:

Create a new clone.

Add the neighbor to the queue for future processing.

Append the cloned neighbor to the cloned nodeâ€™s neighbor list.

4ï¸âƒ£ Return the Cloned Start Node
After BFS finishes, return the clone corresponding to the original start node.

ğŸ§  Why It Works

The BFS ensures we visit every node exactly once (since the graph is connected).

The mapping ensures:

No duplicate nodes are created.

Proper neighbor references are established.

â±ï¸ Complexity

Operation	Time	Space
Clone traversal	O(V + E)	O(V)
â€”	â€”	â€”
V = number of nodes	E = number of edges

âœ… Notes

Works for connected undirected graphs.

Can be easily rewritten using DFS recursion by replacing BFS with recursive traversal.

BFS avoids recursion depth issues for larger graphs.

ğŸ‘‰ Problem: Course Schedule (LeetCode 207)

âœ… Key Idea
Model the problem as a directed graph:

Each course = node

Each prerequisite pair [a, b] = edge b â†’ a (you must take b before a)

You can complete all courses iff the graph has no cycles.
If thereâ€™s a cycle (e.g., course A depends on B and B depends on A), itâ€™s impossible.
We detect cycles using Kahnâ€™s Algorithm (BFS-based topological sorting).

âœ¨ Flashcard

Topological Sort (BFS):
Queue all nodes with in-degree 0 â†’ pop â†’ reduce neighborsâ€™ in-degree â†’ repeat.
If all nodes processed â†’ no cycle â†’ valid course order.


âš¡ Step-by-Step Thinking Approach

Build an adjacency list to represent course dependencies.
Example:
prerequisites = [[1, 0], [2, 1]]
â‡’ 0 â†’ 1 â†’ 2


Count in-degrees (number of prerequisites per course).

Start BFS with all nodes having in-degree 0 (no prerequisites).

Take courses one by one, and reduce in-degree of dependent courses.

If a courseâ€™s in-degree becomes 0, itâ€™s ready to take.


If all courses are taken, it means no cycles exist â†’ return True.
Otherwise â†’ cycle detected â†’ return False.


â±ï¸ Complexity
OperationTimeSpaceBuild graphO(V + E)O(V + E)BFS traversalO(V + E)O(V)
Where V = numCourses, E = len(prerequisites).

âœ… Notes

Alternative DFS approach: detect cycles using recursion and a visiting set.
BFS (Kahnâ€™s algorithm) is often cleaner and more intuitive for this problem.


ğŸ‘‰ Problem: Unique Paths (LeetCode 62)

âœ… Key Idea
We need to count the number of unique paths from the top-left corner of an m x n grid to the bottom-right corner, moving only right or down at each step.

This can be modeled as a Dynamic Programming (DP) problem where each cell (r, c) represents the number of ways to reach the destination from that cell.

Each cellâ€™s value = number of ways right + number of ways down.

Formally:
dp[r][c] = dp[r + 1][c] + dp[r][c + 1]

âœ¨ Flashcard

Dynamic Programming (Bottom-Up)
Start from the destination (bottom-right), move backward to the start (top-left).
The last cell = 1 way (already at destination).
Each cell depends on the cell to its right and the cell below.

âš¡ Step-by-Step Thinking Approach

We initialize from the bottom-right of the grid since thatâ€™s our goal cell â€” only one way from there.

For each cell, the number of unique paths =
â†’ paths to the right cell + paths to the cell below.

We use 1D DP optimization:

Instead of a full grid, we keep only the current row and the row below it (prevRow).

Iterating backward ensures dependencies (right and below) are already computed.

Example (m = 3, n = 3):

Start â†’ (0,0)
â†“ â†“ â†“
Each cell counts possible paths:
[6, 3, 1]
[3, 2, 1]
[1, 1, 1]


Answer = 6

â±ï¸ Complexity

Operation	Time	Space
Build paths	O(m Ã— n)	O(n)

âœ… Notes

This is a combinatorial problem at heart:
Number of paths = C(m + n - 2, m - 1).

But DP solution is preferred when grid constraints are moderate or for learning recursion-to-DP conversion.

ğŸ‘‰ Problem: Unique Paths II (LeetCode 63)
âœ… Key Idea
This problem is an extension of Unique Paths (LeetCode 62) â€” but now, some cells contain obstacles (marked as 1), which the robot cannot pass through.
We still move only right or down, but must skip paths that lead into obstacles.
We use Dynamic Programming (DP) â€” each cell (r, c) represents the number of ways to reach the destination without stepping on obstacles.

âœ¨ Flashcard
DP Transition:
If grid[r][c] == 1 â†’ obstacle â†’ dp[r][c] = 0
Else â†’ dp[r][c] = dp[r+1][c] + dp[r][c+1]
We build the solution from bottom-right to top-left, skipping blocked cells.
âš¡ Step-by-Step Thinking Approach


Base Case:

If the destination (m-1, n-1) has an obstacle â†’ return 0 immediately (no path possible).

Otherwise, set dp[m-1][n-1] = 1 (one way to reach itself).

Iterate from bottom-right upward:

For each cell (r, c):
If itâ€™s an obstacle â†’ dp[r][c] = 0.
Else, dp[r][c] = dp[r+1][c] + dp[r][c+1] (if those exist).


Space Optimization:

Use 1D DP array (prevRow + curRow) instead of a full grid.
Start from the last row, process cells backward.

Final Answer:
The number of unique paths from top-left is dp[0][0].

ğŸ§© Example
Grid:
[0,0,0]
[0,1,0]
[0,0,0]

â†’ Start at (0,0), obstacle at (1,1)

DP Table (paths count):
[2, 2, 1]
[1, 0, 1]
[1, 1, 1]
Answer = 2

â±ï¸ Complexity
OperationTimeSpaceDP traversalO(m Ã— n)O(n)

âœ… Notes
Handle edge cases carefully:
If start or end is blocked â†’ return 0.
Works efficiently for m, n â‰¤ 100.
Conceptually identical to LeetCode 62, except we skip blocked cells.


ğŸ‘‰ Problem: Longest Common Subsequence (LeetCode 1143)

âœ… Key Idea

We are given two strings, text1 and text2, and we need to find the length of their longest common subsequence (LCS) â€” a sequence that appears in both strings in the same order, but not necessarily contiguously.

Example:
text1 = "abcde"
text2 = "ace"
â†’ Longest Common Subsequence = "ace"
â†’ Length = 3

To solve this, we use Dynamic Programming (DP) â€” specifically a bottom-up approach optimized to use only O(m) space.

âœ¨ Flashcard:
â€œCompare characters from the end of both strings.
If they match â†’ add 1 + diagonal value.
If not â†’ take the max from right or down.
Build up the LCS length using only two rows.â€

âš¡ Full Approach

1ï¸âƒ£ Initialization

Let n = len(text1) and m = len(text2).
We create two 1D arrays:
prevRow â†’ represents results for text1[i+1:]
curRow â†’ represents results for text1[i:]
Initialize both with zeros of length m + 1.

2ï¸âƒ£ Bottom-Up DP Traversal

Traverse text1 and text2 backward (from end to start).
For each pair (i, j):

If characters match (text1[i] == text2[j]):
â†’ The LCS includes this character.
â†’ curRow[j] = 1 + prevRow[j + 1]

Else:
â†’ Skip one character from either string.
â†’ curRow[j] = max(prevRow[j], curRow[j + 1])

After finishing one row, assign:
prevRow = curRow

3ï¸âƒ£ Final Answer

Once all rows are processed, prevRow[0] holds the LCS length for the full strings.

â±ï¸ Complexity Analysis

Operation	Time Complexity	Space Complexity
DP traversal	O(n Ã— m)	O(m)

Each character pair is compared once, and only one row is stored at a time.

âœ… Example Walkthrough

Input:

text1 = "abcde"
text2 = "ace"

DP Computation:
Compare from the end:
text1[i] = 'e', text2[j] = 'e' â†’ match â†’ +1
...
Final DP row = [3, 2, 1, 0]

Output:
3

Because the longest common subsequence is "ace".

ğŸ§  Summary

We use bottom-up dynamic programming to build the LCS from the end.

Matching chars â†’ 1 + diagonal.

Non-matching â†’ max(right, down).

Optimized to O(m) space with two rows only.

âœ… Result: Efficient, elegant, and scalable for strings up to 1000 characters.

âœ… Summary (Mental Model)

Make a grid of all character positions.
Fill bottom-right to top-left using:
Match â†’ diagonal + 1
No match â†’ max(right, down)
Top-left â†’ LCS length of full strings.
Backtrack diagonally to reconstruct the subsequence.


What is LCS?

You have two strings.
A subsequence is a string you get by deleting some characters without changing the order.
Example: "ace" is a subsequence of "abcde".
A common subsequence appears in both strings.

Longest Common Subsequence (LCS) is the common subsequence with the maximum length.

Perfect! Letâ€™s go through a step-by-step example of LCS textually, without any code.

Weâ€™ll use:

text1 = "abcde"
text2 = "ace"

Step 1: Start from the end of both strings

Last character of text1 = "e"

Last character of text2 = "e"

They match, so this "e" is part of the LCS.

Move to the previous characters in both strings:

text1 now: "abcd"
text2 now: "ac"
LCS so far: "e"

Step 2: Compare new last characters

Last character of text1 = "d"

Last character of text2 = "c"

They donâ€™t match, so we have two options:

Ignore "d" in text1 â†’ compare "abc" and "ac"

Ignore "c" in text2 â†’ compare "abcd" and "a"

We choose the option that gives the longer LCS.

Step 3: Explore both options

Option 1: "abc" vs "ac"

Last characters "c" vs "c" â†’ match, include "c"

Move to "ab" vs "a" â†’ last chars "b" vs "a" â†’ donâ€™t match

Only "a" matches â†’ LCS = "ac"

Option 2: "abcd" vs "a"

Last chars "d" vs "a" â†’ donâ€™t match

Skip "d" â†’ "abc" vs "a"

Last chars "c" vs "a" â†’ donâ€™t match

Skip "c" â†’ "ab" vs "a"

Last chars "b" vs "a" â†’ donâ€™t match

Skip "b" â†’ "a" vs "a" â†’ match, include "a"

LCS = "a"

âœ… Pick the longer one, which is "ac"

Step 4: Add the previous match

Remember we matched "e" in Step 1

Add it to "ac" â†’ LCS = "ace"

Step 5: Final LCS

"ace" is the longest common subsequence

Length = 3

Key Observations

Always compare last characters of current substrings.

If match â†’ include and move diagonally.

If no match â†’ try skipping one character from either string.

Always pick the option giving the longer subsequence.

Repeat until all characters are processed.

âœ… Summary in Words

Think of LCS as picking letters from both strings in order.

Matching letters are included.

Non-matching letters â†’ decide which to skip for a longer sequence.

Build the solution step by step from the end toward the start.


ğŸ‘‰ Problem type: Bit Manipulation â€“ Brian Kernighanâ€™s Algorithm - Number of 1 Bits (LeetCode 191)

âœ¨ Flashcard:
â€œUse Brian Kernighanâ€™s trick â†’ n &= (n - 1) drops the lowest set bit each time.â€

âš¡ Full Approach

We need to count how many 1 bits (set bits) a number has in its binary representation.

ğŸ”¥ Key Idea: Brian Kernighanâ€™s Algorithm

Instead of checking every bit, we repeatedly remove the lowest set bit using:

n &= (n - 1)


Why this works:

n - 1 flips all bits after the lowest set bit.

ANDing with n removes the rightmost 1.

Each iteration removes exactly one set bit.

Number of iterations = number of 1 bits.

ğŸ§  Steps

Initialize count = 0.

While n is not zero:

Do n &= (n - 1) â†’ removes the lowest set bit.

Increment count.

Return count.

ğŸ“ Notes

The algorithm is efficient because:

#Skips Zero Bits Efficiently

Instead of checking every bit (32 times), the loop runs only for each 1 bit in n.

#Direct Bit Manipulation

By removing one set bit at a time, you avoid unnecessary iterations.

#Works in O(k)

Where k = number of set bits, which is usually much smaller than 32.

#No Extra Space

The operation modifies n directly without needing additional memory.

â±ï¸ Complexity

Time: O(k) â†’ where k = number of 1 bits
(Worst case: O(32) for a 32-bit number)

Space: O(1) â†’ constant space

ğŸ‘‰ Problem type: Bit Manipulation â€“ Counting Bits (LeetCode 338)

âœ¨ Flashcard:
â€œNumber of 1s in i = number of 1s in i divided by 2 + 1 if last bit is 1â€

âš¡ Full Approach

We need to return an array ans where ans[i] represents the number of 1s in the binary representation of i for all i from 0 to n.

ğŸ”¥ Key Idea: Dynamic Programming + Bit Manipulation

Instead of converting each number to binary and counting 1s:

Observe that the binary of i can be split into:

Main part: i >> 1 â†’ all bits except the last bit.

Last bit: i & 1 â†’ 1 if last bit is set, 0 otherwise.

If we already know ans[i >> 1] â†’ number of 1s in the main part,
then adding (i & 1) gives the total number of 1s in i.

ğŸ§  Steps

Initialize ans = [0] * (n + 1) â†’ ans[0] = 0 since 0 has no 1s.

Loop from i = 1 to n:

Compute ans[i] = ans[i >> 1] + (i & 1)

i >> 1 â†’ removes last bit (smaller number, already computed)

i & 1 â†’ adds 1 if last bit is 1

Return ans.

ğŸ“ Notes

Dynamic Programming: Each number uses the result of a smaller number (i >> 1) â†’ efficient O(n).

Bit Manipulation: (i & 1) directly gives the last bit without converting to binary.

Linear Time: Each number is processed once.

No Extra Space: Only stores the answer array.

â±ï¸ Complexity

Time: O(n) â†’ compute once for each number from 1 to n

Space: O(n) â†’ store answers for all numbers from 0 to n


