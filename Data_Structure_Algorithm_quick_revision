ğŸ‘‰ Type: Static Array

1. Insert at End

âœ¨ Flashcard
"Place at arr[length] â†’ increment length."

âš¡ Full Approach
Steps:

Check if thereâ€™s capacity (length < capacity).
Insert the new value at arr[length].
Return updated length (length + 1).

â±ï¸ Complexity

Time: O(1) â†’ Direct insertion.
Space: O(1) â†’ No extra memory.

2. Remove from End

âœ¨ Flashcard
"Clear arr[length-1] â†’ decrement length."

âš¡ Full Approach
Steps:

Check if the array is non-empty (length > 0).
Reset last element (arr[length-1] = 0).
Return updated length (length - 1).

â±ï¸ Complexity

Time: O(1) â†’ Direct removal.
Space: O(1) â†’ No extra memory.

3. Insert in Middle

âœ¨ Flashcard
"Shift right â†’ place value â†’ increment length."

âš¡ Full Approach
Steps:

Start from the last real element (length - 1) down to i.
Shift each element one step to the right (arr[index + 1] = arr[index]).
Insert the value at position i.
Return updated length (length + 1).

â±ï¸ Complexity

Time: O(n) â†’ Shifting elements.
Space: O(1) â†’ No extra memory.

4. Remove from Middle

âœ¨ Flashcard
"Shift left â†’ clear last slot â†’ decrement length."

âš¡ Full Approach
Steps:

Start from i+1 to the end (length - 1).
Shift elements one step to the left (arr[index-1] = arr[index]).
Reset last slot (arr[length-1] = 0).
Return updated length (length - 1).

â±ï¸ Complexity

Time: O(n) â†’ Shifting elements.
Space: O(1) â†’ No extra memory.

5. Print Array

âœ¨ Flashcard
"Loop from 0 â†’ capacity â†’ print each value."

âš¡ Full Approach
Steps:

Loop through 0 to capacity-1.
Print each arr[i].

â±ï¸ Complexity

Time: O(n) â†’ Iterate through array.

Space: O(1) â†’ No extra memory.

ğŸ‘‰ Type: Stack (Dynamic Array)

1. Push (Insert at Top)

âœ¨ Flashcard
"Append to list â†’ top grows upward."

âš¡ Full Approach
Steps:

Call append(n) to add element at the end of the list.
The new element becomes the top of the stack.

â±ï¸ Complexity

Time: O(1) â†’ Direct append.
Space: O(1) â†’ No extra memory (except element storage).

2. Pop (Remove from Top)

âœ¨ Flashcard
"Pop last â†’ return top element."

âš¡ Full Approach
Steps:

Call pop() to remove the last element.
Return the removed element (the previous top).

â±ï¸ Complexity

Time: O(1) â†’ Direct pop from end.
Space: O(1) â†’ No extra memory.

ğŸ‘‰ Type: Singly Linked List

1. Insert Node at End

âœ¨ Flashcard
"Create new_node â†’ link tail.next â†’ move tail."

âš¡ Full Approach
Steps:

Create a new node (new_node = ListNode(val)).
Link the current tail node to the new node (self.tail.next = new_node).
Move self.tail to point to the new node (self.tail = new_node).

â±ï¸ Complexity

Time: O(1) â†’ Direct tail reference.
Space: O(1) â†’ No extra memory.

2. Remove Node at Given Index

âœ¨ Flashcard
"Traverse to node before target â†’ skip target â†’ update tail if last node removed."

âš¡ Full Approach
Steps:

Start from the dummy head node (curr = self.head).
Use a for loop to move curr forward index times.
If curr.next is None, index is out of range â†’ exit function.

Once at the node before the target, update link:
curr.next = curr.next.next

If we removed the last node, update:
self.tail = curr

â±ï¸ Complexity

Time: O(n) â†’ Traverses up to index.
Space: O(1) â†’ In-place modification.

ğŸ‘‰ Type: Doubly Linked List

1. Insert at Front
Key principle When inserting a node:
Link the new node to the existing nodes first. Then update the dummy node (head or tail) to point to the new node.

âœ¨ Flashcard
"Create a new node â†’ link between head and first real node."

head -> 5 -> 10 -> 20 -> tail       think with this example list for easier visualization

âš¡ Full Approach
Steps:

Create a new_node with the value.
Set new_node.prev = head.
Set new_node.next = head.next (the old first node).
Update the old first nodeâ€™s prev to point to new_node.
Update head.next to point to new_node.

â±ï¸ Complexity

Time: O(1) â†’ Direct pointer updates.
Space: O(1) â†’ No extra memory.

2. Insert at End

âœ¨ Flashcard
"Create a new node â†’ link between last node and tail."

head -> 5 -> 10 -> 20 -> tail

âš¡ Full Approach
Steps:

Create a new_node with the value.
Set new_node.next = tail.
Set new_node.prev = tail.prev (the old last node).
Update the old last nodeâ€™s next to point to new_node.
Update tail.prev to point to new_node.

â±ï¸ Complexity

Time: O(1)
Space: O(1)

3. Remove from Front
Key principle When removing a node:
Reconnect the previous and next nodes to each other first, then detach the target node.

âœ¨ Flashcard
"Skip the first node by connecting head to the second node."

head -> 5 -> 10 -> 20 -> tail


âš¡ Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update head.next to point to the second node.
Update the second nodeâ€™s prev to point to head.

â±ï¸ Complexity

Time: O(1)
Space: O(1)

4. Remove from End

âœ¨ Flashcard
"Skip the last node by connecting tail to the second-last node."

head -> 5 -> 10 -> 20 -> tail

âš¡ Full Approach
Steps:

Check if the list is empty (head.next == tail).
If empty, print "List is empty" and return.
Update tail.prev to point to the second-last node.
Update the second-last nodeâ€™s next to point to tail.

â±ï¸ Complexity

Time: O(1)
Space: O(1)

5. Print List

âœ¨ Flashcard
"Traverse from head to tail, printing each value."

âš¡ Full Approach
Steps:

Start at the node after head.
Keep moving forward using next.
Print each nodeâ€™s value until reaching tail.

â±ï¸ Complexity

Time: O(n) â†’ Must traverse all nodes.
Space: O(1) â†’ No extra memory.

ğŸ”¹ When to use deque vs list?
Use deque when you need fast appends/pops from both ends (O(1) time).
Use list when you need fast random access (indexing, slicing).
ğŸ‘‰ Type: Queue (Linked List with Dummy Node)

1. Enqueue (Insert at Tail)

âœ¨ Flashcard
"Create a new node â†’ attach to tail.next â†’ move tail pointer."

âš¡ Full Approach
Steps:
Create a new node with the given value.
Link the current tail.next to this new node.
Update tail to point to the new node.

â±ï¸ Complexity

Time: O(1) â†’ Constant-time insertion at the end.
Space: O(1) â†’ No extra memory besides the new node.

2. Dequeue (Remove from Head)

âœ¨ Flashcard
"Take value from head.next â†’ move head.next forward â†’ reset tail if empty."

âš¡ Full Approach

Steps:
If head.next is None, the queue is empty â†’ return None.
Store the value from head.next.val.
Update head.next to skip the removed node (head.next.next).
If the queue is now empty, reset tail = head.
Return the stored value.

â±ï¸ Complexity

Time: O(1) â†’ Constant-time removal from the front.
Space: O(1) â†’ No extra memory.